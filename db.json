{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/404.html","path":"404.html","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/404/404-NotFound.md","path":"404/404-NotFound.md","modified":0,"renderable":0},{"_id":"source/404/404-tencent.md","path":"404/404-tencent.md","modified":0,"renderable":0},{"_id":"source/404/404-cat.md","path":"404/404-cat.md","modified":0,"renderable":0},{"_id":"source/music/music_demo.ejs","path":"music/music_demo.ejs","modified":0,"renderable":0},{"_id":"source/photos/video_demo.ejs","path":"photos/video_demo.ejs","modified":0,"renderable":0},{"_id":"source/music/lrc/丁香花 - 唐磊.lrc","path":"music/lrc/丁香花 - 唐磊.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/举镜子的女孩 - 张子枫.lrc","path":"music/lrc/举镜子的女孩 - 张子枫.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/亲爱的旅人啊 - 周深.lrc","path":"music/lrc/亲爱的旅人啊 - 周深.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/何以爱情 - 钟汉良.lrc","path":"music/lrc/何以爱情 - 钟汉良.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/光年之外 - G.E.M.邓紫棋.lrc","path":"music/lrc/光年之外 - G.E.M.邓紫棋.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/可能否 - 木小雅.lrc","path":"music/lrc/可能否 - 木小雅.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/刚刚好 - 薛之谦.lrc","path":"music/lrc/刚刚好 - 薛之谦.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/在青春里遇见 - 卜冠今.lrc","path":"music/lrc/在青春里遇见 - 卜冠今.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/冬眠 - 司南.lrc","path":"music/lrc/冬眠 - 司南.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/大鱼 (Live) - 周深.lrc","path":"music/lrc/大鱼 (Live) - 周深.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/少年 (Live) - 梦然.lrc","path":"music/lrc/少年 (Live) - 梦然.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/平凡的一天 - 毛不易.lrc","path":"music/lrc/平凡的一天 - 毛不易.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/心如止水 - Ice Paper.lrc","path":"music/lrc/心如止水 - Ice Paper.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/忽而今夏 - 汪苏泷.lrc","path":"music/lrc/忽而今夏 - 汪苏泷.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/我和我的祖国 - 王菲.lrc","path":"music/lrc/我和我的祖国 - 王菲.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/所念皆星河 - 房东的猫.lrc","path":"music/lrc/所念皆星河 - 房东的猫.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc","path":"music/lrc/杏花弦外雨 - CRITTY,司夏.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/泡沫 - G.E.M.邓紫棋.lrc","path":"music/lrc/泡沫 - G.E.M.邓紫棋.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/成都 - 赵雷.lrc","path":"music/lrc/成都 - 赵雷.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/空空如也  - 任然.lrc","path":"music/lrc/空空如也  - 任然.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/若把你 - Kirsty刘瑾睿.lrc","path":"music/lrc/若把你 - Kirsty刘瑾睿.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/远方不远 - 徐薇.lrc","path":"music/lrc/远方不远 - 徐薇.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/蓝莲花 - 许巍.lrc","path":"music/lrc/蓝莲花 - 许巍.lrc","modified":0,"renderable":0},{"_id":"source/music/lrc/风铃 - 孟凡明.lrc","path":"music/lrc/风铃 - 孟凡明.lrc","modified":0,"renderable":0},{"_id":"source/photos/static/empty.png","path":"photos/static/empty.png","modified":0,"renderable":0},{"_id":"themes/new-yilia/source/css/avatarrotation.css","path":"css/avatarrotation.css","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/css/main.0cf68a.css","path":"css/main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/checkered-pattern.png","path":"fonts/checkered-pattern.png","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/default-skin.png","path":"fonts/default-skin.png","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/scrollbar_arrow.png","path":"fonts/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/preloader.gif","path":"fonts/preloader.gif","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/js/clipboard_use.js","path":"js/clipboard_use.js","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/js/main.0cf68a.js","path":"js/main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/js/mobile.992cbe.js","path":"js/mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/js/slider.e37972.js","path":"js/slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/img/alipay-min.png","path":"img/alipay-min.png","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/img/wechatpay-min.png","path":"img/wechatpay-min.png","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/js/snow.js","path":"js/snow.js","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/new-yilia/source/img/sanshui.png","path":"img/sanshui.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"db0fb60d61d361df08e7ab9fc4874ab46c69a4e4","modified":1634305877505},{"_id":"source/robots.txt","hash":"a9f1b3cb791e41216f34aedb7269c501f0365d8f","modified":1668866973170},{"_id":"source/README.md","hash":"f76bf17a7fdd19c5d498078e2ebaf059ff79e07f","modified":1669544216730},{"_id":"source/404/404-tencent.md","hash":"69a35a973e0b2d78a9ce20154e4da24c3adf1e32","modified":1633860875529},{"_id":"source/404/404-NotFound.md","hash":"776b570de0a9e075776dfcfea233e4e2bb1e4e0b","modified":1635242931245},{"_id":"source/404/404-cat.md","hash":"6fd1112559b32267abf19918a551803671b6ec7d","modified":1635339443794},{"_id":"source/_drafts/07 LeetCode刷题 Day3 链表 203.移除链表元素 707.设计链表 206.反转链表.md","hash":"fb769a9fb90bfe8e7adb4a766b381526ca3f33ef","modified":1669495131847},{"_id":"source/_drafts/用BusyBox制作最小根文件系统.md","hash":"20f1d733e3531c99cf6e058a3af478c3aa102416","modified":1640865379024},{"_id":"source/_drafts/论文阅读-Learning Rich Features for Image Manipulation Detection(CVPR 2018 - 图像篡改检测).md","hash":"da7b97a468f3215526c22b483e5ed4c7deef67e9","modified":1635420960420},{"_id":"source/_posts/01 从零开始搭建Hexo博客.md","hash":"96ab5f1d13a55f22510d9fc3162cfad19c43ddfc","modified":1669696170242},{"_id":"source/_posts/02 图像篡改检测技术及数据集总结.md","hash":"840892db441233b2e2e093091964eaeb4690aa19","modified":1669494906591},{"_id":"source/_drafts/公式.md","hash":"ab5096878dc07c8047167c28f992e6c449959fcb","modified":1660475791114},{"_id":"source/_posts/04 Linux内核裁剪及编译.md","hash":"233c0c78074b56bec6f352fb19b52681a31af352","modified":1669087051752},{"_id":"source/_posts/07 三水的笔记 Find Notes 上线.md","hash":"60f6cf5c1562cedb37e23d32a4c8ffa158e3a6af","modified":1669715001680},{"_id":"source/404.html","hash":"0df814e2b6cd4d8b7b855c0c1765fd70645a8ce3","modified":1635339730912},{"_id":"source/archives/index.md","hash":"fd37ef9af046e414022e882cc8c28c9d273b108d","modified":1669112166226},{"_id":"source/_drafts/模板.md","hash":"a03ffa89c24a2afd2d2072defa5fe7966305a6d3","modified":1640862593439},{"_id":"source/_posts/05 LeetCode刷题 Day1 数组 704. 二分查找 27. 移除元素.md","hash":"860d7dd8cce751f8c1b0ce53260ae1f4b70e01b2","modified":1669495016025},{"_id":"source/_posts/06 LeetCode刷题 Day2 数组 977.有序数组的平方 209.长度最小的子数组 59.螺旋矩阵II.md","hash":"cd7a5eee12515639c2ae8ecf6d8e38396917fc03","modified":1669495111513},{"_id":"source/categories/index.md","hash":"df8df3e3c7b8197709d21eae143da19a938d68a8","modified":1634117450950},{"_id":"source/music/aplayer_config.js","hash":"5243f9332f2fa38bf8131b7a97c63071794daacb","modified":1634386854769},{"_id":"source/music/music_demo.ejs","hash":"b929e83d546156b2bb2bc8761636f29d8e7e2364","modified":1634096670768},{"_id":"source/music/aplayer_page_config.js","hash":"048f08e2c3d95acc87631e780aba30419be5bac9","modified":1634386839891},{"_id":"source/photos/data.json","hash":"562b156952f322a39f40fbd0da91d710682826fa","modified":1661017564602},{"_id":"source/photos/video_demo.ejs","hash":"416839c05ce89074a05019abccdf8755cfc003cd","modified":1635088295399},{"_id":"source/music/index.md","hash":"d6b9c1cb5a0364ce4186bcb513db0428c831b04c","modified":1634305228964},{"_id":"source/photos/video.ejs","hash":"337a9cf0b9f0092e88bce7dea78540cbe5cfd813","modified":1635088924482},{"_id":"source/music/lrc/丁香花 - 唐磊.lrc","hash":"85c849a8a23e9db880ec8b99ff889a3bd180c165","modified":1634043556084},{"_id":"source/photos/index.ejs","hash":"1a182378336efb4caad387a273789a918c99d4b6","modified":1669354653577},{"_id":"source/music/lrc/举镜子的女孩 - 张子枫.lrc","hash":"a8a82b2472a64ca2b11d81d33d5c949add3d35b9","modified":1634387059222},{"_id":"source/music/lrc/光年之外 - G.E.M.邓紫棋.lrc","hash":"de9f1b77ebea81d3aa79da0dcfc218e8decdadfe","modified":1634044336732},{"_id":"source/music/lrc/何以爱情 - 钟汉良.lrc","hash":"341db046ab17e2564194cfe1c90b281ad0ec5c1d","modified":1634301786275},{"_id":"source/music/lrc/亲爱的旅人啊 - 周深.lrc","hash":"0db5a4cbefc899be30b1344800d11266c8d361b0","modified":1634047199008},{"_id":"source/music/lrc/可能否 - 木小雅.lrc","hash":"9f62b42154abc6e9bfc0adfd1f5089d20a67d26d","modified":1634043386772},{"_id":"source/music/lrc/刚刚好 - 薛之谦.lrc","hash":"09c0c2e7441d5cf8b15407b81b0962b8d3793ebf","modified":1634044267411},{"_id":"source/music/lrc/冬眠 - 司南.lrc","hash":"d4f35bd5372ba65d0452ef4eda59125c0c41837f","modified":1634043734142},{"_id":"source/music/lrc/少年 (Live) - 梦然.lrc","hash":"010368ca3134343e46025b2f154464fed440683e","modified":1634043811750},{"_id":"source/music/lrc/大鱼 (Live) - 周深.lrc","hash":"083c9bdb26e7ded40acd4b4600d3d678353382b4","modified":1634041990165},{"_id":"source/music/lrc/在青春里遇见 - 卜冠今.lrc","hash":"9f6f811ac6ff0b08993862754e248c5ee0f66ac1","modified":1634047071358},{"_id":"source/music/lrc/平凡的一天 - 毛不易.lrc","hash":"023ae27829e4319911e88d3940cbfd3c4bfce06e","modified":1634047253944},{"_id":"source/music/lrc/心如止水 - Ice Paper.lrc","hash":"dfde78aa1773a10c94201f5db7f58eaae475e42f","modified":1634042562560},{"_id":"source/music/lrc/忽而今夏 - 汪苏泷.lrc","hash":"622c4fdbe79b411e8d7d0963e09ef4ca4a9e93b6","modified":1634043036249},{"_id":"source/music/lrc/我和我的祖国 - 王菲.lrc","hash":"31a28f4da704b724c737635f8e23502a43df2c35","modified":1634044077092},{"_id":"source/music/lrc/所念皆星河 - 房东的猫.lrc","hash":"2c2442f05198118d6865289dd2517f219df41a0b","modified":1634040361679},{"_id":"source/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc","hash":"78f18b50342847a3b45bf95ebd34d7c51370f2d3","modified":1634044192290},{"_id":"source/music/lrc/成都 - 赵雷.lrc","hash":"df23345e6e84210ca111d48a1c60235208e44aca","modified":1634042686479},{"_id":"source/music/lrc/泡沫 - G.E.M.邓紫棋.lrc","hash":"97cf16fde145a7197f6b97a13890d226438a445c","modified":1634043128275},{"_id":"source/music/lrc/空空如也  - 任然.lrc","hash":"3da63bfcd5bc67f45e28c52ba0492c276c5dd2d8","modified":1634044422436},{"_id":"source/music/lrc/若把你 - Kirsty刘瑾睿.lrc","hash":"cdb22fd66f048cba858b4a8ee72f4a8a9625b8cd","modified":1634047356932},{"_id":"source/music/lrc/蓝莲花 - 许巍.lrc","hash":"f3fe5d1ff9aee7f3b50e6f97fc7c5899b826e94c","modified":1634301612502},{"_id":"source/music/lrc/远方不远 - 徐薇.lrc","hash":"042a73de0ba50cc67d38f0b689ff9095d15567a1","modified":1634041755334},{"_id":"source/music/lrc/风铃 - 孟凡明.lrc","hash":"883e4b78e58cc94dac96bab88aef65128e4f3987","modified":1634042181323},{"_id":"source/photos/static/empty.png","hash":"e88177c88f6b7219a3474da7d210965a6dbb57d7","modified":1634138297852},{"_id":"source/photos/static/ins.css","hash":"e6c082041e67b622c9d3d165542abd07ce0d7cc8","modified":1634965762979},{"_id":"themes/new-yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1632919465986},{"_id":"themes/new-yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1632919465986},{"_id":"themes/new-yilia/_config.yml","hash":"32e0fc0db911bcbb2842c81fc9fd28878110d3bc","modified":1669621598768},{"_id":"themes/new-yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1632919465987},{"_id":"themes/new-yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1632919465988},{"_id":"themes/new-yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1632919465988},{"_id":"source/photos/static/ins.js","hash":"238d8c04aa6f00aad71aa1b3dabbb59bfcf4d140","modified":1634145838633},{"_id":"themes/new-yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1632919466008},{"_id":"themes/new-yilia/languages/zh-tw.yml","hash":"4e2395f0b395a36ca229dd40ff3ae00d847ec501","modified":1633681592637},{"_id":"themes/new-yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1632919465989},{"_id":"themes/new-yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1632919466009},{"_id":"themes/new-yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1632919466009},{"_id":"themes/new-yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1632919466011},{"_id":"themes/new-yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1632919466012},{"_id":"themes/new-yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1632919466011},{"_id":"themes/new-yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1632919465991},{"_id":"themes/new-yilia/layout/_partial/baidu-push.ejs","hash":"2a68b27ed28190ab3e151560174952cd2f05775a","modified":1634979020773},{"_id":"themes/new-yilia/layout/_partial/after-footer.ejs","hash":"db197d1b97e1cf6d0dfa9ee7701a9e2ee2d77cd2","modified":1660467271125},{"_id":"themes/new-yilia/layout/_partial/baidu-analytics.ejs","hash":"898714c541d864b0cab2cbef39c0985ce08b441f","modified":1634906619495},{"_id":"themes/new-yilia/layout/layout.ejs","hash":"a8e859dc1647c7b1a5c816d6b5abc24bfa232dc8","modified":1669113786459},{"_id":"themes/new-yilia/layout/_partial/aside.ejs","hash":"1ddb958ebcbab870b4672fb3e394badac0d94d90","modified":1660726261374},{"_id":"themes/new-yilia/layout/_partial/archive.ejs","hash":"696ad5a7e9f8dc8b966ae657cb8c8843d12c054b","modified":1660467427908},{"_id":"themes/new-yilia/layout/_partial/css.ejs","hash":"173bdf21f9e69d53bb2813d7feae70ba76a6c255","modified":1634882747800},{"_id":"themes/new-yilia/layout/_partial/google-analytics.ejs","hash":"e0d4bac30d4039ea5f005994fdfe01d6ef8fb09b","modified":1634904796229},{"_id":"themes/new-yilia/layout/_partial/footer.ejs","hash":"7d8948eb167441b66d964151bdb798d3862e370c","modified":1669621566230},{"_id":"themes/new-yilia/layout/_partial/mobile-nav.ejs","hash":"a875a9a1f7d1612273fb323121ab31371f3c952c","modified":1669105299145},{"_id":"themes/new-yilia/layout/_partial/head.ejs","hash":"ed823f8d70f4d49f226aabb645e64d5f1fccdb15","modified":1640856711360},{"_id":"themes/new-yilia/layout/_partial/header.ejs","hash":"47895d276aef6f3211c9ab689cde28c2e12b7d86","modified":1634965317265},{"_id":"themes/new-yilia/layout/_partial/mathjax.ejs","hash":"4ad40841bba99cfd8ccbc14acd0190381879fbf5","modified":1660474810071},{"_id":"themes/new-yilia/layout/_partial/left-col.ejs","hash":"069b1fe74bb49484481adb7d13c751804500bf6a","modified":1669114766640},{"_id":"themes/new-yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1632919466007},{"_id":"themes/new-yilia/layout/_partial/article.ejs","hash":"34d00b59ba9490c0bcce575b64f3735ff596bd68","modified":1660743578366},{"_id":"themes/new-yilia/source/css/avatarrotation.css","hash":"42092d227f181f270167b7a7f9d3c66074a5ce9d","modified":1632990382049},{"_id":"themes/new-yilia/layout/_partial/tools.ejs","hash":"4b77d8e52b77ab89232a5f40a830303e11af0707","modified":1633713413922},{"_id":"themes/new-yilia/source/fonts/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1632919466030},{"_id":"themes/new-yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1632919466050},{"_id":"themes/new-yilia/source/fonts/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1632919466054},{"_id":"themes/new-yilia/source/fonts/iconfont.16acc2.ttf","hash":"d238bb87ce97671367ccf34c10c7fa8013474022","modified":1607136489000},{"_id":"themes/new-yilia/source/fonts/iconfont.8c627f.woff","hash":"06538c9e94320272bdb38ad96f120b758aa74a95","modified":1607136489000},{"_id":"themes/new-yilia/source/fonts/iconfont.45d7ee.svg","hash":"8c54c7353010a8bc3542c295491f5dfceed7d524","modified":1607136489000},{"_id":"themes/new-yilia/source/fonts/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1632919466055},{"_id":"themes/new-yilia/source/fonts/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1632919466030},{"_id":"themes/new-yilia/source/fonts/iconfont.b322fa.eot","hash":"c600351fa976b45cf502d310ff9d37141e484f6a","modified":1607136489000},{"_id":"themes/new-yilia/source/fonts/tooltip.4004ff.svg","hash":"cf6824e66b3d0fa11d9edf3bd5bb29a3d7dad4fe","modified":1633509998553},{"_id":"themes/new-yilia/source/js/clipboard_use.js","hash":"1ab93ec8dae8779412aa87b89cc7cd93478a36f2","modified":1633695422192},{"_id":"themes/new-yilia/source/js/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1632919466059},{"_id":"themes/new-yilia/source/img/alipay-min.png","hash":"f03ba25a3d1e62ed3c3fc54701cdfc79f2efd464","modified":1660898968723},{"_id":"themes/new-yilia/source/img/wechatpay-min.png","hash":"68c606aa9c8b1c12503f34dcaaa74d9b35b3693c","modified":1660899028373},{"_id":"themes/new-yilia/source/img/sanshui.png","hash":"568ede842afe69e02501e28a92000b6eec9b397a","modified":1634212301777},{"_id":"themes/new-yilia/source/js/snow.js","hash":"1c7a8b79b5a60e43e386c60f4ad7bf456d5cb5f1","modified":1634115179546},{"_id":"themes/new-yilia/source/img/favicon.ico","hash":"1aa470f9756dcfd98567478e4a7da12ea9295835","modified":1640851834134},{"_id":"themes/new-yilia/layout/_partial/post/aplayer.ejs","hash":"d9f5597423ce96e0dca5fa5d0da3497ba12e2f60","modified":1634386695678},{"_id":"themes/new-yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1632919466000},{"_id":"themes/new-yilia/layout/_partial/post/category.ejs","hash":"e68dd07762a7e2358ba857b6ff4496a43e02ee83","modified":1635435201364},{"_id":"themes/new-yilia/layout/_partial/post/clock.ejs","hash":"ea66b0b8c3de50cd6ba91698c54a6cf587724a40","modified":1633849884204},{"_id":"themes/new-yilia/layout/_partial/post/date.ejs","hash":"69e902b213e346a6412dd672202f42c2b9077cd4","modified":1660379295871},{"_id":"themes/new-yilia/layout/_partial/post/mouse_love.ejs","hash":"cbe1f17f18eeaecee163a91a82e4c7ed54b99f0d","modified":1634113183065},{"_id":"themes/new-yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1632919466002},{"_id":"themes/new-yilia/layout/_partial/post/declare.ejs","hash":"ae468cb8ce7c69c0e9cb2a9ee6eeb57eb7b8e535","modified":1633771600339},{"_id":"themes/new-yilia/layout/_partial/post/mouse_word.ejs","hash":"3b0ab6e7895e413721215ad2f88dc12333bd69a0","modified":1634113989986},{"_id":"themes/new-yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1632919466003},{"_id":"themes/new-yilia/layout/_partial/post/gittalk.ejs","hash":"cd2a3124a0b3352405f008c378a1066a85f92091","modified":1633660346334},{"_id":"themes/new-yilia/layout/_partial/post/word_count.ejs","hash":"5152366fc5235567c07dd70e4bf3cb4ccedf33f8","modified":1634974333577},{"_id":"themes/new-yilia/layout/_partial/post/title.ejs","hash":"f111ffe8f44524f787a216d84d35fe2a6ef22917","modified":1669109711849},{"_id":"themes/new-yilia/layout/_partial/post/share.ejs","hash":"16b0b4a51c41a700d55a351c04c97d4bc138009c","modified":1633504610739},{"_id":"source/_posts/03 图像和视频篡改检测Manipulation Detection综述.md","hash":"d107b31720c89e3980bac610daba0912a986bcb0","modified":1669494945984},{"_id":"themes/new-yilia/layout/_partial/post/tag.ejs","hash":"0f10f0f74ff6d50c7b257f6f83b55168e3676d0f","modified":1635436735521},{"_id":"themes/new-yilia/source/css/main.0cf68a.css","hash":"1e22f66657e869d2e43a1b9285b89444ddc34683","modified":1669495803282},{"_id":"themes/new-yilia/layout/_partial/script.ejs","hash":"6a1da4e1742fd0d8b10f07b7bd2a99af660e99d6","modified":1634882981265},{"_id":"themes/new-yilia/source/js/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1632919466058},{"_id":"themes/new-yilia/source/js/main.0cf68a.js","hash":"919f7c84b590d0d92434fac037fe504416ac630d","modified":1634984134099},{"_id":"themes/new-yilia/layout/_partial/post/waline.ejs","hash":"b0ec0119e72d273911015b488527323f180cdbd0","modified":1669446506545},{"_id":"public/music/aplayer_config.js","hash":"524f910e2b4973a5ac15bc96d13be0e11bcce535","modified":1669715062901},{"_id":"public/music/aplayer_page_config.js","hash":"de14c8a51e80a9572d6930a112d67d14be08e24c","modified":1669715062901},{"_id":"public/photos/data.json","hash":"8f3555c56094e84e26c40d9325ac9347416c6650","modified":1669715062901},{"_id":"public/photos/static/ins.css","hash":"e6c082041e67b622c9d3d165542abd07ce0d7cc8","modified":1669715062901},{"_id":"public/baidu_urls.txt","hash":"5844b8bbf2cd877800903f1b691c9a0bc13c997b","modified":1669715062901},{"_id":"public/photos/static/ins.js","hash":"238d8c04aa6f00aad71aa1b3dabbb59bfcf4d140","modified":1669715062901},{"_id":"public/baidusitemap.xml","hash":"037d1db6ab2c03c1f9f8a7146992912dff9fa0a6","modified":1669715062901},{"_id":"public/atom.xml","hash":"1246f02cc917373cb4dc0356d674626d026f786f","modified":1669715062901},{"_id":"public/content.json","hash":"1a210b6d6e1ae47fca00ac36fdc9c3f9e0b80512","modified":1669715062901},{"_id":"public/sitemap.xml","hash":"616e141c93c462e2abfcc1f5f8c8facc6b030b8d","modified":1669715062901},{"_id":"public/archives/index.html","hash":"0adcc4cc46c1738dab8e4f57758cc3f0790e0f76","modified":1669715062901},{"_id":"public/categories/index.html","hash":"6b78adca3b7938c20a08e4de72c0e8be590292db","modified":1669715062901},{"_id":"public/music/index.html","hash":"e0844f55328dfd03c533b7c205167abff292078a","modified":1669715062901},{"_id":"public/photos/index.html","hash":"284118998bc1b75b9640c42e5c804b70a9be8226","modified":1669715062901},{"_id":"public/photos/video.html","hash":"e360b24a2a3e672b4c45db4eb22df383b28e01a8","modified":1669715062901},{"_id":"public/post/2e289bf9.html","hash":"333032f5d19f1e5a943e2ef35b08866612fdd619","modified":1669715062901},{"_id":"public/post/931914af.html","hash":"5d5eb7c1c9e719faa61056b2b20de0b7a3fbca4a","modified":1669715062901},{"_id":"public/post/d446fd47.html","hash":"75e192550d3a2110cbffb9ac17d102516522f070","modified":1669715062901},{"_id":"public/post/8283904e.html","hash":"9753d41f06e78740d9ba27618d90c34ba787b4c9","modified":1669715062901},{"_id":"public/post/3f292744.html","hash":"d9b32f78f81ecffa441bb8b7724f724e489291d0","modified":1669715062901},{"_id":"public/post/6473c150.html","hash":"8b038320c57ee604da8092ddffa5ece4fdb34e9b","modified":1669715062901},{"_id":"public/post/8d2d3001.html","hash":"9933429e9f04a37c375139684305f2622fb6cc31","modified":1669715062901},{"_id":"public/index.html","hash":"78e5ccae1f4b3fc11f42df67e8806750d801aa8c","modified":1669715062901},{"_id":"public/archives/2021/index.html","hash":"bb3fd7103b6ec0049f1bea1eedb91ba0a644b721","modified":1669715062901},{"_id":"public/archives/2021/10/index.html","hash":"c3234abc0eab18c26b15deda2cf8e477fb866515","modified":1669715062901},{"_id":"public/archives/2021/12/index.html","hash":"9a8c3f57a25caa06efb86fcc3b3a361f3aa28b61","modified":1669715062901},{"_id":"public/archives/2022/index.html","hash":"ec123c3a5c29be5cc42d383eaa184a8cb606b59f","modified":1669715062901},{"_id":"public/archives/2022/11/index.html","hash":"620cb85e3dffc6dbcddeaccdb94b9e5832ebdd1c","modified":1669715062901},{"_id":"public/categories/算法刷题/index.html","hash":"073413f068bf6f8202c4851049de2ddc49765a09","modified":1669715062901},{"_id":"public/categories/linux/index.html","hash":"c8178a4584ce9c84c2121f779eb9bb32d7002cfb","modified":1669715062901},{"_id":"public/categories/论文阅读/index.html","hash":"4d9963da1e53c3837da4c2d2ee987db5b24c92f7","modified":1669715062901},{"_id":"public/categories/算法刷题/代码随想录/index.html","hash":"dc357d1cec0a62ef2fa8ed49251926950c3c5e95","modified":1669715062901},{"_id":"public/categories/博客Blog/index.html","hash":"9220576e09a6f278957194a6b485f7fb409004af","modified":1669715062901},{"_id":"public/categories/论文阅读/图像篡改/index.html","hash":"b57af945579d6e62dc40b139f4bc6f281b926132","modified":1669715062901},{"_id":"public/categories/博客Blog/hexo/index.html","hash":"7722dd11ff34088d5c2348cc7c2e925d90b1f451","modified":1669715062901},{"_id":"public/categories/博客Blog/三水的笔记/index.html","hash":"ab4301109d57b9a58862c991bc78d818f25c6ef8","modified":1669715062901},{"_id":"public/categories/博客Blog/yilia/index.html","hash":"fa1c61a3d42b3c2a2300260952daf9396fb49e57","modified":1669715062901},{"_id":"public/tags/LeetCode/index.html","hash":"bf24b3c0682970165c236ca85170b752af6fd840","modified":1669715062901},{"_id":"public/tags/linux/index.html","hash":"a61fdf706c2ae73bad378ad8a80a816227e80950","modified":1669715062901},{"_id":"public/tags/论文阅读/index.html","hash":"cd433e485373af03aa33a658388f843ee6cb5f5b","modified":1669715062901},{"_id":"public/tags/图像篡改/index.html","hash":"006c194ce79bb1a98f6497f1f4916c06afe10468","modified":1669715062901},{"_id":"public/tags/hexo/index.html","hash":"331e0af67ae38fb2bcde09cf36b5d2bff20e3453","modified":1669715062901},{"_id":"public/tags/yilia/index.html","hash":"bcb82392d843ccf1a52a6658651a6021cd4bd16e","modified":1669715062901},{"_id":"public/tags/三水/index.html","hash":"a2a186b836e77882ca1c00c4da031ebe7ac42924","modified":1669715062901},{"_id":"public/404/404-NotFound.md","hash":"776b570de0a9e075776dfcfea233e4e2bb1e4e0b","modified":1669715062901},{"_id":"public/404.html","hash":"0df814e2b6cd4d8b7b855c0c1765fd70645a8ce3","modified":1669715062901},{"_id":"public/404/404-tencent.md","hash":"69a35a973e0b2d78a9ce20154e4da24c3adf1e32","modified":1669715062901},{"_id":"public/README.md","hash":"f76bf17a7fdd19c5d498078e2ebaf059ff79e07f","modified":1669715062901},{"_id":"public/music/music_demo.ejs","hash":"b929e83d546156b2bb2bc8761636f29d8e7e2364","modified":1669715062901},{"_id":"public/photos/video_demo.ejs","hash":"416839c05ce89074a05019abccdf8755cfc003cd","modified":1669715062901},{"_id":"public/CNAME","hash":"db0fb60d61d361df08e7ab9fc4874ab46c69a4e4","modified":1669715062901},{"_id":"public/404/404-cat.md","hash":"6fd1112559b32267abf19918a551803671b6ec7d","modified":1669715062901},{"_id":"public/robots.txt","hash":"a9f1b3cb791e41216f34aedb7269c501f0365d8f","modified":1669715062901},{"_id":"public/music/lrc/举镜子的女孩 - 张子枫.lrc","hash":"a8a82b2472a64ca2b11d81d33d5c949add3d35b9","modified":1669715062901},{"_id":"public/music/lrc/光年之外 - G.E.M.邓紫棋.lrc","hash":"de9f1b77ebea81d3aa79da0dcfc218e8decdadfe","modified":1669715062901},{"_id":"public/music/lrc/何以爱情 - 钟汉良.lrc","hash":"341db046ab17e2564194cfe1c90b281ad0ec5c1d","modified":1669715062901},{"_id":"public/music/lrc/亲爱的旅人啊 - 周深.lrc","hash":"0db5a4cbefc899be30b1344800d11266c8d361b0","modified":1669715062901},{"_id":"public/music/lrc/丁香花 - 唐磊.lrc","hash":"85c849a8a23e9db880ec8b99ff889a3bd180c165","modified":1669715062901},{"_id":"public/music/lrc/可能否 - 木小雅.lrc","hash":"9f62b42154abc6e9bfc0adfd1f5089d20a67d26d","modified":1669715062901},{"_id":"public/music/lrc/在青春里遇见 - 卜冠今.lrc","hash":"9f6f811ac6ff0b08993862754e248c5ee0f66ac1","modified":1669715062901},{"_id":"public/music/lrc/刚刚好 - 薛之谦.lrc","hash":"09c0c2e7441d5cf8b15407b81b0962b8d3793ebf","modified":1669715062901},{"_id":"public/music/lrc/大鱼 (Live) - 周深.lrc","hash":"083c9bdb26e7ded40acd4b4600d3d678353382b4","modified":1669715062901},{"_id":"public/music/lrc/心如止水 - Ice Paper.lrc","hash":"dfde78aa1773a10c94201f5db7f58eaae475e42f","modified":1669715062901},{"_id":"public/music/lrc/平凡的一天 - 毛不易.lrc","hash":"023ae27829e4319911e88d3940cbfd3c4bfce06e","modified":1669715062901},{"_id":"public/music/lrc/少年 (Live) - 梦然.lrc","hash":"010368ca3134343e46025b2f154464fed440683e","modified":1669715062901},{"_id":"public/music/lrc/冬眠 - 司南.lrc","hash":"d4f35bd5372ba65d0452ef4eda59125c0c41837f","modified":1669715062901},{"_id":"public/music/lrc/忽而今夏 - 汪苏泷.lrc","hash":"622c4fdbe79b411e8d7d0963e09ef4ca4a9e93b6","modified":1669715062901},{"_id":"public/music/lrc/泡沫 - G.E.M.邓紫棋.lrc","hash":"97cf16fde145a7197f6b97a13890d226438a445c","modified":1669715062901},{"_id":"public/music/lrc/所念皆星河 - 房东的猫.lrc","hash":"2c2442f05198118d6865289dd2517f219df41a0b","modified":1669715062901},{"_id":"public/music/lrc/我和我的祖国 - 王菲.lrc","hash":"31a28f4da704b724c737635f8e23502a43df2c35","modified":1669715062901},{"_id":"public/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc","hash":"78f18b50342847a3b45bf95ebd34d7c51370f2d3","modified":1669715062901},{"_id":"public/music/lrc/远方不远 - 徐薇.lrc","hash":"042a73de0ba50cc67d38f0b689ff9095d15567a1","modified":1669715062901},{"_id":"public/music/lrc/空空如也  - 任然.lrc","hash":"3da63bfcd5bc67f45e28c52ba0492c276c5dd2d8","modified":1669715062901},{"_id":"public/music/lrc/若把你 - Kirsty刘瑾睿.lrc","hash":"cdb22fd66f048cba858b4a8ee72f4a8a9625b8cd","modified":1669715062901},{"_id":"public/photos/static/empty.png","hash":"e88177c88f6b7219a3474da7d210965a6dbb57d7","modified":1669715062901},{"_id":"public/fonts/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1669715062901},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1669715062901},{"_id":"public/fonts/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1669715062901},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"d238bb87ce97671367ccf34c10c7fa8013474022","modified":1669715062901},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"06538c9e94320272bdb38ad96f120b758aa74a95","modified":1669715062901},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"8c54c7353010a8bc3542c295491f5dfceed7d524","modified":1669715062901},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"c600351fa976b45cf502d310ff9d37141e484f6a","modified":1669715062901},{"_id":"public/music/lrc/成都 - 赵雷.lrc","hash":"df23345e6e84210ca111d48a1c60235208e44aca","modified":1669715062901},{"_id":"public/fonts/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1669715062901},{"_id":"public/fonts/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1669715062901},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"cf6824e66b3d0fa11d9edf3bd5bb29a3d7dad4fe","modified":1669715062901},{"_id":"public/img/alipay-min.png","hash":"f03ba25a3d1e62ed3c3fc54701cdfc79f2efd464","modified":1669715062901},{"_id":"public/img/wechatpay-min.png","hash":"68c606aa9c8b1c12503f34dcaaa74d9b35b3693c","modified":1669715062901},{"_id":"public/music/lrc/风铃 - 孟凡明.lrc","hash":"883e4b78e58cc94dac96bab88aef65128e4f3987","modified":1669715062901},{"_id":"public/music/lrc/蓝莲花 - 许巍.lrc","hash":"f3fe5d1ff9aee7f3b50e6f97fc7c5899b826e94c","modified":1669715062901},{"_id":"public/img/favicon.ico","hash":"1aa470f9756dcfd98567478e4a7da12ea9295835","modified":1669715062901},{"_id":"public/img/sanshui.png","hash":"568ede842afe69e02501e28a92000b6eec9b397a","modified":1669715062901},{"_id":"public/css/avatarrotation.css","hash":"e5488cc35b1c38273c568fe84e3c4e672dbe28b0","modified":1669715062901},{"_id":"public/js/clipboard_use.js","hash":"405736ea9bcb4d5834f9b94dc26fb831429f6c20","modified":1669715062901},{"_id":"public/js/snow.js","hash":"ee514720afd480b7df9cd1ad0ecde56bbfc035e3","modified":1669715062901},{"_id":"public/css/main.0cf68a.css","hash":"896ff3b5dc6653906cd6291e6487f49862d6c1d5","modified":1669715062901},{"_id":"public/js/main.0cf68a.js","hash":"919f7c84b590d0d92434fac037fe504416ac630d","modified":1669715062901},{"_id":"public/js/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1669715062901},{"_id":"public/js/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1669715062901}],"Category":[{"name":"算法刷题","_id":"clb218l4h000e64rg3yoz4s32"},{"name":"linux","_id":"clb218l4k000i64rghjjbbxto"},{"name":"论文阅读","_id":"clb218l4n000n64rgfd1d9ms1"},{"name":"代码随想录","parent":"clb218l4h000e64rg3yoz4s32","_id":"clb218l4t001164rg8dfpgba9"},{"name":"博客Blog","_id":"clb218l4v001864rgcb9i14gu"},{"name":"图像篡改","parent":"clb218l4n000n64rgfd1d9ms1","_id":"clb218l4v001d64rg0aj821kv"},{"name":"CV","parent":"clb218l4n000n64rgfd1d9ms1","_id":"clb218l4w001j64rggqe24105"},{"name":"hexo","parent":"clb218l4v001864rgcb9i14gu","_id":"clb218l4z001x64rgf2u824gt"},{"name":"图像篡改","parent":"clb218l4w001j64rggqe24105","_id":"clb218l50002064rg4zfabl2h"},{"name":"三水的笔记","parent":"clb218l4v001864rgcb9i14gu","_id":"clb218l50002364rg003rfcm5"},{"name":"yilia","parent":"clb218l4v001864rgcb9i14gu","_id":"clb218l50002564rg8onzhsez"}],"Data":[],"Page":[{"title":"archives","_content":"\n","source":"archives/index.md","raw":"---\ntitle: archives\n---\n\n","date":"2022-11-25T07:40:52.116Z","updated":"2022-11-22T10:16:06.226Z","path":"archives/index.html","comments":1,"layout":"page","_id":"clb218l3u000064rg89s91xcb","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"const ap = new APlayer({\n    container: document.getElementById('aplayer'),\n\t// mini: false,\n    fixed: true,//吸底模式\n    autoplay: false,//默认是否自动播放\n\t//theme: '#0088cc',\n    loop: 'all',\n    order: 'random',\n\t//order: 'list',\n    preload: 'auto',\n    volume: 0.7,//默认音量\n\tlrcType: 3, //使用lrc文件提供歌词\n    mutex: true,//是否不允许多个播放器同时播放\n    listFolded: true,//是否默认收起播放列表\n    //listMaxHeight: 90,//播放列表的高度\n\t//网易云默认外链链接：http://music.163.com/song/media/outer/url?id=ID数字.mp3\n\t// 音乐网解析: https://www.jbsou.cn/\n\n    audio: [{\n            name: '所念皆星河',\n            artist: '房东的猫',\n            lrc: '/music/lrc/所念皆星河 - 房东的猫.lrc',\n            cover: 'http://p1.music.126.net/JtevaRk1N7ecpmwZCIvwzQ==/109951165293262893.jpg?param=300y300',\n            url: 'http://music.163.com/song/media/outer/url?id=1476239407.mp3',\n\t\t\ttheme: 'red',\n\t\t\ttype: '',\n                  },\n        {\n            name: '举镜子的女孩',\n            artist: '张子枫',\n            lrc: '/music/lrc/举镜子的女孩 - 张子枫.lrc',\n            cover: 'http://p1.music.126.net/DVPFwwNkeWRiFx_UscjOpA==/109951165582170050.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1871120552.mp3',\n                  },\n\t\t{\n            name: '亲爱的旅人啊',\n            artist: '周深',\n            lrc: '/music/lrc/亲爱的旅人啊 - 周深.lrc',\n            cover: 'http://p2.music.126.net/1YrCPOBV314i-mTtlDg8mQ==/109951164148664637.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1371939273.mp3'\n                  },\n        {\n            name: '平凡的一天',\n            artist: '毛不易',\n            lrc: '/music/lrc/平凡的一天 - 毛不易.lrc',\n            cover: 'http://p1.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214247.mp3'\n                  },\n        {\n            name: '若把你',\n            artist: 'Kirsty刘瑾睿',\n            lrc: '/music/lrc/若把你 - Kirsty刘瑾睿.lrc',\n            cover: 'http://p1.music.126.net/M877M2-VhWZiLPVFORf9iQ==/109951163401482434.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=865632948.mp3'\n                  },\n        {\n            name: '大鱼',\n            artist: '周深',\n            lrc: '/music/lrc/大鱼 (Live) - 周深.lrc',\n            cover: 'https://p2.music.126.net/aiPQXP8mdLovQSrKsM3hMQ==/1416170985079958.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1421191783',\n                  },\n        {\n            name: '远方不远',\n            artist: '徐薇',\n            lrc: '/music/lrc/远方不远 - 徐薇.lrc',\n            cover: 'https://p1.music.126.net/LjwSx1AXf7si4MaAb8bzYw==/109951165041602630.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=431554119.mp3'\n                  },\n        {\n            name: '风铃',\n            artist: '孟凡明',\n            lrc: '/music/lrc/风铃 - 孟凡明.lrc',\n            cover: 'https://p1.music.126.net/ZjWhERuCE8slMan5EzX96w==/109951164358745101.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1390480881.mp3'\n                  },\n        {\n            name: '心如止水',\n            artist: 'Ice Paper',\n            lrc: '/music/lrc/心如止水 - Ice Paper.lrc',\n            cover: 'http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1349292048.mp3'\n                  },\n        {\n            name: '成都',\n            artist: '赵雷',\n            lrc: '/music/lrc/成都 - 赵雷.lrc',\n            cover: '\thttps://p2.music.126.net/34YW1QtKxJ_3YnX9ZzKhzw==/2946691234868155.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=436514312.mp3'\n                  },\n        {\n            name: '忽而今夏',\n            artist: '汪苏泷',\n            lrc: '/music/lrc/忽而今夏 - 汪苏泷.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1366388726.mp3'\n                  },\n        {\n            name: '泡沫',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/泡沫 - G.E.M.邓紫棋.lrc',\n            cover: 'https://p2.music.126.net/fqleir2BWqbmE8tDNLa5Pg==/109951163789160762.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=233931.mp3'\n                  },\n        {\n            name: '何以爱情',\n            artist: '钟汉良',\n            lrc: '/music/lrc/何以爱情 - 钟汉良.lrc',\n            cover: 'https://p2.music.126.net/ODGACHdemEF8EgDy6-Mjlw==/109951163014224498.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1869806072.mp3'\n                  },\n        {\n            name: '可能否',\n            artist: '木小雅',\n            lrc: '/music/lrc/可能否 - 木小雅.lrc',\n            cover: 'https://p2.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214126.mp3'\n                  },\n        {\n            name: '丁香花',\n            artist: '唐磊',\n            lrc: '/music/lrc/丁香花 - 唐磊.lrc',\n            cover: 'https://p2.music.126.net/FdutyVQ0oNOvjDHDixrALw==/844424930132282.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=151985.mp3'\n                  },\n        {\n            name: '冬眠',\n            artist: '司南',\n            lrc: '/music/lrc/冬眠 - 司南.lrc',\n            cover: 'https://p1.music.126.net/4KDBaQXnQywQovmqvjx-8Q==/109951164444131697.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1398663411.mp3'\n                  },\n        {\n            name: '少年 (Live)',\n            artist: '梦然',\n            lrc: '/music/lrc/少年 (Live) - 梦然.lrc',\n            cover: 'https://p2.music.126.net/AcJI2yDiUNgKYn_Wr5eVxw==/109951165358201641.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1483891561.mp3'\n                  },\n        {\n            name: '我和我的祖国',\n            artist: '王菲',\n            lrc: '/music/lrc/我和我的祖国 - 王菲.lrc',\n            cover: 'https://p1.music.126.net/HeGrAKPiZhKkONiFDxZvmw==/109951164384346866.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1392990601.mp3'\n                  },\n        {\n            name: '在青春里遇见',\n            artist: '卜冠今',\n            lrc: '/music/lrc/在青春里遇见 - 卜冠今.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1324399236.mp3'\n                  },\n        {\n            name: '杏花弦外雨',\n            artist: '杏花弦外雨',\n            lrc: '/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc',\n            cover: 'https://p2.music.126.net/iwZ6w7D5C8WXgnjcohHb0Q==/7799935488436943.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=32957012.mp3'\n                  },\n        {\n            name: '刚刚好',\n            artist: '薛之谦',\n            lrc: '/music/lrc/刚刚好 - 薛之谦.lrc',\n            cover: '\thttps://p2.music.126.net/hti_a0LADoFMBHvOBwAtRA==/1369991500930171.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=415792881.mp3'\n                  },\n        {\n            name: '光年之外',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/光年之外 - G.E.M.邓紫棋.lrc',\n            cover: '\thttps://p2.music.126.net/fkqFqMaEt0CzxYS-0NpCog==/18587244069235039.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=449818741.mp3'\n                  },\n        {\n            name: '空空如也 ',\n            artist: '任然',\n            lrc: '/music/lrc/空空如也  - 任然.lrc',\n            cover: 'https://p1.music.126.net/84FJjDgb51TmRqixaUpshg==/109951163094476391.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=526464293.mp3'\n                  },\n\t\t{\n            name: '蓝莲花',\n            artist: '许巍',\n            lrc: '/music/lrc/蓝莲花 - 许巍.lrc',\n            cover: 'http://imge.kugou.com/stdmusic/150/20150719/20150719030234152582.jpg',\n            url: 'http://music.163.com/song/media/outer/url?id=1428019277.mp3'\n                  },\n\n        ],\n\t\tcustomAudioType: {\n\t\t\t'customHls': function (audioElement, audio, player) {\n\t\t\t\tif (Hls.isSupported()) {\n\t\t\t\t\tconst hls = new Hls();\n\t\t\t\t\thls.loadSource(audio.url);\n\t\t\t\t\thls.attachMedia(audioElement);\n\t\t\t\t}\n\t\t\t\telse if (audioElement.canPlayType('application/x-mpegURL') || audioElement.canPlayType('application/vnd.apple.mpegURL')) {\n\t\t\t\t\taudioElement.src = audio.url;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplayer.notice('Error: HLS is not supported.');\n\t\t\t\t}\n\t\t\t}\n       }  \n});","source":"music/aplayer_config.js","raw":"const ap = new APlayer({\n    container: document.getElementById('aplayer'),\n\t// mini: false,\n    fixed: true,//吸底模式\n    autoplay: false,//默认是否自动播放\n\t//theme: '#0088cc',\n    loop: 'all',\n    order: 'random',\n\t//order: 'list',\n    preload: 'auto',\n    volume: 0.7,//默认音量\n\tlrcType: 3, //使用lrc文件提供歌词\n    mutex: true,//是否不允许多个播放器同时播放\n    listFolded: true,//是否默认收起播放列表\n    //listMaxHeight: 90,//播放列表的高度\n\t//网易云默认外链链接：http://music.163.com/song/media/outer/url?id=ID数字.mp3\n\t// 音乐网解析: https://www.jbsou.cn/\n\n    audio: [{\n            name: '所念皆星河',\n            artist: '房东的猫',\n            lrc: '/music/lrc/所念皆星河 - 房东的猫.lrc',\n            cover: 'http://p1.music.126.net/JtevaRk1N7ecpmwZCIvwzQ==/109951165293262893.jpg?param=300y300',\n            url: 'http://music.163.com/song/media/outer/url?id=1476239407.mp3',\n\t\t\ttheme: 'red',\n\t\t\ttype: '',\n                  },\n        {\n            name: '举镜子的女孩',\n            artist: '张子枫',\n            lrc: '/music/lrc/举镜子的女孩 - 张子枫.lrc',\n            cover: 'http://p1.music.126.net/DVPFwwNkeWRiFx_UscjOpA==/109951165582170050.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1871120552.mp3',\n                  },\n\t\t{\n            name: '亲爱的旅人啊',\n            artist: '周深',\n            lrc: '/music/lrc/亲爱的旅人啊 - 周深.lrc',\n            cover: 'http://p2.music.126.net/1YrCPOBV314i-mTtlDg8mQ==/109951164148664637.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1371939273.mp3'\n                  },\n        {\n            name: '平凡的一天',\n            artist: '毛不易',\n            lrc: '/music/lrc/平凡的一天 - 毛不易.lrc',\n            cover: 'http://p1.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214247.mp3'\n                  },\n        {\n            name: '若把你',\n            artist: 'Kirsty刘瑾睿',\n            lrc: '/music/lrc/若把你 - Kirsty刘瑾睿.lrc',\n            cover: 'http://p1.music.126.net/M877M2-VhWZiLPVFORf9iQ==/109951163401482434.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=865632948.mp3'\n                  },\n        {\n            name: '大鱼',\n            artist: '周深',\n            lrc: '/music/lrc/大鱼 (Live) - 周深.lrc',\n            cover: 'https://p2.music.126.net/aiPQXP8mdLovQSrKsM3hMQ==/1416170985079958.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1421191783',\n                  },\n        {\n            name: '远方不远',\n            artist: '徐薇',\n            lrc: '/music/lrc/远方不远 - 徐薇.lrc',\n            cover: 'https://p1.music.126.net/LjwSx1AXf7si4MaAb8bzYw==/109951165041602630.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=431554119.mp3'\n                  },\n        {\n            name: '风铃',\n            artist: '孟凡明',\n            lrc: '/music/lrc/风铃 - 孟凡明.lrc',\n            cover: 'https://p1.music.126.net/ZjWhERuCE8slMan5EzX96w==/109951164358745101.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1390480881.mp3'\n                  },\n        {\n            name: '心如止水',\n            artist: 'Ice Paper',\n            lrc: '/music/lrc/心如止水 - Ice Paper.lrc',\n            cover: 'http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1349292048.mp3'\n                  },\n        {\n            name: '成都',\n            artist: '赵雷',\n            lrc: '/music/lrc/成都 - 赵雷.lrc',\n            cover: '\thttps://p2.music.126.net/34YW1QtKxJ_3YnX9ZzKhzw==/2946691234868155.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=436514312.mp3'\n                  },\n        {\n            name: '忽而今夏',\n            artist: '汪苏泷',\n            lrc: '/music/lrc/忽而今夏 - 汪苏泷.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1366388726.mp3'\n                  },\n        {\n            name: '泡沫',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/泡沫 - G.E.M.邓紫棋.lrc',\n            cover: 'https://p2.music.126.net/fqleir2BWqbmE8tDNLa5Pg==/109951163789160762.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=233931.mp3'\n                  },\n        {\n            name: '何以爱情',\n            artist: '钟汉良',\n            lrc: '/music/lrc/何以爱情 - 钟汉良.lrc',\n            cover: 'https://p2.music.126.net/ODGACHdemEF8EgDy6-Mjlw==/109951163014224498.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1869806072.mp3'\n                  },\n        {\n            name: '可能否',\n            artist: '木小雅',\n            lrc: '/music/lrc/可能否 - 木小雅.lrc',\n            cover: 'https://p2.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214126.mp3'\n                  },\n        {\n            name: '丁香花',\n            artist: '唐磊',\n            lrc: '/music/lrc/丁香花 - 唐磊.lrc',\n            cover: 'https://p2.music.126.net/FdutyVQ0oNOvjDHDixrALw==/844424930132282.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=151985.mp3'\n                  },\n        {\n            name: '冬眠',\n            artist: '司南',\n            lrc: '/music/lrc/冬眠 - 司南.lrc',\n            cover: 'https://p1.music.126.net/4KDBaQXnQywQovmqvjx-8Q==/109951164444131697.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1398663411.mp3'\n                  },\n        {\n            name: '少年 (Live)',\n            artist: '梦然',\n            lrc: '/music/lrc/少年 (Live) - 梦然.lrc',\n            cover: 'https://p2.music.126.net/AcJI2yDiUNgKYn_Wr5eVxw==/109951165358201641.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1483891561.mp3'\n                  },\n        {\n            name: '我和我的祖国',\n            artist: '王菲',\n            lrc: '/music/lrc/我和我的祖国 - 王菲.lrc',\n            cover: 'https://p1.music.126.net/HeGrAKPiZhKkONiFDxZvmw==/109951164384346866.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1392990601.mp3'\n                  },\n        {\n            name: '在青春里遇见',\n            artist: '卜冠今',\n            lrc: '/music/lrc/在青春里遇见 - 卜冠今.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1324399236.mp3'\n                  },\n        {\n            name: '杏花弦外雨',\n            artist: '杏花弦外雨',\n            lrc: '/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc',\n            cover: 'https://p2.music.126.net/iwZ6w7D5C8WXgnjcohHb0Q==/7799935488436943.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=32957012.mp3'\n                  },\n        {\n            name: '刚刚好',\n            artist: '薛之谦',\n            lrc: '/music/lrc/刚刚好 - 薛之谦.lrc',\n            cover: '\thttps://p2.music.126.net/hti_a0LADoFMBHvOBwAtRA==/1369991500930171.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=415792881.mp3'\n                  },\n        {\n            name: '光年之外',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/光年之外 - G.E.M.邓紫棋.lrc',\n            cover: '\thttps://p2.music.126.net/fkqFqMaEt0CzxYS-0NpCog==/18587244069235039.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=449818741.mp3'\n                  },\n        {\n            name: '空空如也 ',\n            artist: '任然',\n            lrc: '/music/lrc/空空如也  - 任然.lrc',\n            cover: 'https://p1.music.126.net/84FJjDgb51TmRqixaUpshg==/109951163094476391.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=526464293.mp3'\n                  },\n\t\t{\n            name: '蓝莲花',\n            artist: '许巍',\n            lrc: '/music/lrc/蓝莲花 - 许巍.lrc',\n            cover: 'http://imge.kugou.com/stdmusic/150/20150719/20150719030234152582.jpg',\n            url: 'http://music.163.com/song/media/outer/url?id=1428019277.mp3'\n                  },\n\n        ],\n\t\tcustomAudioType: {\n\t\t\t'customHls': function (audioElement, audio, player) {\n\t\t\t\tif (Hls.isSupported()) {\n\t\t\t\t\tconst hls = new Hls();\n\t\t\t\t\thls.loadSource(audio.url);\n\t\t\t\t\thls.attachMedia(audioElement);\n\t\t\t\t}\n\t\t\t\telse if (audioElement.canPlayType('application/x-mpegURL') || audioElement.canPlayType('application/vnd.apple.mpegURL')) {\n\t\t\t\t\taudioElement.src = audio.url;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplayer.notice('Error: HLS is not supported.');\n\t\t\t\t}\n\t\t\t}\n       }  \n});","date":"2021-10-16T12:20:54.769Z","updated":"2021-10-16T12:20:54.769Z","path":"music/aplayer_config.js","layout":"false","title":"","comments":1,"_id":"clb218l3y000164rge5acft5b","content":"const ap = new APlayer({\n    container: document.getElementById('aplayer'),\n\t// mini: false,\n    fixed: true,//吸底模式\n    autoplay: false,//默认是否自动播放\n\t//theme: '#0088cc',\n    loop: 'all',\n    order: 'random',\n\t//order: 'list',\n    preload: 'auto',\n    volume: 0.7,//默认音量\n\tlrcType: 3, //使用lrc文件提供歌词\n    mutex: true,//是否不允许多个播放器同时播放\n    listFolded: true,//是否默认收起播放列表\n    //listMaxHeight: 90,//播放列表的高度\n\t//网易云默认外链链接：http://music.163.com/song/media/outer/url?id=ID数字.mp3\n\t// 音乐网解析: https://www.jbsou.cn/\n\n    audio: [{\n            name: '所念皆星河',\n            artist: '房东的猫',\n            lrc: '/music/lrc/所念皆星河 - 房东的猫.lrc',\n            cover: 'http://p1.music.126.net/JtevaRk1N7ecpmwZCIvwzQ==/109951165293262893.jpg?param=300y300',\n            url: 'http://music.163.com/song/media/outer/url?id=1476239407.mp3',\n\t\t\ttheme: 'red',\n\t\t\ttype: '',\n                  },\n        {\n            name: '举镜子的女孩',\n            artist: '张子枫',\n            lrc: '/music/lrc/举镜子的女孩 - 张子枫.lrc',\n            cover: 'http://p1.music.126.net/DVPFwwNkeWRiFx_UscjOpA==/109951165582170050.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1871120552.mp3',\n                  },\n\t\t{\n            name: '亲爱的旅人啊',\n            artist: '周深',\n            lrc: '/music/lrc/亲爱的旅人啊 - 周深.lrc',\n            cover: 'http://p2.music.126.net/1YrCPOBV314i-mTtlDg8mQ==/109951164148664637.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1371939273.mp3'\n                  },\n        {\n            name: '平凡的一天',\n            artist: '毛不易',\n            lrc: '/music/lrc/平凡的一天 - 毛不易.lrc',\n            cover: 'http://p1.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214247.mp3'\n                  },\n        {\n            name: '若把你',\n            artist: 'Kirsty刘瑾睿',\n            lrc: '/music/lrc/若把你 - Kirsty刘瑾睿.lrc',\n            cover: 'http://p1.music.126.net/M877M2-VhWZiLPVFORf9iQ==/109951163401482434.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=865632948.mp3'\n                  },\n        {\n            name: '大鱼',\n            artist: '周深',\n            lrc: '/music/lrc/大鱼 (Live) - 周深.lrc',\n            cover: 'https://p2.music.126.net/aiPQXP8mdLovQSrKsM3hMQ==/1416170985079958.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1421191783',\n                  },\n        {\n            name: '远方不远',\n            artist: '徐薇',\n            lrc: '/music/lrc/远方不远 - 徐薇.lrc',\n            cover: 'https://p1.music.126.net/LjwSx1AXf7si4MaAb8bzYw==/109951165041602630.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=431554119.mp3'\n                  },\n        {\n            name: '风铃',\n            artist: '孟凡明',\n            lrc: '/music/lrc/风铃 - 孟凡明.lrc',\n            cover: 'https://p1.music.126.net/ZjWhERuCE8slMan5EzX96w==/109951164358745101.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1390480881.mp3'\n                  },\n        {\n            name: '心如止水',\n            artist: 'Ice Paper',\n            lrc: '/music/lrc/心如止水 - Ice Paper.lrc',\n            cover: 'http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1349292048.mp3'\n                  },\n        {\n            name: '成都',\n            artist: '赵雷',\n            lrc: '/music/lrc/成都 - 赵雷.lrc',\n            cover: '\thttps://p2.music.126.net/34YW1QtKxJ_3YnX9ZzKhzw==/2946691234868155.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=436514312.mp3'\n                  },\n        {\n            name: '忽而今夏',\n            artist: '汪苏泷',\n            lrc: '/music/lrc/忽而今夏 - 汪苏泷.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1366388726.mp3'\n                  },\n        {\n            name: '泡沫',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/泡沫 - G.E.M.邓紫棋.lrc',\n            cover: 'https://p2.music.126.net/fqleir2BWqbmE8tDNLa5Pg==/109951163789160762.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=233931.mp3'\n                  },\n        {\n            name: '何以爱情',\n            artist: '钟汉良',\n            lrc: '/music/lrc/何以爱情 - 钟汉良.lrc',\n            cover: 'https://p2.music.126.net/ODGACHdemEF8EgDy6-Mjlw==/109951163014224498.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1869806072.mp3'\n                  },\n        {\n            name: '可能否',\n            artist: '木小雅',\n            lrc: '/music/lrc/可能否 - 木小雅.lrc',\n            cover: 'https://p2.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214126.mp3'\n                  },\n        {\n            name: '丁香花',\n            artist: '唐磊',\n            lrc: '/music/lrc/丁香花 - 唐磊.lrc',\n            cover: 'https://p2.music.126.net/FdutyVQ0oNOvjDHDixrALw==/844424930132282.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=151985.mp3'\n                  },\n        {\n            name: '冬眠',\n            artist: '司南',\n            lrc: '/music/lrc/冬眠 - 司南.lrc',\n            cover: 'https://p1.music.126.net/4KDBaQXnQywQovmqvjx-8Q==/109951164444131697.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1398663411.mp3'\n                  },\n        {\n            name: '少年 (Live)',\n            artist: '梦然',\n            lrc: '/music/lrc/少年 (Live) - 梦然.lrc',\n            cover: 'https://p2.music.126.net/AcJI2yDiUNgKYn_Wr5eVxw==/109951165358201641.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1483891561.mp3'\n                  },\n        {\n            name: '我和我的祖国',\n            artist: '王菲',\n            lrc: '/music/lrc/我和我的祖国 - 王菲.lrc',\n            cover: 'https://p1.music.126.net/HeGrAKPiZhKkONiFDxZvmw==/109951164384346866.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1392990601.mp3'\n                  },\n        {\n            name: '在青春里遇见',\n            artist: '卜冠今',\n            lrc: '/music/lrc/在青春里遇见 - 卜冠今.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1324399236.mp3'\n                  },\n        {\n            name: '杏花弦外雨',\n            artist: '杏花弦外雨',\n            lrc: '/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc',\n            cover: 'https://p2.music.126.net/iwZ6w7D5C8WXgnjcohHb0Q==/7799935488436943.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=32957012.mp3'\n                  },\n        {\n            name: '刚刚好',\n            artist: '薛之谦',\n            lrc: '/music/lrc/刚刚好 - 薛之谦.lrc',\n            cover: '\thttps://p2.music.126.net/hti_a0LADoFMBHvOBwAtRA==/1369991500930171.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=415792881.mp3'\n                  },\n        {\n            name: '光年之外',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/光年之外 - G.E.M.邓紫棋.lrc',\n            cover: '\thttps://p2.music.126.net/fkqFqMaEt0CzxYS-0NpCog==/18587244069235039.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=449818741.mp3'\n                  },\n        {\n            name: '空空如也 ',\n            artist: '任然',\n            lrc: '/music/lrc/空空如也  - 任然.lrc',\n            cover: 'https://p1.music.126.net/84FJjDgb51TmRqixaUpshg==/109951163094476391.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=526464293.mp3'\n                  },\n\t\t{\n            name: '蓝莲花',\n            artist: '许巍',\n            lrc: '/music/lrc/蓝莲花 - 许巍.lrc',\n            cover: 'http://imge.kugou.com/stdmusic/150/20150719/20150719030234152582.jpg',\n            url: 'http://music.163.com/song/media/outer/url?id=1428019277.mp3'\n                  },\n\n        ],\n\t\tcustomAudioType: {\n\t\t\t'customHls': function (audioElement, audio, player) {\n\t\t\t\tif (Hls.isSupported()) {\n\t\t\t\t\tconst hls = new Hls();\n\t\t\t\t\thls.loadSource(audio.url);\n\t\t\t\t\thls.attachMedia(audioElement);\n\t\t\t\t}\n\t\t\t\telse if (audioElement.canPlayType('application/x-mpegURL') || audioElement.canPlayType('application/vnd.apple.mpegURL')) {\n\t\t\t\t\taudioElement.src = audio.url;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplayer.notice('Error: HLS is not supported.');\n\t\t\t\t}\n\t\t\t}\n       }  \n});","site":{"data":{}},"excerpt":"","more":"const ap = new APlayer({\n    container: document.getElementById('aplayer'),\n\t// mini: false,\n    fixed: true,//吸底模式\n    autoplay: false,//默认是否自动播放\n\t//theme: '#0088cc',\n    loop: 'all',\n    order: 'random',\n\t//order: 'list',\n    preload: 'auto',\n    volume: 0.7,//默认音量\n\tlrcType: 3, //使用lrc文件提供歌词\n    mutex: true,//是否不允许多个播放器同时播放\n    listFolded: true,//是否默认收起播放列表\n    //listMaxHeight: 90,//播放列表的高度\n\t//网易云默认外链链接：http://music.163.com/song/media/outer/url?id=ID数字.mp3\n\t// 音乐网解析: https://www.jbsou.cn/\n\n    audio: [{\n            name: '所念皆星河',\n            artist: '房东的猫',\n            lrc: '/music/lrc/所念皆星河 - 房东的猫.lrc',\n            cover: 'http://p1.music.126.net/JtevaRk1N7ecpmwZCIvwzQ==/109951165293262893.jpg?param=300y300',\n            url: 'http://music.163.com/song/media/outer/url?id=1476239407.mp3',\n\t\t\ttheme: 'red',\n\t\t\ttype: '',\n                  },\n        {\n            name: '举镜子的女孩',\n            artist: '张子枫',\n            lrc: '/music/lrc/举镜子的女孩 - 张子枫.lrc',\n            cover: 'http://p1.music.126.net/DVPFwwNkeWRiFx_UscjOpA==/109951165582170050.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1871120552.mp3',\n                  },\n\t\t{\n            name: '亲爱的旅人啊',\n            artist: '周深',\n            lrc: '/music/lrc/亲爱的旅人啊 - 周深.lrc',\n            cover: 'http://p2.music.126.net/1YrCPOBV314i-mTtlDg8mQ==/109951164148664637.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1371939273.mp3'\n                  },\n        {\n            name: '平凡的一天',\n            artist: '毛不易',\n            lrc: '/music/lrc/平凡的一天 - 毛不易.lrc',\n            cover: 'http://p1.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214247.mp3'\n                  },\n        {\n            name: '若把你',\n            artist: 'Kirsty刘瑾睿',\n            lrc: '/music/lrc/若把你 - Kirsty刘瑾睿.lrc',\n            cover: 'http://p1.music.126.net/M877M2-VhWZiLPVFORf9iQ==/109951163401482434.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=865632948.mp3'\n                  },\n        {\n            name: '大鱼',\n            artist: '周深',\n            lrc: '/music/lrc/大鱼 (Live) - 周深.lrc',\n            cover: 'https://p2.music.126.net/aiPQXP8mdLovQSrKsM3hMQ==/1416170985079958.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1421191783',\n                  },\n        {\n            name: '远方不远',\n            artist: '徐薇',\n            lrc: '/music/lrc/远方不远 - 徐薇.lrc',\n            cover: 'https://p1.music.126.net/LjwSx1AXf7si4MaAb8bzYw==/109951165041602630.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=431554119.mp3'\n                  },\n        {\n            name: '风铃',\n            artist: '孟凡明',\n            lrc: '/music/lrc/风铃 - 孟凡明.lrc',\n            cover: 'https://p1.music.126.net/ZjWhERuCE8slMan5EzX96w==/109951164358745101.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1390480881.mp3'\n                  },\n        {\n            name: '心如止水',\n            artist: 'Ice Paper',\n            lrc: '/music/lrc/心如止水 - Ice Paper.lrc',\n            cover: 'http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1349292048.mp3'\n                  },\n        {\n            name: '成都',\n            artist: '赵雷',\n            lrc: '/music/lrc/成都 - 赵雷.lrc',\n            cover: '\thttps://p2.music.126.net/34YW1QtKxJ_3YnX9ZzKhzw==/2946691234868155.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=436514312.mp3'\n                  },\n        {\n            name: '忽而今夏',\n            artist: '汪苏泷',\n            lrc: '/music/lrc/忽而今夏 - 汪苏泷.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1366388726.mp3'\n                  },\n        {\n            name: '泡沫',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/泡沫 - G.E.M.邓紫棋.lrc',\n            cover: 'https://p2.music.126.net/fqleir2BWqbmE8tDNLa5Pg==/109951163789160762.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=233931.mp3'\n                  },\n        {\n            name: '何以爱情',\n            artist: '钟汉良',\n            lrc: '/music/lrc/何以爱情 - 钟汉良.lrc',\n            cover: 'https://p2.music.126.net/ODGACHdemEF8EgDy6-Mjlw==/109951163014224498.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1869806072.mp3'\n                  },\n        {\n            name: '可能否',\n            artist: '木小雅',\n            lrc: '/music/lrc/可能否 - 木小雅.lrc',\n            cover: 'https://p2.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214126.mp3'\n                  },\n        {\n            name: '丁香花',\n            artist: '唐磊',\n            lrc: '/music/lrc/丁香花 - 唐磊.lrc',\n            cover: 'https://p2.music.126.net/FdutyVQ0oNOvjDHDixrALw==/844424930132282.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=151985.mp3'\n                  },\n        {\n            name: '冬眠',\n            artist: '司南',\n            lrc: '/music/lrc/冬眠 - 司南.lrc',\n            cover: 'https://p1.music.126.net/4KDBaQXnQywQovmqvjx-8Q==/109951164444131697.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1398663411.mp3'\n                  },\n        {\n            name: '少年 (Live)',\n            artist: '梦然',\n            lrc: '/music/lrc/少年 (Live) - 梦然.lrc',\n            cover: 'https://p2.music.126.net/AcJI2yDiUNgKYn_Wr5eVxw==/109951165358201641.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1483891561.mp3'\n                  },\n        {\n            name: '我和我的祖国',\n            artist: '王菲',\n            lrc: '/music/lrc/我和我的祖国 - 王菲.lrc',\n            cover: 'https://p1.music.126.net/HeGrAKPiZhKkONiFDxZvmw==/109951164384346866.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1392990601.mp3'\n                  },\n        {\n            name: '在青春里遇见',\n            artist: '卜冠今',\n            lrc: '/music/lrc/在青春里遇见 - 卜冠今.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1324399236.mp3'\n                  },\n        {\n            name: '杏花弦外雨',\n            artist: '杏花弦外雨',\n            lrc: '/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc',\n            cover: 'https://p2.music.126.net/iwZ6w7D5C8WXgnjcohHb0Q==/7799935488436943.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=32957012.mp3'\n                  },\n        {\n            name: '刚刚好',\n            artist: '薛之谦',\n            lrc: '/music/lrc/刚刚好 - 薛之谦.lrc',\n            cover: '\thttps://p2.music.126.net/hti_a0LADoFMBHvOBwAtRA==/1369991500930171.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=415792881.mp3'\n                  },\n        {\n            name: '光年之外',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/光年之外 - G.E.M.邓紫棋.lrc',\n            cover: '\thttps://p2.music.126.net/fkqFqMaEt0CzxYS-0NpCog==/18587244069235039.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=449818741.mp3'\n                  },\n        {\n            name: '空空如也 ',\n            artist: '任然',\n            lrc: '/music/lrc/空空如也  - 任然.lrc',\n            cover: 'https://p1.music.126.net/84FJjDgb51TmRqixaUpshg==/109951163094476391.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=526464293.mp3'\n                  },\n\t\t{\n            name: '蓝莲花',\n            artist: '许巍',\n            lrc: '/music/lrc/蓝莲花 - 许巍.lrc',\n            cover: 'http://imge.kugou.com/stdmusic/150/20150719/20150719030234152582.jpg',\n            url: 'http://music.163.com/song/media/outer/url?id=1428019277.mp3'\n                  },\n\n        ],\n\t\tcustomAudioType: {\n\t\t\t'customHls': function (audioElement, audio, player) {\n\t\t\t\tif (Hls.isSupported()) {\n\t\t\t\t\tconst hls = new Hls();\n\t\t\t\t\thls.loadSource(audio.url);\n\t\t\t\t\thls.attachMedia(audioElement);\n\t\t\t\t}\n\t\t\t\telse if (audioElement.canPlayType('application/x-mpegURL') || audioElement.canPlayType('application/vnd.apple.mpegURL')) {\n\t\t\t\t\taudioElement.src = audio.url;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplayer.notice('Error: HLS is not supported.');\n\t\t\t\t}\n\t\t\t}\n       }  \n});"},{"_content":"const ap = new APlayer({\n\t// 这里命名ap, 与全局音乐播放器ap名称一样 所以在/music页面只出现一个播放器 ; 如果需要同时出现 请命名ap1\n    container: document.getElementById('aplayer2'),\n\t// mini: false,\n    //fixed: true,//吸底模式\n    autoplay: false,//默认是否自动播放\n\t//theme: '#0088cc',\n    loop: 'all',\n    //order: 'random',\n\torder: 'list',\n    preload: 'auto',\n    volume: 0.7,//默认音量\n\tlrcType: 3, //使用lrc文件提供歌词\n    mutex: true,//是否不允许多个播放器同时播放\n    listFolded: false,//是否默认收起播放列表\n    listMaxHeight: 700,//播放列表的高度\n\t//网易云默认外链链接：http://music.163.com/song/media/outer/url?id=ID数字.mp3\n\t// 音乐网解析: https://www.jbsou.cn/\n\n    audio: [{\n            name: '所念皆星河',\n            artist: '房东的猫',\n            lrc: '/music/lrc/所念皆星河 - 房东的猫.lrc',\n            cover: 'http://p1.music.126.net/JtevaRk1N7ecpmwZCIvwzQ==/109951165293262893.jpg?param=300y300',\n            url: 'http://music.163.com/song/media/outer/url?id=1476239407.mp3',\n\t\t\ttheme: 'red',\n\t\t\ttype: '',\n                  },\n        {\n            name: '举镜子的女孩',\n            artist: '张子枫',\n            lrc: '/music/lrc/举镜子的女孩 - 张子枫.lrc',\n            cover: 'http://p1.music.126.net/DVPFwwNkeWRiFx_UscjOpA==/109951165582170050.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1871120552.mp3',\n                  },\n\t\t{\n            name: '亲爱的旅人啊',\n            artist: '周深',\n            lrc: '/music/lrc/亲爱的旅人啊 - 周深.lrc',\n            cover: 'http://p2.music.126.net/1YrCPOBV314i-mTtlDg8mQ==/109951164148664637.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1371939273.mp3'\n                  },\n        {\n            name: '平凡的一天',\n            artist: '毛不易',\n            lrc: '/music/lrc/平凡的一天 - 毛不易.lrc',\n            cover: 'http://p1.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214247.mp3'\n                  },\n        {\n            name: '若把你',\n            artist: 'Kirsty刘瑾睿',\n            lrc: '/music/lrc/若把你 - Kirsty刘瑾睿.lrc',\n            cover: 'http://p1.music.126.net/M877M2-VhWZiLPVFORf9iQ==/109951163401482434.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=865632948.mp3'\n                  },\n        {\n            name: '大鱼',\n            artist: '周深',\n            lrc: '/music/lrc/大鱼 (Live) - 周深.lrc',\n            cover: 'https://p2.music.126.net/aiPQXP8mdLovQSrKsM3hMQ==/1416170985079958.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1421191783',\n                  },\n        {\n            name: '远方不远',\n            artist: '徐薇',\n            lrc: '/music/lrc/远方不远 - 徐薇.lrc',\n            cover: 'https://p1.music.126.net/LjwSx1AXf7si4MaAb8bzYw==/109951165041602630.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=431554119.mp3'\n                  },\n        {\n            name: '风铃',\n            artist: '孟凡明',\n            lrc: '/music/lrc/风铃 - 孟凡明.lrc',\n            cover: 'https://p1.music.126.net/ZjWhERuCE8slMan5EzX96w==/109951164358745101.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1390480881.mp3'\n                  },\n        {\n            name: '心如止水',\n            artist: 'Ice Paper',\n            lrc: '/music/lrc/心如止水 - Ice Paper.lrc',\n            cover: 'http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1349292048.mp3'\n                  },\n        {\n            name: '成都',\n            artist: '赵雷',\n            lrc: '/music/lrc/成都 - 赵雷.lrc',\n            cover: '\thttps://p2.music.126.net/34YW1QtKxJ_3YnX9ZzKhzw==/2946691234868155.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=436514312.mp3'\n                  },\n        {\n            name: '忽而今夏',\n            artist: '汪苏泷',\n            lrc: '/music/lrc/忽而今夏 - 汪苏泷.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1366388726.mp3'\n                  },\n        {\n            name: '泡沫',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/泡沫 - G.E.M.邓紫棋.lrc',\n            cover: 'https://p2.music.126.net/fqleir2BWqbmE8tDNLa5Pg==/109951163789160762.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=233931.mp3'\n                  },\n        {\n            name: '何以爱情',\n            artist: '钟汉良',\n            lrc: '/music/lrc/何以爱情 - 钟汉良.lrc',\n            cover: 'https://p2.music.126.net/ODGACHdemEF8EgDy6-Mjlw==/109951163014224498.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1869806072.mp3'\n                  },\n        {\n            name: '可能否',\n            artist: '木小雅',\n            lrc: '/music/lrc/可能否 - 木小雅.lrc',\n            cover: 'https://p2.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214126.mp3'\n                  },\n        {\n            name: '丁香花',\n            artist: '唐磊',\n            lrc: '/music/lrc/丁香花 - 唐磊.lrc',\n            cover: 'https://p2.music.126.net/FdutyVQ0oNOvjDHDixrALw==/844424930132282.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=151985.mp3'\n                  },\n        {\n            name: '冬眠',\n            artist: '司南',\n            lrc: '/music/lrc/冬眠 - 司南.lrc',\n            cover: 'https://p1.music.126.net/4KDBaQXnQywQovmqvjx-8Q==/109951164444131697.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1398663411.mp3'\n                  },\n        {\n            name: '少年 (Live)',\n            artist: '梦然',\n            lrc: '/music/lrc/少年 (Live) - 梦然.lrc',\n            cover: 'https://p2.music.126.net/AcJI2yDiUNgKYn_Wr5eVxw==/109951165358201641.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1483891561.mp3'\n                  },\n        {\n            name: '我和我的祖国',\n            artist: '王菲',\n            lrc: '/music/lrc/我和我的祖国 - 王菲.lrc',\n            cover: 'https://p1.music.126.net/HeGrAKPiZhKkONiFDxZvmw==/109951164384346866.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1392990601.mp3'\n                  },\n        {\n            name: '在青春里遇见',\n            artist: '卜冠今',\n            lrc: '/music/lrc/在青春里遇见 - 卜冠今.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1324399236.mp3'\n                  },\n        {\n            name: '杏花弦外雨',\n            artist: '杏花弦外雨',\n            lrc: '/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc',\n            cover: 'https://p2.music.126.net/iwZ6w7D5C8WXgnjcohHb0Q==/7799935488436943.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=32957012.mp3'\n                  },\n        {\n            name: '刚刚好',\n            artist: '薛之谦',\n            lrc: '/music/lrc/刚刚好 - 薛之谦.lrc',\n            cover: '\thttps://p2.music.126.net/hti_a0LADoFMBHvOBwAtRA==/1369991500930171.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=415792881.mp3'\n                  },\n        {\n            name: '光年之外',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/光年之外 - G.E.M.邓紫棋.lrc',\n            cover: '\thttps://p2.music.126.net/fkqFqMaEt0CzxYS-0NpCog==/18587244069235039.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=449818741.mp3'\n                  },\n        {\n            name: '空空如也 ',\n            artist: '任然',\n            lrc: '/music/lrc/空空如也  - 任然.lrc',\n            cover: 'https://p1.music.126.net/84FJjDgb51TmRqixaUpshg==/109951163094476391.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=526464293.mp3'\n                  },\n\t\t{\n            name: '蓝莲花',\n            artist: '许巍',\n            lrc: '/music/lrc/蓝莲花 - 许巍.lrc',\n            cover: 'http://imge.kugou.com/stdmusic/150/20150719/20150719030234152582.jpg',\n            url: 'http://music.163.com/song/media/outer/url?id=1428019277.mp3'\n                  },\n\n        ],\n\t\tcustomAudioType: {\n\t\t\t'customHls': function (audioElement, audio, player) {\n\t\t\t\tif (Hls.isSupported()) {\n\t\t\t\t\tconst hls = new Hls();\n\t\t\t\t\thls.loadSource(audio.url);\n\t\t\t\t\thls.attachMedia(audioElement);\n\t\t\t\t}\n\t\t\t\telse if (audioElement.canPlayType('application/x-mpegURL') || audioElement.canPlayType('application/vnd.apple.mpegURL')) {\n\t\t\t\t\taudioElement.src = audio.url;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplayer.notice('Error: HLS is not supported.');\n\t\t\t\t}\n\t\t\t}\n       }  \n});","source":"music/aplayer_page_config.js","raw":"const ap = new APlayer({\n\t// 这里命名ap, 与全局音乐播放器ap名称一样 所以在/music页面只出现一个播放器 ; 如果需要同时出现 请命名ap1\n    container: document.getElementById('aplayer2'),\n\t// mini: false,\n    //fixed: true,//吸底模式\n    autoplay: false,//默认是否自动播放\n\t//theme: '#0088cc',\n    loop: 'all',\n    //order: 'random',\n\torder: 'list',\n    preload: 'auto',\n    volume: 0.7,//默认音量\n\tlrcType: 3, //使用lrc文件提供歌词\n    mutex: true,//是否不允许多个播放器同时播放\n    listFolded: false,//是否默认收起播放列表\n    listMaxHeight: 700,//播放列表的高度\n\t//网易云默认外链链接：http://music.163.com/song/media/outer/url?id=ID数字.mp3\n\t// 音乐网解析: https://www.jbsou.cn/\n\n    audio: [{\n            name: '所念皆星河',\n            artist: '房东的猫',\n            lrc: '/music/lrc/所念皆星河 - 房东的猫.lrc',\n            cover: 'http://p1.music.126.net/JtevaRk1N7ecpmwZCIvwzQ==/109951165293262893.jpg?param=300y300',\n            url: 'http://music.163.com/song/media/outer/url?id=1476239407.mp3',\n\t\t\ttheme: 'red',\n\t\t\ttype: '',\n                  },\n        {\n            name: '举镜子的女孩',\n            artist: '张子枫',\n            lrc: '/music/lrc/举镜子的女孩 - 张子枫.lrc',\n            cover: 'http://p1.music.126.net/DVPFwwNkeWRiFx_UscjOpA==/109951165582170050.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1871120552.mp3',\n                  },\n\t\t{\n            name: '亲爱的旅人啊',\n            artist: '周深',\n            lrc: '/music/lrc/亲爱的旅人啊 - 周深.lrc',\n            cover: 'http://p2.music.126.net/1YrCPOBV314i-mTtlDg8mQ==/109951164148664637.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1371939273.mp3'\n                  },\n        {\n            name: '平凡的一天',\n            artist: '毛不易',\n            lrc: '/music/lrc/平凡的一天 - 毛不易.lrc',\n            cover: 'http://p1.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214247.mp3'\n                  },\n        {\n            name: '若把你',\n            artist: 'Kirsty刘瑾睿',\n            lrc: '/music/lrc/若把你 - Kirsty刘瑾睿.lrc',\n            cover: 'http://p1.music.126.net/M877M2-VhWZiLPVFORf9iQ==/109951163401482434.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=865632948.mp3'\n                  },\n        {\n            name: '大鱼',\n            artist: '周深',\n            lrc: '/music/lrc/大鱼 (Live) - 周深.lrc',\n            cover: 'https://p2.music.126.net/aiPQXP8mdLovQSrKsM3hMQ==/1416170985079958.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1421191783',\n                  },\n        {\n            name: '远方不远',\n            artist: '徐薇',\n            lrc: '/music/lrc/远方不远 - 徐薇.lrc',\n            cover: 'https://p1.music.126.net/LjwSx1AXf7si4MaAb8bzYw==/109951165041602630.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=431554119.mp3'\n                  },\n        {\n            name: '风铃',\n            artist: '孟凡明',\n            lrc: '/music/lrc/风铃 - 孟凡明.lrc',\n            cover: 'https://p1.music.126.net/ZjWhERuCE8slMan5EzX96w==/109951164358745101.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1390480881.mp3'\n                  },\n        {\n            name: '心如止水',\n            artist: 'Ice Paper',\n            lrc: '/music/lrc/心如止水 - Ice Paper.lrc',\n            cover: 'http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1349292048.mp3'\n                  },\n        {\n            name: '成都',\n            artist: '赵雷',\n            lrc: '/music/lrc/成都 - 赵雷.lrc',\n            cover: '\thttps://p2.music.126.net/34YW1QtKxJ_3YnX9ZzKhzw==/2946691234868155.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=436514312.mp3'\n                  },\n        {\n            name: '忽而今夏',\n            artist: '汪苏泷',\n            lrc: '/music/lrc/忽而今夏 - 汪苏泷.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1366388726.mp3'\n                  },\n        {\n            name: '泡沫',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/泡沫 - G.E.M.邓紫棋.lrc',\n            cover: 'https://p2.music.126.net/fqleir2BWqbmE8tDNLa5Pg==/109951163789160762.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=233931.mp3'\n                  },\n        {\n            name: '何以爱情',\n            artist: '钟汉良',\n            lrc: '/music/lrc/何以爱情 - 钟汉良.lrc',\n            cover: 'https://p2.music.126.net/ODGACHdemEF8EgDy6-Mjlw==/109951163014224498.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1869806072.mp3'\n                  },\n        {\n            name: '可能否',\n            artist: '木小雅',\n            lrc: '/music/lrc/可能否 - 木小雅.lrc',\n            cover: 'https://p2.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214126.mp3'\n                  },\n        {\n            name: '丁香花',\n            artist: '唐磊',\n            lrc: '/music/lrc/丁香花 - 唐磊.lrc',\n            cover: 'https://p2.music.126.net/FdutyVQ0oNOvjDHDixrALw==/844424930132282.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=151985.mp3'\n                  },\n        {\n            name: '冬眠',\n            artist: '司南',\n            lrc: '/music/lrc/冬眠 - 司南.lrc',\n            cover: 'https://p1.music.126.net/4KDBaQXnQywQovmqvjx-8Q==/109951164444131697.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1398663411.mp3'\n                  },\n        {\n            name: '少年 (Live)',\n            artist: '梦然',\n            lrc: '/music/lrc/少年 (Live) - 梦然.lrc',\n            cover: 'https://p2.music.126.net/AcJI2yDiUNgKYn_Wr5eVxw==/109951165358201641.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1483891561.mp3'\n                  },\n        {\n            name: '我和我的祖国',\n            artist: '王菲',\n            lrc: '/music/lrc/我和我的祖国 - 王菲.lrc',\n            cover: 'https://p1.music.126.net/HeGrAKPiZhKkONiFDxZvmw==/109951164384346866.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1392990601.mp3'\n                  },\n        {\n            name: '在青春里遇见',\n            artist: '卜冠今',\n            lrc: '/music/lrc/在青春里遇见 - 卜冠今.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1324399236.mp3'\n                  },\n        {\n            name: '杏花弦外雨',\n            artist: '杏花弦外雨',\n            lrc: '/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc',\n            cover: 'https://p2.music.126.net/iwZ6w7D5C8WXgnjcohHb0Q==/7799935488436943.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=32957012.mp3'\n                  },\n        {\n            name: '刚刚好',\n            artist: '薛之谦',\n            lrc: '/music/lrc/刚刚好 - 薛之谦.lrc',\n            cover: '\thttps://p2.music.126.net/hti_a0LADoFMBHvOBwAtRA==/1369991500930171.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=415792881.mp3'\n                  },\n        {\n            name: '光年之外',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/光年之外 - G.E.M.邓紫棋.lrc',\n            cover: '\thttps://p2.music.126.net/fkqFqMaEt0CzxYS-0NpCog==/18587244069235039.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=449818741.mp3'\n                  },\n        {\n            name: '空空如也 ',\n            artist: '任然',\n            lrc: '/music/lrc/空空如也  - 任然.lrc',\n            cover: 'https://p1.music.126.net/84FJjDgb51TmRqixaUpshg==/109951163094476391.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=526464293.mp3'\n                  },\n\t\t{\n            name: '蓝莲花',\n            artist: '许巍',\n            lrc: '/music/lrc/蓝莲花 - 许巍.lrc',\n            cover: 'http://imge.kugou.com/stdmusic/150/20150719/20150719030234152582.jpg',\n            url: 'http://music.163.com/song/media/outer/url?id=1428019277.mp3'\n                  },\n\n        ],\n\t\tcustomAudioType: {\n\t\t\t'customHls': function (audioElement, audio, player) {\n\t\t\t\tif (Hls.isSupported()) {\n\t\t\t\t\tconst hls = new Hls();\n\t\t\t\t\thls.loadSource(audio.url);\n\t\t\t\t\thls.attachMedia(audioElement);\n\t\t\t\t}\n\t\t\t\telse if (audioElement.canPlayType('application/x-mpegURL') || audioElement.canPlayType('application/vnd.apple.mpegURL')) {\n\t\t\t\t\taudioElement.src = audio.url;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplayer.notice('Error: HLS is not supported.');\n\t\t\t\t}\n\t\t\t}\n       }  \n});","date":"2021-10-16T12:20:39.891Z","updated":"2021-10-16T12:20:39.891Z","path":"music/aplayer_page_config.js","layout":"false","title":"","comments":1,"_id":"clb218l3z000264rg5jtb1i6m","content":"const ap = new APlayer({\n\t// 这里命名ap, 与全局音乐播放器ap名称一样 所以在/music页面只出现一个播放器 ; 如果需要同时出现 请命名ap1\n    container: document.getElementById('aplayer2'),\n\t// mini: false,\n    //fixed: true,//吸底模式\n    autoplay: false,//默认是否自动播放\n\t//theme: '#0088cc',\n    loop: 'all',\n    //order: 'random',\n\torder: 'list',\n    preload: 'auto',\n    volume: 0.7,//默认音量\n\tlrcType: 3, //使用lrc文件提供歌词\n    mutex: true,//是否不允许多个播放器同时播放\n    listFolded: false,//是否默认收起播放列表\n    listMaxHeight: 700,//播放列表的高度\n\t//网易云默认外链链接：http://music.163.com/song/media/outer/url?id=ID数字.mp3\n\t// 音乐网解析: https://www.jbsou.cn/\n\n    audio: [{\n            name: '所念皆星河',\n            artist: '房东的猫',\n            lrc: '/music/lrc/所念皆星河 - 房东的猫.lrc',\n            cover: 'http://p1.music.126.net/JtevaRk1N7ecpmwZCIvwzQ==/109951165293262893.jpg?param=300y300',\n            url: 'http://music.163.com/song/media/outer/url?id=1476239407.mp3',\n\t\t\ttheme: 'red',\n\t\t\ttype: '',\n                  },\n        {\n            name: '举镜子的女孩',\n            artist: '张子枫',\n            lrc: '/music/lrc/举镜子的女孩 - 张子枫.lrc',\n            cover: 'http://p1.music.126.net/DVPFwwNkeWRiFx_UscjOpA==/109951165582170050.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1871120552.mp3',\n                  },\n\t\t{\n            name: '亲爱的旅人啊',\n            artist: '周深',\n            lrc: '/music/lrc/亲爱的旅人啊 - 周深.lrc',\n            cover: 'http://p2.music.126.net/1YrCPOBV314i-mTtlDg8mQ==/109951164148664637.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1371939273.mp3'\n                  },\n        {\n            name: '平凡的一天',\n            artist: '毛不易',\n            lrc: '/music/lrc/平凡的一天 - 毛不易.lrc',\n            cover: 'http://p1.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214247.mp3'\n                  },\n        {\n            name: '若把你',\n            artist: 'Kirsty刘瑾睿',\n            lrc: '/music/lrc/若把你 - Kirsty刘瑾睿.lrc',\n            cover: 'http://p1.music.126.net/M877M2-VhWZiLPVFORf9iQ==/109951163401482434.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=865632948.mp3'\n                  },\n        {\n            name: '大鱼',\n            artist: '周深',\n            lrc: '/music/lrc/大鱼 (Live) - 周深.lrc',\n            cover: 'https://p2.music.126.net/aiPQXP8mdLovQSrKsM3hMQ==/1416170985079958.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1421191783',\n                  },\n        {\n            name: '远方不远',\n            artist: '徐薇',\n            lrc: '/music/lrc/远方不远 - 徐薇.lrc',\n            cover: 'https://p1.music.126.net/LjwSx1AXf7si4MaAb8bzYw==/109951165041602630.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=431554119.mp3'\n                  },\n        {\n            name: '风铃',\n            artist: '孟凡明',\n            lrc: '/music/lrc/风铃 - 孟凡明.lrc',\n            cover: 'https://p1.music.126.net/ZjWhERuCE8slMan5EzX96w==/109951164358745101.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1390480881.mp3'\n                  },\n        {\n            name: '心如止水',\n            artist: 'Ice Paper',\n            lrc: '/music/lrc/心如止水 - Ice Paper.lrc',\n            cover: 'http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1349292048.mp3'\n                  },\n        {\n            name: '成都',\n            artist: '赵雷',\n            lrc: '/music/lrc/成都 - 赵雷.lrc',\n            cover: '\thttps://p2.music.126.net/34YW1QtKxJ_3YnX9ZzKhzw==/2946691234868155.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=436514312.mp3'\n                  },\n        {\n            name: '忽而今夏',\n            artist: '汪苏泷',\n            lrc: '/music/lrc/忽而今夏 - 汪苏泷.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1366388726.mp3'\n                  },\n        {\n            name: '泡沫',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/泡沫 - G.E.M.邓紫棋.lrc',\n            cover: 'https://p2.music.126.net/fqleir2BWqbmE8tDNLa5Pg==/109951163789160762.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=233931.mp3'\n                  },\n        {\n            name: '何以爱情',\n            artist: '钟汉良',\n            lrc: '/music/lrc/何以爱情 - 钟汉良.lrc',\n            cover: 'https://p2.music.126.net/ODGACHdemEF8EgDy6-Mjlw==/109951163014224498.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1869806072.mp3'\n                  },\n        {\n            name: '可能否',\n            artist: '木小雅',\n            lrc: '/music/lrc/可能否 - 木小雅.lrc',\n            cover: 'https://p2.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214126.mp3'\n                  },\n        {\n            name: '丁香花',\n            artist: '唐磊',\n            lrc: '/music/lrc/丁香花 - 唐磊.lrc',\n            cover: 'https://p2.music.126.net/FdutyVQ0oNOvjDHDixrALw==/844424930132282.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=151985.mp3'\n                  },\n        {\n            name: '冬眠',\n            artist: '司南',\n            lrc: '/music/lrc/冬眠 - 司南.lrc',\n            cover: 'https://p1.music.126.net/4KDBaQXnQywQovmqvjx-8Q==/109951164444131697.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1398663411.mp3'\n                  },\n        {\n            name: '少年 (Live)',\n            artist: '梦然',\n            lrc: '/music/lrc/少年 (Live) - 梦然.lrc',\n            cover: 'https://p2.music.126.net/AcJI2yDiUNgKYn_Wr5eVxw==/109951165358201641.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1483891561.mp3'\n                  },\n        {\n            name: '我和我的祖国',\n            artist: '王菲',\n            lrc: '/music/lrc/我和我的祖国 - 王菲.lrc',\n            cover: 'https://p1.music.126.net/HeGrAKPiZhKkONiFDxZvmw==/109951164384346866.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1392990601.mp3'\n                  },\n        {\n            name: '在青春里遇见',\n            artist: '卜冠今',\n            lrc: '/music/lrc/在青春里遇见 - 卜冠今.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1324399236.mp3'\n                  },\n        {\n            name: '杏花弦外雨',\n            artist: '杏花弦外雨',\n            lrc: '/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc',\n            cover: 'https://p2.music.126.net/iwZ6w7D5C8WXgnjcohHb0Q==/7799935488436943.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=32957012.mp3'\n                  },\n        {\n            name: '刚刚好',\n            artist: '薛之谦',\n            lrc: '/music/lrc/刚刚好 - 薛之谦.lrc',\n            cover: '\thttps://p2.music.126.net/hti_a0LADoFMBHvOBwAtRA==/1369991500930171.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=415792881.mp3'\n                  },\n        {\n            name: '光年之外',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/光年之外 - G.E.M.邓紫棋.lrc',\n            cover: '\thttps://p2.music.126.net/fkqFqMaEt0CzxYS-0NpCog==/18587244069235039.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=449818741.mp3'\n                  },\n        {\n            name: '空空如也 ',\n            artist: '任然',\n            lrc: '/music/lrc/空空如也  - 任然.lrc',\n            cover: 'https://p1.music.126.net/84FJjDgb51TmRqixaUpshg==/109951163094476391.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=526464293.mp3'\n                  },\n\t\t{\n            name: '蓝莲花',\n            artist: '许巍',\n            lrc: '/music/lrc/蓝莲花 - 许巍.lrc',\n            cover: 'http://imge.kugou.com/stdmusic/150/20150719/20150719030234152582.jpg',\n            url: 'http://music.163.com/song/media/outer/url?id=1428019277.mp3'\n                  },\n\n        ],\n\t\tcustomAudioType: {\n\t\t\t'customHls': function (audioElement, audio, player) {\n\t\t\t\tif (Hls.isSupported()) {\n\t\t\t\t\tconst hls = new Hls();\n\t\t\t\t\thls.loadSource(audio.url);\n\t\t\t\t\thls.attachMedia(audioElement);\n\t\t\t\t}\n\t\t\t\telse if (audioElement.canPlayType('application/x-mpegURL') || audioElement.canPlayType('application/vnd.apple.mpegURL')) {\n\t\t\t\t\taudioElement.src = audio.url;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplayer.notice('Error: HLS is not supported.');\n\t\t\t\t}\n\t\t\t}\n       }  \n});","site":{"data":{}},"excerpt":"","more":"const ap = new APlayer({\n\t// 这里命名ap, 与全局音乐播放器ap名称一样 所以在/music页面只出现一个播放器 ; 如果需要同时出现 请命名ap1\n    container: document.getElementById('aplayer2'),\n\t// mini: false,\n    //fixed: true,//吸底模式\n    autoplay: false,//默认是否自动播放\n\t//theme: '#0088cc',\n    loop: 'all',\n    //order: 'random',\n\torder: 'list',\n    preload: 'auto',\n    volume: 0.7,//默认音量\n\tlrcType: 3, //使用lrc文件提供歌词\n    mutex: true,//是否不允许多个播放器同时播放\n    listFolded: false,//是否默认收起播放列表\n    listMaxHeight: 700,//播放列表的高度\n\t//网易云默认外链链接：http://music.163.com/song/media/outer/url?id=ID数字.mp3\n\t// 音乐网解析: https://www.jbsou.cn/\n\n    audio: [{\n            name: '所念皆星河',\n            artist: '房东的猫',\n            lrc: '/music/lrc/所念皆星河 - 房东的猫.lrc',\n            cover: 'http://p1.music.126.net/JtevaRk1N7ecpmwZCIvwzQ==/109951165293262893.jpg?param=300y300',\n            url: 'http://music.163.com/song/media/outer/url?id=1476239407.mp3',\n\t\t\ttheme: 'red',\n\t\t\ttype: '',\n                  },\n        {\n            name: '举镜子的女孩',\n            artist: '张子枫',\n            lrc: '/music/lrc/举镜子的女孩 - 张子枫.lrc',\n            cover: 'http://p1.music.126.net/DVPFwwNkeWRiFx_UscjOpA==/109951165582170050.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1871120552.mp3',\n                  },\n\t\t{\n            name: '亲爱的旅人啊',\n            artist: '周深',\n            lrc: '/music/lrc/亲爱的旅人啊 - 周深.lrc',\n            cover: 'http://p2.music.126.net/1YrCPOBV314i-mTtlDg8mQ==/109951164148664637.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1371939273.mp3'\n                  },\n        {\n            name: '平凡的一天',\n            artist: '毛不易',\n            lrc: '/music/lrc/平凡的一天 - 毛不易.lrc',\n            cover: 'http://p1.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214247.mp3'\n                  },\n        {\n            name: '若把你',\n            artist: 'Kirsty刘瑾睿',\n            lrc: '/music/lrc/若把你 - Kirsty刘瑾睿.lrc',\n            cover: 'http://p1.music.126.net/M877M2-VhWZiLPVFORf9iQ==/109951163401482434.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=865632948.mp3'\n                  },\n        {\n            name: '大鱼',\n            artist: '周深',\n            lrc: '/music/lrc/大鱼 (Live) - 周深.lrc',\n            cover: 'https://p2.music.126.net/aiPQXP8mdLovQSrKsM3hMQ==/1416170985079958.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1421191783',\n                  },\n        {\n            name: '远方不远',\n            artist: '徐薇',\n            lrc: '/music/lrc/远方不远 - 徐薇.lrc',\n            cover: 'https://p1.music.126.net/LjwSx1AXf7si4MaAb8bzYw==/109951165041602630.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=431554119.mp3'\n                  },\n        {\n            name: '风铃',\n            artist: '孟凡明',\n            lrc: '/music/lrc/风铃 - 孟凡明.lrc',\n            cover: 'https://p1.music.126.net/ZjWhERuCE8slMan5EzX96w==/109951164358745101.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1390480881.mp3'\n                  },\n        {\n            name: '心如止水',\n            artist: 'Ice Paper',\n            lrc: '/music/lrc/心如止水 - Ice Paper.lrc',\n            cover: 'http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1349292048.mp3'\n                  },\n        {\n            name: '成都',\n            artist: '赵雷',\n            lrc: '/music/lrc/成都 - 赵雷.lrc',\n            cover: '\thttps://p2.music.126.net/34YW1QtKxJ_3YnX9ZzKhzw==/2946691234868155.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=436514312.mp3'\n                  },\n        {\n            name: '忽而今夏',\n            artist: '汪苏泷',\n            lrc: '/music/lrc/忽而今夏 - 汪苏泷.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1366388726.mp3'\n                  },\n        {\n            name: '泡沫',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/泡沫 - G.E.M.邓紫棋.lrc',\n            cover: 'https://p2.music.126.net/fqleir2BWqbmE8tDNLa5Pg==/109951163789160762.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=233931.mp3'\n                  },\n        {\n            name: '何以爱情',\n            artist: '钟汉良',\n            lrc: '/music/lrc/何以爱情 - 钟汉良.lrc',\n            cover: 'https://p2.music.126.net/ODGACHdemEF8EgDy6-Mjlw==/109951163014224498.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1869806072.mp3'\n                  },\n        {\n            name: '可能否',\n            artist: '木小雅',\n            lrc: '/music/lrc/可能否 - 木小雅.lrc',\n            cover: 'https://p2.music.126.net/SJYnDay7wgewU3O7tPfmOQ==/109951163322541581.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=569214126.mp3'\n                  },\n        {\n            name: '丁香花',\n            artist: '唐磊',\n            lrc: '/music/lrc/丁香花 - 唐磊.lrc',\n            cover: 'https://p2.music.126.net/FdutyVQ0oNOvjDHDixrALw==/844424930132282.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=151985.mp3'\n                  },\n        {\n            name: '冬眠',\n            artist: '司南',\n            lrc: '/music/lrc/冬眠 - 司南.lrc',\n            cover: 'https://p1.music.126.net/4KDBaQXnQywQovmqvjx-8Q==/109951164444131697.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1398663411.mp3'\n                  },\n        {\n            name: '少年 (Live)',\n            artist: '梦然',\n            lrc: '/music/lrc/少年 (Live) - 梦然.lrc',\n            cover: 'https://p2.music.126.net/AcJI2yDiUNgKYn_Wr5eVxw==/109951165358201641.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1483891561.mp3'\n                  },\n        {\n            name: '我和我的祖国',\n            artist: '王菲',\n            lrc: '/music/lrc/我和我的祖国 - 王菲.lrc',\n            cover: 'https://p1.music.126.net/HeGrAKPiZhKkONiFDxZvmw==/109951164384346866.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1392990601.mp3'\n                  },\n        {\n            name: '在青春里遇见',\n            artist: '卜冠今',\n            lrc: '/music/lrc/在青春里遇见 - 卜冠今.lrc',\n            cover: 'https://p2.music.126.net/Oq2wbMND4y6jTSL5F3HmNA==/109951163293541812.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=1324399236.mp3'\n                  },\n        {\n            name: '杏花弦外雨',\n            artist: '杏花弦外雨',\n            lrc: '/music/lrc/杏花弦外雨 - CRITTY,司夏.lrc',\n            cover: 'https://p2.music.126.net/iwZ6w7D5C8WXgnjcohHb0Q==/7799935488436943.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=32957012.mp3'\n                  },\n        {\n            name: '刚刚好',\n            artist: '薛之谦',\n            lrc: '/music/lrc/刚刚好 - 薛之谦.lrc',\n            cover: '\thttps://p2.music.126.net/hti_a0LADoFMBHvOBwAtRA==/1369991500930171.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=415792881.mp3'\n                  },\n        {\n            name: '光年之外',\n            artist: 'G.E.M.邓紫棋',\n            lrc: '/music/lrc/光年之外 - G.E.M.邓紫棋.lrc',\n            cover: '\thttps://p2.music.126.net/fkqFqMaEt0CzxYS-0NpCog==/18587244069235039.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=449818741.mp3'\n                  },\n        {\n            name: '空空如也 ',\n            artist: '任然',\n            lrc: '/music/lrc/空空如也  - 任然.lrc',\n            cover: 'https://p1.music.126.net/84FJjDgb51TmRqixaUpshg==/109951163094476391.jpg?param=300x300',\n            url: 'http://music.163.com/song/media/outer/url?id=526464293.mp3'\n                  },\n\t\t{\n            name: '蓝莲花',\n            artist: '许巍',\n            lrc: '/music/lrc/蓝莲花 - 许巍.lrc',\n            cover: 'http://imge.kugou.com/stdmusic/150/20150719/20150719030234152582.jpg',\n            url: 'http://music.163.com/song/media/outer/url?id=1428019277.mp3'\n                  },\n\n        ],\n\t\tcustomAudioType: {\n\t\t\t'customHls': function (audioElement, audio, player) {\n\t\t\t\tif (Hls.isSupported()) {\n\t\t\t\t\tconst hls = new Hls();\n\t\t\t\t\thls.loadSource(audio.url);\n\t\t\t\t\thls.attachMedia(audioElement);\n\t\t\t\t}\n\t\t\t\telse if (audioElement.canPlayType('application/x-mpegURL') || audioElement.canPlayType('application/vnd.apple.mpegURL')) {\n\t\t\t\t\taudioElement.src = audio.url;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplayer.notice('Error: HLS is not supported.');\n\t\t\t\t}\n\t\t\t}\n       }  \n});"},{"title":"分类","type":"categories","no_word_count":true,"no_date":true,"no_declare":true,"no_toc":true,"no_reward":true,"no_comments":false,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\nno_word_count: true\nno_date: true\nno_declare: true\nno_toc: true\nno_reward: true\nno_comments: false\n---\n","date":"2022-11-25T07:41:09.423Z","updated":"2021-10-13T09:30:50.950Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clb218l3z000364rgd1rob7g3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"音乐","no_word_count":true,"no_date":true,"no_declare":true,"no_toc":true,"no_reward":true,"no_comments":false,"_content":"\n<center>\n    <img src=\"https://qiniu.findn.cn/blog/photos/article/music-1.jpg\" />\n</center>\n\n\n<!-- 添加APlayer音乐播放器,详见: https://aplayer.js.org -->\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css\">\n\n<!-- 列表左对齐 并显示在最上面一层 -->\n<div id=\"aplayer2\" style=\"text-align:left;\">\n\n<script src=\"https://cdn.jsdelivr.net/npm/hls.js@latest\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/color-thief-don@2.0.2/src/color-thief.js\"></script>\n\n<!-- 为方便修改，添加一个配置文件，修改时直接修改配置文件即可。 -->\n<script type=\"text/javascript\" src=\"/music/aplayer_page_config.js\"></script>\n\n<!-- 根据封面自适应主题色，主要是作用于进度条 -->\n<script type=\"text/javascript\">\n\t  const colorThief = new ColorThief();\n\t  const setTheme = (index) => {\n\t\tif (!ap.list.audios[index].theme) {\n\t\t  colorThief.getColorAsync(ap.list.audios[index].cover, function(color) {\n\t\t\tap.theme(`rgb(${color[0]}, ${color[1]}, ${color[2]})`, index);\n\t\t  });\n\t\t}\n\t  };\n\t  setTheme(ap.list.index);\n\t  ap.on('listswitch', (data) => {\n\t\tsetTheme(data.index);\n\t  });\n</script>\n\n<!-- APlayer音乐播放器功能结束 -->\n\n\n<center>\n    <h1></h1>\n\t<h1></h1>\n</center>\n\n<center>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/music-2.jpg\" />\n</center>\n\n<!-- 用meting-js 添加APlayer音乐播放器, 可以实现添加导入音乐列表, 详见: https://github.com/metowolf/MetingJS -->\n<!-- 支持server：netease, tencent, kugou, xiami, baidu -->\n<!-- 网易云音乐 “我喜欢的音乐”不支持 其它收藏歌单均支持 -->\n<!-- require APlayer -->\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\"></script>\n<!-- require MetingJS -->\n<script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\"></script>\n\n\n<!-- 歌单 替换id即可 -->\n<meting-js style=\"margin-top: 1.5rem;width: auto;height: auto\"\n\tserver=\"netease\"\n\ttype=\"playlist\"\n\tid=\"6728476093\"\n\tfixed=\"false\"\n\tmini=\"false\"\n\ttheme=\"#0088cc\"\n\tautoplay=\"false\"\n\tloop=\"all\"\n\tpreload=\"auto\"\n\tvolume=\"0.7\"\n\torder=\"list\"\n\tmutex=\"true\"\n\tlist-folded=\"false\"\n\tlist-max-height=\"700px\"\n\tstorage-name=\"metingjs\">\n</meting-js>\n\n\n\n\n\n\n\n\n","source":"music/index.md","raw":"---\ntitle: 音乐\nno_word_count: true\nno_date: true\nno_declare: true\nno_toc: true\nno_reward: true\nno_comments: false\n---\n\n<center>\n    <img src=\"https://qiniu.findn.cn/blog/photos/article/music-1.jpg\" />\n</center>\n\n\n<!-- 添加APlayer音乐播放器,详见: https://aplayer.js.org -->\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css\">\n\n<!-- 列表左对齐 并显示在最上面一层 -->\n<div id=\"aplayer2\" style=\"text-align:left;\">\n\n<script src=\"https://cdn.jsdelivr.net/npm/hls.js@latest\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/color-thief-don@2.0.2/src/color-thief.js\"></script>\n\n<!-- 为方便修改，添加一个配置文件，修改时直接修改配置文件即可。 -->\n<script type=\"text/javascript\" src=\"/music/aplayer_page_config.js\"></script>\n\n<!-- 根据封面自适应主题色，主要是作用于进度条 -->\n<script type=\"text/javascript\">\n\t  const colorThief = new ColorThief();\n\t  const setTheme = (index) => {\n\t\tif (!ap.list.audios[index].theme) {\n\t\t  colorThief.getColorAsync(ap.list.audios[index].cover, function(color) {\n\t\t\tap.theme(`rgb(${color[0]}, ${color[1]}, ${color[2]})`, index);\n\t\t  });\n\t\t}\n\t  };\n\t  setTheme(ap.list.index);\n\t  ap.on('listswitch', (data) => {\n\t\tsetTheme(data.index);\n\t  });\n</script>\n\n<!-- APlayer音乐播放器功能结束 -->\n\n\n<center>\n    <h1></h1>\n\t<h1></h1>\n</center>\n\n<center>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/music-2.jpg\" />\n</center>\n\n<!-- 用meting-js 添加APlayer音乐播放器, 可以实现添加导入音乐列表, 详见: https://github.com/metowolf/MetingJS -->\n<!-- 支持server：netease, tencent, kugou, xiami, baidu -->\n<!-- 网易云音乐 “我喜欢的音乐”不支持 其它收藏歌单均支持 -->\n<!-- require APlayer -->\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\"></script>\n<!-- require MetingJS -->\n<script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\"></script>\n\n\n<!-- 歌单 替换id即可 -->\n<meting-js style=\"margin-top: 1.5rem;width: auto;height: auto\"\n\tserver=\"netease\"\n\ttype=\"playlist\"\n\tid=\"6728476093\"\n\tfixed=\"false\"\n\tmini=\"false\"\n\ttheme=\"#0088cc\"\n\tautoplay=\"false\"\n\tloop=\"all\"\n\tpreload=\"auto\"\n\tvolume=\"0.7\"\n\torder=\"list\"\n\tmutex=\"true\"\n\tlist-folded=\"false\"\n\tlist-max-height=\"700px\"\n\tstorage-name=\"metingjs\">\n</meting-js>\n\n\n\n\n\n\n\n\n","date":"2022-11-24T13:26:51.899Z","updated":"2021-10-15T13:40:28.964Z","path":"music/index.html","comments":1,"layout":"page","_id":"clb218l40000464rg2jys02sa","content":"<center>\n    <img src=\"https://qiniu.findn.cn/blog/photos/article/music-1.jpg\" />\n</center>\n\n\n<!-- 添加APlayer音乐播放器,详见: https://aplayer.js.org -->\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css\">\n\n<!-- 列表左对齐 并显示在最上面一层 -->\n<div id=\"aplayer2\" style=\"text-align:left;\">\n\n<script src=\"https://cdn.jsdelivr.net/npm/hls.js@latest\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/color-thief-don@2.0.2/src/color-thief.js\"></script>\n\n<!-- 为方便修改，添加一个配置文件，修改时直接修改配置文件即可。 -->\n<script type=\"text/javascript\" src=\"/music/aplayer_page_config.js\"></script>\n\n<!-- 根据封面自适应主题色，主要是作用于进度条 -->\n<script type=\"text/javascript\">\n      const colorThief = new ColorThief();\n      const setTheme = (index) => {\n        if (!ap.list.audios[index].theme) {\n          colorThief.getColorAsync(ap.list.audios[index].cover, function(color) {\n            ap.theme(`rgb(${color[0]}, ${color[1]}, ${color[2]})`, index);\n          });\n        }\n      };\n      setTheme(ap.list.index);\n      ap.on('listswitch', (data) => {\n        setTheme(data.index);\n      });\n</script>\n\n<!-- APlayer音乐播放器功能结束 -->\n\n\n<center>\n    <h1></h1>\n    <h1></h1>\n</center>\n\n<center>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/music-2.jpg\" />\n</center>\n\n<!-- 用meting-js 添加APlayer音乐播放器, 可以实现添加导入音乐列表, 详见: https://github.com/metowolf/MetingJS -->\n<!-- 支持server：netease, tencent, kugou, xiami, baidu -->\n<!-- 网易云音乐 “我喜欢的音乐”不支持 其它收藏歌单均支持 -->\n<!-- require APlayer -->\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\"></script>\n<!-- require MetingJS -->\n<script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\"></script>\n\n\n<!-- 歌单 替换id即可 -->\n<p><meting-js style=\"margin-top: 1.5rem;width: auto;height: auto\"\n    server=\"netease\"\n    type=\"playlist\"\n    id=\"6728476093\"\n    fixed=\"false\"\n    mini=\"false\"\n    theme=\"#0088cc\"\n    autoplay=\"false\"\n    loop=\"all\"\n    preload=\"auto\"\n    volume=\"0.7\"\n    order=\"list\"\n    mutex=\"true\"\n    list-folded=\"false\"\n    list-max-height=\"700px\"\n    storage-name=\"metingjs\"><br></meting-js></p>\n","site":{"data":{}},"excerpt":"","more":"<center>\n    <img src=\"https://qiniu.findn.cn/blog/photos/article/music-1.jpg\" />\n</center>\n\n\n<!-- 添加APlayer音乐播放器,详见: https://aplayer.js.org -->\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css\">\n\n<!-- 列表左对齐 并显示在最上面一层 -->\n<div id=\"aplayer2\" style=\"text-align:left;\">\n\n<script src=\"https://cdn.jsdelivr.net/npm/hls.js@latest\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/color-thief-don@2.0.2/src/color-thief.js\"></script>\n\n<!-- 为方便修改，添加一个配置文件，修改时直接修改配置文件即可。 -->\n<script type=\"text/javascript\" src=\"/music/aplayer_page_config.js\"></script>\n\n<!-- 根据封面自适应主题色，主要是作用于进度条 -->\n<script type=\"text/javascript\">\n      const colorThief = new ColorThief();\n      const setTheme = (index) => {\n        if (!ap.list.audios[index].theme) {\n          colorThief.getColorAsync(ap.list.audios[index].cover, function(color) {\n            ap.theme(`rgb(${color[0]}, ${color[1]}, ${color[2]})`, index);\n          });\n        }\n      };\n      setTheme(ap.list.index);\n      ap.on('listswitch', (data) => {\n        setTheme(data.index);\n      });\n</script>\n\n<!-- APlayer音乐播放器功能结束 -->\n\n\n<center>\n    <h1></h1>\n    <h1></h1>\n</center>\n\n<center>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/music-2.jpg\" />\n</center>\n\n<!-- 用meting-js 添加APlayer音乐播放器, 可以实现添加导入音乐列表, 详见: https://github.com/metowolf/MetingJS -->\n<!-- 支持server：netease, tencent, kugou, xiami, baidu -->\n<!-- 网易云音乐 “我喜欢的音乐”不支持 其它收藏歌单均支持 -->\n<!-- require APlayer -->\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\"></script>\n<!-- require MetingJS -->\n<script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\"></script>\n\n\n<!-- 歌单 替换id即可 -->\n<p><meting-js style=\"margin-top: 1.5rem;width: auto;height: auto\"\n    server=\"netease\"\n    type=\"playlist\"\n    id=\"6728476093\"\n    fixed=\"false\"\n    mini=\"false\"\n    theme=\"#0088cc\"\n    autoplay=\"false\"\n    loop=\"all\"\n    preload=\"auto\"\n    volume=\"0.7\"\n    order=\"list\"\n    mutex=\"true\"\n    list-folded=\"false\"\n    list-max-height=\"700px\"\n    storage-name=\"metingjs\"><br></meting-js></p>\n"},{"_content":"{\"list\": [{\"date\": \"2022-08\", \"arr\": {\"year\": 2022, \"month\": 8, \"link\": [\"2022-08-01_\\u548c\\u4f60\\u4e00\\u8d77.jpg\", \"2022-08-02_\\u53e4\\u89c2\\u97f3\\u7985\\u5bfa.jpg\"], \"text\": [\"\\u548c\\u4f60\\u4e00\\u8d77\", \"\\u53e4\\u89c2\\u97f3\\u7985\\u5bfa\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2022-07\", \"arr\": {\"year\": 2022, \"month\": 7, \"link\": [\"2022-07-28_\\u949f\\u697c.jpg\", \"2022-07-31_\\u4e00\\u8d77\\u8d70\\u591c\\u8def.jpg\", \"2022-07-31_\\u5927\\u96c1\\u5854.jpg\"], \"text\": [\"\\u949f\\u697c\", \"\\u4e00\\u8d77\\u8d70\\u591c\\u8def\", \"\\u5927\\u96c1\\u5854\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2022-06\", \"arr\": {\"year\": 2022, \"month\": 6, \"link\": [\"2022-06-15_\\u5f00\\u53d1\\u533a\\u8f7b\\u8f68.jpg\", \"2022-06-30_\\u51b0\\u723d\\u6c14\\u6ce1\\u6c34.jpg\"], \"text\": [\"\\u5f00\\u53d1\\u533a\\u8f7b\\u8f68\", \"\\u51b0\\u723d\\u6c14\\u6ce1\\u6c34\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2022-05\", \"arr\": {\"year\": 2022, \"month\": 5, \"link\": [\"2022-05-20_\\u5c0f\\u60ca\\u559c.jpg\"], \"text\": [\"\\u5c0f\\u60ca\\u559c\"], \"type\": [\"image\"]}}, {\"date\": \"2022-02\", \"arr\": {\"year\": 2022, \"month\": 2, \"link\": [\"2022-02-02_\\u864e\\u864e\\u864e.jpg\", \"2022-02-02_\\u9655\\u5317\\u7a97\\u82b1.jpg\", \"2022-02-05_\\u5e74\\u591c\\u996d.jpg\", \"2022-02-14_\\u7b2c\\u4e00\\u4e2a\\u60c5\\u4eba\\u8282.jpg\"], \"text\": [\"\\u864e\\u864e\\u864e\", \"\\u9655\\u5317\\u7a97\\u82b1\", \"\\u5e74\\u591c\\u996d\", \"\\u7b2c\\u4e00\\u4e2a\\u60c5\\u4eba\\u8282\"], \"type\": [\"image\", \"image\", \"image\", \"image\"]}}, {\"date\": \"2021-10\", \"arr\": {\"year\": 2021, \"month\": 10, \"link\": [\"2021-10-01_\\u6e05\\u8377.jpg\", \"2021-10-24_\\u751f\\u65e5\\u4e0d\\u5b64\\u5355.jpg\", \"2021-10-29_\\u79cb.jpg\"], \"text\": [\"\\u6e05\\u8377\", \"\\u751f\\u65e5\\u4e0d\\u5b64\\u5355\", \"\\u79cb\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2021-09\", \"arr\": {\"year\": 2021, \"month\": 9, \"link\": [\"2021-09-22_\\u684c\\u9762\\u4e00\\u89d2.jpg\"], \"text\": [\"\\u684c\\u9762\\u4e00\\u89d2\"], \"type\": [\"image\"]}}, {\"date\": \"2021-08\", \"arr\": {\"year\": 2021, \"month\": 8, \"link\": [\"2021-08-07_\\u5411\\u5f80\\u7684\\u751f\\u6d3b.jpg\", \"2021-08-14_\\u590f\\u65e5\\u5feb\\u4e50.jpg\", \"2021-08-14_\\u5b9a\\u5236\\u76f8\\u518c.jpg\"], \"text\": [\"\\u5411\\u5f80\\u7684\\u751f\\u6d3b\", \"\\u590f\\u65e5\\u5feb\\u4e50\", \"\\u5b9a\\u5236\\u76f8\\u518c\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2021-07\", \"arr\": {\"year\": 2021, \"month\": 7, \"link\": [\"2021-07-17_\\u5c0f\\u5e78\\u798f.jpg\", \"2021-07-17_\\u8fdc\\u65b9\\u4e0d\\u8fdc.jpg\"], \"text\": [\"\\u5c0f\\u5e78\\u798f\", \"\\u8fdc\\u65b9\\u4e0d\\u8fdc\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2021-06\", \"arr\": {\"year\": 2021, \"month\": 6, \"link\": [\"2021-06-08_\\u4fe1.jpg\", \"2021-06-17_\\u6708\\u5b63\\u82b1\\u5f00.jpg\", \"2021-06-19_\\u6bd5\\u4e1a\\u5b63.jpg\"], \"text\": [\"\\u4fe1\", \"\\u6708\\u5b63\\u82b1\\u5f00\", \"\\u6bd5\\u4e1a\\u5b63\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2021-05\", \"arr\": {\"year\": 2021, \"month\": 5, \"link\": [\"2021-05-22_\\u6ef4\\u6ef4.jpg\", \"2021-05-30_\\u604b\\u7231\\u4e86.jpg\"], \"text\": [\"\\u6ef4\\u6ef4\", \"\\u604b\\u7231\\u4e86\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2021-04\", \"arr\": {\"year\": 2021, \"month\": 4, \"link\": [\"2021-04-14_\\u6a31\\u82b1\\u81ea\\u7531.jpg\", \"2021-04-18_\\u7389\\u5170\\u82b1\\u5f00.jpg\", \"2021-04-18_\\u843d\\u65e5\\u6d12\\u5728\\u8138\\u4e0a.jpg\"], \"text\": [\"\\u6a31\\u82b1\\u81ea\\u7531\", \"\\u7389\\u5170\\u82b1\\u5f00\", \"\\u843d\\u65e5\\u6d12\\u5728\\u8138\\u4e0a\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2021-02\", \"arr\": {\"year\": 2021, \"month\": 2, \"link\": [\"2021-02-09_\\u661f\\u6d77\\u5e7f\\u573a.jpg\"], \"text\": [\"\\u661f\\u6d77\\u5e7f\\u573a\"], \"type\": [\"image\"]}}, {\"date\": \"2020-12\", \"arr\": {\"year\": 2020, \"month\": 12, \"link\": [\"2020-12-02_\\u70e4\\u51b7\\u9762\\u771f\\u9999.jpg\", \"2020-12-14_\\u6821\\u56ed\\u51ac\\u666f.jpg\", \"2020-12-15_\\u77e9\\u9635\\u7ed3\\u8bfe.jpg\"], \"text\": [\"\\u70e4\\u51b7\\u9762\\u771f\\u9999\", \"\\u6821\\u56ed\\u51ac\\u666f\", \"\\u77e9\\u9635\\u7ed3\\u8bfe\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2020-11\", \"arr\": {\"year\": 2020, \"month\": 11, \"link\": [\"2020-11-02_\\u60f3\\u8d77\\u5c0f\\u65f6\\u5019.jpg\"], \"text\": [\"\\u60f3\\u8d77\\u5c0f\\u65f6\\u5019\"], \"type\": [\"image\"]}}, {\"date\": \"2020-10\", \"arr\": {\"year\": 2020, \"month\": 10, \"link\": [\"2020-10-15_\\u846b\\u82a6\\u5a03.jpg\", \"2020-10-24_\\u4e00\\u4e2a\\u4eba\\u4e5f\\u8981\\u8fc7\\u751f\\u65e5.jpg\"], \"text\": [\"\\u846b\\u82a6\\u5a03\", \"\\u4e00\\u4e2a\\u4eba\\u4e5f\\u8981\\u8fc7\\u751f\\u65e5\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2020-08\", \"arr\": {\"year\": 2020, \"month\": 8, \"link\": [\"2020-08-12_\\u901a\\u77e5\\u4e66\\u6765\\u5566.jpg\", \"2020-08-30_\\u5c0f\\u65c5\\u9986.jpg\"], \"text\": [\"\\u901a\\u77e5\\u4e66\\u6765\\u5566\", \"\\u5c0f\\u65c5\\u9986\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2020-06\", \"arr\": {\"year\": 2020, \"month\": 6, \"link\": [\"2020-06-02_\\u7389\\u6cc9\\u9662\\u4e4c\\u9f9f.jpg\", \"2020-06-05_\\u592a\\u767d\\u5c71\\u6211\\u4eec\\u4ee8.jpg\", \"2020-06-05_\\u6708\\u4eae\\u51fa\\u6765\\u4e86.jpg\", \"2020-06-06_\\u592a\\u767d\\u5c71\\u65e5\\u843d.jpg\", \"2020-06-14_\\u6d50\\u705e\\u516c\\u56ed\\u7684\\u9e2d\\u5b50.jpg\", \"2020-06-25_\\u81ea\\u9a7e\\u6e38\\u5c31\\u662f\\u723d.jpg\"], \"text\": [\"\\u7389\\u6cc9\\u9662\\u4e4c\\u9f9f\", \"\\u592a\\u767d\\u5c71\\u6211\\u4eec\\u4ee8\", \"\\u6708\\u4eae\\u51fa\\u6765\\u4e86\", \"\\u592a\\u767d\\u5c71\\u65e5\\u843d\", \"\\u6d50\\u705e\\u516c\\u56ed\\u7684\\u9e2d\\u5b50\", \"\\u81ea\\u9a7e\\u6e38\\u5c31\\u662f\\u723d\"], \"type\": [\"image\", \"image\", \"image\", \"image\", \"image\", \"image\"]}}, {\"date\": \"2020-05\", \"arr\": {\"year\": 2020, \"month\": 5, \"link\": [\"2020-05-02_\\u66f2\\u6c5f\\u591c\\u666f.jpg\"], \"text\": [\"\\u66f2\\u6c5f\\u591c\\u666f\"], \"type\": [\"image\"]}}, {\"date\": \"2020-04\", \"arr\": {\"year\": 2020, \"month\": 4, \"link\": [\"2020-04-08_DIY\\u8d34\\u7eb8.jpg\"], \"text\": [\"DIY\\u8d34\\u7eb8\"], \"type\": [\"image\"]}}, {\"date\": \"2020-02\", \"arr\": {\"year\": 2020, \"month\": 2, \"link\": [\"2020-02-08_\\u8001\\u5bb6\\u70df\\u82b1.jpg\"], \"text\": [\"\\u8001\\u5bb6\\u70df\\u82b1\"], \"type\": [\"image\"]}}, {\"date\": \"2019-09\", \"arr\": {\"year\": 2019, \"month\": 9, \"link\": [\"2019-09-08_\\u56fe\\u4e66\\u9986\\u7684\\u8def\\u706f.jpg\"], \"text\": [\"\\u56fe\\u4e66\\u9986\\u7684\\u8def\\u706f\"], \"type\": [\"image\"]}}, {\"date\": \"2019-08\", \"arr\": {\"year\": 2019, \"month\": 8, \"link\": [\"2019-08-27_\\u72ec\\u4e00\\u4efd\\u8377\\u82b1.jpg\"], \"text\": [\"\\u72ec\\u4e00\\u4efd\\u8377\\u82b1\"], \"type\": [\"image\"]}}, {\"date\": \"2019-06\", \"arr\": {\"year\": 2019, \"month\": 6, \"link\": [\"2019-06-01_\\u54c6\\u5566A\\u68a6.jpg\"], \"text\": [\"\\u54c6\\u5566A\\u68a6\"], \"type\": [\"image\"]}}, {\"date\": \"2019-05\", \"arr\": {\"year\": 2019, \"month\": 5, \"link\": [\"2019-05-17_\\u5c0f\\u5c0f\\u8717\\u725b.jpg\"], \"text\": [\"\\u5c0f\\u5c0f\\u8717\\u725b\"], \"type\": [\"image\"]}}, {\"date\": \"2019-03\", \"arr\": {\"year\": 2019, \"month\": 3, \"link\": [\"2019-03-17_\\u9752\\u9f99\\u5bfa\\u7684\\u6a31\\u82b1.jpg\", \"2019-03-24_\\u79e6\\u5cad\\u8e0f\\u9752.jpg\"], \"text\": [\"\\u9752\\u9f99\\u5bfa\\u7684\\u6a31\\u82b1\", \"\\u79e6\\u5cad\\u8e0f\\u9752\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2018-09\", \"arr\": {\"year\": 2018, \"month\": 9, \"link\": [\"2018-09-19_\\u957f\\u6c99\\u81ed\\u8c46\\u8150.jpg\"], \"text\": [\"\\u957f\\u6c99\\u81ed\\u8c46\\u8150\"], \"type\": [\"image\"]}}, {\"date\": \"2018-07\", \"arr\": {\"year\": 2018, \"month\": 7, \"link\": [\"2018-07-10_\\u8de8\\u8003ing.jpg\"], \"text\": [\"\\u8de8\\u8003ing\"], \"type\": [\"image\"]}}, {\"date\": \"2018-06\", \"arr\": {\"year\": 2018, \"month\": 6, \"link\": [\"2018-06-06_\\u5907\\u6218\\u89c2\\u6469\\u4f1a.jpg\", \"2018-06-06_\\u89c2\\u6469\\u4f1a.jpg\"], \"text\": [\"\\u5907\\u6218\\u89c2\\u6469\\u4f1a\", \"\\u89c2\\u6469\\u4f1a\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2018-05\", \"arr\": {\"year\": 2018, \"month\": 5, \"link\": [\"2018-05-03_\\u8d85\\u591a\\u9c7c.jpg\"], \"text\": [\"\\u8d85\\u591a\\u9c7c\"], \"type\": [\"image\"]}}, {\"date\": \"2018-04\", \"arr\": {\"year\": 2018, \"month\": 4, \"link\": [\"2018-04-01_\\u5357\\u6e56\\u516c\\u56ed.jpg\", \"2018-04-05_\\u5df4\\u9002\\u4e0b\\u5348\\u8336.jpg\", \"2018-04-05_\\u8336\\u5ba4\\u4e00\\u89d2.jpg\", \"2018-04-07_\\u6b22\\u4e50\\u8c37.jpg\"], \"text\": [\"\\u5357\\u6e56\\u516c\\u56ed\", \"\\u5df4\\u9002\\u4e0b\\u5348\\u8336\", \"\\u8336\\u5ba4\\u4e00\\u89d2\", \"\\u6b22\\u4e50\\u8c37\"], \"type\": [\"image\", \"image\", \"image\", \"image\"]}}, {\"date\": \"2018-01\", \"arr\": {\"year\": 2018, \"month\": 1, \"link\": [\"2018-01-21_\\u6cf8\\u6cbd\\u6e56.jpg\"], \"text\": [\"\\u6cf8\\u6cbd\\u6e56\"], \"type\": [\"image\"]}}, {\"date\": \"2017-12\", \"arr\": {\"year\": 2017, \"month\": 12, \"link\": [\"2017-12-09_\\u590d\\u53e4\\u4e66\\u5e97\\u7684\\u94a8\\u4e1d\\u706f.jpg\", \"2017-12-14_\\u8d85\\u840c\\u7684\\u72d7\\u72d7.jpg\"], \"text\": [\"\\u590d\\u53e4\\u4e66\\u5e97\\u7684\\u94a8\\u4e1d\\u706f\", \"\\u8d85\\u840c\\u7684\\u72d7\\u72d7\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2017-09\", \"arr\": {\"year\": 2017, \"month\": 9, \"link\": [\"2017-09-03_\\u5ddd\\u5927\\u7684\\u732b.jpg\", \"2017-09-09_\\u6625\\u7199\\u8defIFS.jpg\"], \"text\": [\"\\u5ddd\\u5927\\u7684\\u732b\", \"\\u6625\\u7199\\u8defIFS\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2017-07\", \"arr\": {\"year\": 2017, \"month\": 7, \"link\": [\"2017-07-16_\\u6a58\\u5b50\\u6d32\\u5934.jpg\", \"2017-07-16_\\u957f\\u6c99\\u5c0f\\u9f99\\u867e.jpg\"], \"text\": [\"\\u6a58\\u5b50\\u6d32\\u5934\", \"\\u957f\\u6c99\\u5c0f\\u9f99\\u867e\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2017-06\", \"arr\": {\"year\": 2017, \"month\": 6, \"link\": [\"2017-06-01_\\u6bd5\\u4e1a\\u5b63.jpg\", \"2017-06-22_\\u6bd5\\u4e1a\\u5178\\u793c.jpg\"], \"text\": [\"\\u6bd5\\u4e1a\\u5b63\", \"\\u6bd5\\u4e1a\\u5178\\u793c\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2017-04\", \"arr\": {\"year\": 2017, \"month\": 4, \"link\": [\"2017-04-09_\\u94f6\\u5ddd\\u6e7f\\u5730\\u516c\\u56ed.jpg\"], \"text\": [\"\\u94f6\\u5ddd\\u6e7f\\u5730\\u516c\\u56ed\"], \"type\": [\"image\"]}}]}","source":"photos/data.json","raw":"{\"list\": [{\"date\": \"2022-08\", \"arr\": {\"year\": 2022, \"month\": 8, \"link\": [\"2022-08-01_\\u548c\\u4f60\\u4e00\\u8d77.jpg\", \"2022-08-02_\\u53e4\\u89c2\\u97f3\\u7985\\u5bfa.jpg\"], \"text\": [\"\\u548c\\u4f60\\u4e00\\u8d77\", \"\\u53e4\\u89c2\\u97f3\\u7985\\u5bfa\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2022-07\", \"arr\": {\"year\": 2022, \"month\": 7, \"link\": [\"2022-07-28_\\u949f\\u697c.jpg\", \"2022-07-31_\\u4e00\\u8d77\\u8d70\\u591c\\u8def.jpg\", \"2022-07-31_\\u5927\\u96c1\\u5854.jpg\"], \"text\": [\"\\u949f\\u697c\", \"\\u4e00\\u8d77\\u8d70\\u591c\\u8def\", \"\\u5927\\u96c1\\u5854\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2022-06\", \"arr\": {\"year\": 2022, \"month\": 6, \"link\": [\"2022-06-15_\\u5f00\\u53d1\\u533a\\u8f7b\\u8f68.jpg\", \"2022-06-30_\\u51b0\\u723d\\u6c14\\u6ce1\\u6c34.jpg\"], \"text\": [\"\\u5f00\\u53d1\\u533a\\u8f7b\\u8f68\", \"\\u51b0\\u723d\\u6c14\\u6ce1\\u6c34\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2022-05\", \"arr\": {\"year\": 2022, \"month\": 5, \"link\": [\"2022-05-20_\\u5c0f\\u60ca\\u559c.jpg\"], \"text\": [\"\\u5c0f\\u60ca\\u559c\"], \"type\": [\"image\"]}}, {\"date\": \"2022-02\", \"arr\": {\"year\": 2022, \"month\": 2, \"link\": [\"2022-02-02_\\u864e\\u864e\\u864e.jpg\", \"2022-02-02_\\u9655\\u5317\\u7a97\\u82b1.jpg\", \"2022-02-05_\\u5e74\\u591c\\u996d.jpg\", \"2022-02-14_\\u7b2c\\u4e00\\u4e2a\\u60c5\\u4eba\\u8282.jpg\"], \"text\": [\"\\u864e\\u864e\\u864e\", \"\\u9655\\u5317\\u7a97\\u82b1\", \"\\u5e74\\u591c\\u996d\", \"\\u7b2c\\u4e00\\u4e2a\\u60c5\\u4eba\\u8282\"], \"type\": [\"image\", \"image\", \"image\", \"image\"]}}, {\"date\": \"2021-10\", \"arr\": {\"year\": 2021, \"month\": 10, \"link\": [\"2021-10-01_\\u6e05\\u8377.jpg\", \"2021-10-24_\\u751f\\u65e5\\u4e0d\\u5b64\\u5355.jpg\", \"2021-10-29_\\u79cb.jpg\"], \"text\": [\"\\u6e05\\u8377\", \"\\u751f\\u65e5\\u4e0d\\u5b64\\u5355\", \"\\u79cb\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2021-09\", \"arr\": {\"year\": 2021, \"month\": 9, \"link\": [\"2021-09-22_\\u684c\\u9762\\u4e00\\u89d2.jpg\"], \"text\": [\"\\u684c\\u9762\\u4e00\\u89d2\"], \"type\": [\"image\"]}}, {\"date\": \"2021-08\", \"arr\": {\"year\": 2021, \"month\": 8, \"link\": [\"2021-08-07_\\u5411\\u5f80\\u7684\\u751f\\u6d3b.jpg\", \"2021-08-14_\\u590f\\u65e5\\u5feb\\u4e50.jpg\", \"2021-08-14_\\u5b9a\\u5236\\u76f8\\u518c.jpg\"], \"text\": [\"\\u5411\\u5f80\\u7684\\u751f\\u6d3b\", \"\\u590f\\u65e5\\u5feb\\u4e50\", \"\\u5b9a\\u5236\\u76f8\\u518c\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2021-07\", \"arr\": {\"year\": 2021, \"month\": 7, \"link\": [\"2021-07-17_\\u5c0f\\u5e78\\u798f.jpg\", \"2021-07-17_\\u8fdc\\u65b9\\u4e0d\\u8fdc.jpg\"], \"text\": [\"\\u5c0f\\u5e78\\u798f\", \"\\u8fdc\\u65b9\\u4e0d\\u8fdc\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2021-06\", \"arr\": {\"year\": 2021, \"month\": 6, \"link\": [\"2021-06-08_\\u4fe1.jpg\", \"2021-06-17_\\u6708\\u5b63\\u82b1\\u5f00.jpg\", \"2021-06-19_\\u6bd5\\u4e1a\\u5b63.jpg\"], \"text\": [\"\\u4fe1\", \"\\u6708\\u5b63\\u82b1\\u5f00\", \"\\u6bd5\\u4e1a\\u5b63\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2021-05\", \"arr\": {\"year\": 2021, \"month\": 5, \"link\": [\"2021-05-22_\\u6ef4\\u6ef4.jpg\", \"2021-05-30_\\u604b\\u7231\\u4e86.jpg\"], \"text\": [\"\\u6ef4\\u6ef4\", \"\\u604b\\u7231\\u4e86\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2021-04\", \"arr\": {\"year\": 2021, \"month\": 4, \"link\": [\"2021-04-14_\\u6a31\\u82b1\\u81ea\\u7531.jpg\", \"2021-04-18_\\u7389\\u5170\\u82b1\\u5f00.jpg\", \"2021-04-18_\\u843d\\u65e5\\u6d12\\u5728\\u8138\\u4e0a.jpg\"], \"text\": [\"\\u6a31\\u82b1\\u81ea\\u7531\", \"\\u7389\\u5170\\u82b1\\u5f00\", \"\\u843d\\u65e5\\u6d12\\u5728\\u8138\\u4e0a\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2021-02\", \"arr\": {\"year\": 2021, \"month\": 2, \"link\": [\"2021-02-09_\\u661f\\u6d77\\u5e7f\\u573a.jpg\"], \"text\": [\"\\u661f\\u6d77\\u5e7f\\u573a\"], \"type\": [\"image\"]}}, {\"date\": \"2020-12\", \"arr\": {\"year\": 2020, \"month\": 12, \"link\": [\"2020-12-02_\\u70e4\\u51b7\\u9762\\u771f\\u9999.jpg\", \"2020-12-14_\\u6821\\u56ed\\u51ac\\u666f.jpg\", \"2020-12-15_\\u77e9\\u9635\\u7ed3\\u8bfe.jpg\"], \"text\": [\"\\u70e4\\u51b7\\u9762\\u771f\\u9999\", \"\\u6821\\u56ed\\u51ac\\u666f\", \"\\u77e9\\u9635\\u7ed3\\u8bfe\"], \"type\": [\"image\", \"image\", \"image\"]}}, {\"date\": \"2020-11\", \"arr\": {\"year\": 2020, \"month\": 11, \"link\": [\"2020-11-02_\\u60f3\\u8d77\\u5c0f\\u65f6\\u5019.jpg\"], \"text\": [\"\\u60f3\\u8d77\\u5c0f\\u65f6\\u5019\"], \"type\": [\"image\"]}}, {\"date\": \"2020-10\", \"arr\": {\"year\": 2020, \"month\": 10, \"link\": [\"2020-10-15_\\u846b\\u82a6\\u5a03.jpg\", \"2020-10-24_\\u4e00\\u4e2a\\u4eba\\u4e5f\\u8981\\u8fc7\\u751f\\u65e5.jpg\"], \"text\": [\"\\u846b\\u82a6\\u5a03\", \"\\u4e00\\u4e2a\\u4eba\\u4e5f\\u8981\\u8fc7\\u751f\\u65e5\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2020-08\", \"arr\": {\"year\": 2020, \"month\": 8, \"link\": [\"2020-08-12_\\u901a\\u77e5\\u4e66\\u6765\\u5566.jpg\", \"2020-08-30_\\u5c0f\\u65c5\\u9986.jpg\"], \"text\": [\"\\u901a\\u77e5\\u4e66\\u6765\\u5566\", \"\\u5c0f\\u65c5\\u9986\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2020-06\", \"arr\": {\"year\": 2020, \"month\": 6, \"link\": [\"2020-06-02_\\u7389\\u6cc9\\u9662\\u4e4c\\u9f9f.jpg\", \"2020-06-05_\\u592a\\u767d\\u5c71\\u6211\\u4eec\\u4ee8.jpg\", \"2020-06-05_\\u6708\\u4eae\\u51fa\\u6765\\u4e86.jpg\", \"2020-06-06_\\u592a\\u767d\\u5c71\\u65e5\\u843d.jpg\", \"2020-06-14_\\u6d50\\u705e\\u516c\\u56ed\\u7684\\u9e2d\\u5b50.jpg\", \"2020-06-25_\\u81ea\\u9a7e\\u6e38\\u5c31\\u662f\\u723d.jpg\"], \"text\": [\"\\u7389\\u6cc9\\u9662\\u4e4c\\u9f9f\", \"\\u592a\\u767d\\u5c71\\u6211\\u4eec\\u4ee8\", \"\\u6708\\u4eae\\u51fa\\u6765\\u4e86\", \"\\u592a\\u767d\\u5c71\\u65e5\\u843d\", \"\\u6d50\\u705e\\u516c\\u56ed\\u7684\\u9e2d\\u5b50\", \"\\u81ea\\u9a7e\\u6e38\\u5c31\\u662f\\u723d\"], \"type\": [\"image\", \"image\", \"image\", \"image\", \"image\", \"image\"]}}, {\"date\": \"2020-05\", \"arr\": {\"year\": 2020, \"month\": 5, \"link\": [\"2020-05-02_\\u66f2\\u6c5f\\u591c\\u666f.jpg\"], \"text\": [\"\\u66f2\\u6c5f\\u591c\\u666f\"], \"type\": [\"image\"]}}, {\"date\": \"2020-04\", \"arr\": {\"year\": 2020, \"month\": 4, \"link\": [\"2020-04-08_DIY\\u8d34\\u7eb8.jpg\"], \"text\": [\"DIY\\u8d34\\u7eb8\"], \"type\": [\"image\"]}}, {\"date\": \"2020-02\", \"arr\": {\"year\": 2020, \"month\": 2, \"link\": [\"2020-02-08_\\u8001\\u5bb6\\u70df\\u82b1.jpg\"], \"text\": [\"\\u8001\\u5bb6\\u70df\\u82b1\"], \"type\": [\"image\"]}}, {\"date\": \"2019-09\", \"arr\": {\"year\": 2019, \"month\": 9, \"link\": [\"2019-09-08_\\u56fe\\u4e66\\u9986\\u7684\\u8def\\u706f.jpg\"], \"text\": [\"\\u56fe\\u4e66\\u9986\\u7684\\u8def\\u706f\"], \"type\": [\"image\"]}}, {\"date\": \"2019-08\", \"arr\": {\"year\": 2019, \"month\": 8, \"link\": [\"2019-08-27_\\u72ec\\u4e00\\u4efd\\u8377\\u82b1.jpg\"], \"text\": [\"\\u72ec\\u4e00\\u4efd\\u8377\\u82b1\"], \"type\": [\"image\"]}}, {\"date\": \"2019-06\", \"arr\": {\"year\": 2019, \"month\": 6, \"link\": [\"2019-06-01_\\u54c6\\u5566A\\u68a6.jpg\"], \"text\": [\"\\u54c6\\u5566A\\u68a6\"], \"type\": [\"image\"]}}, {\"date\": \"2019-05\", \"arr\": {\"year\": 2019, \"month\": 5, \"link\": [\"2019-05-17_\\u5c0f\\u5c0f\\u8717\\u725b.jpg\"], \"text\": [\"\\u5c0f\\u5c0f\\u8717\\u725b\"], \"type\": [\"image\"]}}, {\"date\": \"2019-03\", \"arr\": {\"year\": 2019, \"month\": 3, \"link\": [\"2019-03-17_\\u9752\\u9f99\\u5bfa\\u7684\\u6a31\\u82b1.jpg\", \"2019-03-24_\\u79e6\\u5cad\\u8e0f\\u9752.jpg\"], \"text\": [\"\\u9752\\u9f99\\u5bfa\\u7684\\u6a31\\u82b1\", \"\\u79e6\\u5cad\\u8e0f\\u9752\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2018-09\", \"arr\": {\"year\": 2018, \"month\": 9, \"link\": [\"2018-09-19_\\u957f\\u6c99\\u81ed\\u8c46\\u8150.jpg\"], \"text\": [\"\\u957f\\u6c99\\u81ed\\u8c46\\u8150\"], \"type\": [\"image\"]}}, {\"date\": \"2018-07\", \"arr\": {\"year\": 2018, \"month\": 7, \"link\": [\"2018-07-10_\\u8de8\\u8003ing.jpg\"], \"text\": [\"\\u8de8\\u8003ing\"], \"type\": [\"image\"]}}, {\"date\": \"2018-06\", \"arr\": {\"year\": 2018, \"month\": 6, \"link\": [\"2018-06-06_\\u5907\\u6218\\u89c2\\u6469\\u4f1a.jpg\", \"2018-06-06_\\u89c2\\u6469\\u4f1a.jpg\"], \"text\": [\"\\u5907\\u6218\\u89c2\\u6469\\u4f1a\", \"\\u89c2\\u6469\\u4f1a\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2018-05\", \"arr\": {\"year\": 2018, \"month\": 5, \"link\": [\"2018-05-03_\\u8d85\\u591a\\u9c7c.jpg\"], \"text\": [\"\\u8d85\\u591a\\u9c7c\"], \"type\": [\"image\"]}}, {\"date\": \"2018-04\", \"arr\": {\"year\": 2018, \"month\": 4, \"link\": [\"2018-04-01_\\u5357\\u6e56\\u516c\\u56ed.jpg\", \"2018-04-05_\\u5df4\\u9002\\u4e0b\\u5348\\u8336.jpg\", \"2018-04-05_\\u8336\\u5ba4\\u4e00\\u89d2.jpg\", \"2018-04-07_\\u6b22\\u4e50\\u8c37.jpg\"], \"text\": [\"\\u5357\\u6e56\\u516c\\u56ed\", \"\\u5df4\\u9002\\u4e0b\\u5348\\u8336\", \"\\u8336\\u5ba4\\u4e00\\u89d2\", \"\\u6b22\\u4e50\\u8c37\"], \"type\": [\"image\", \"image\", \"image\", \"image\"]}}, {\"date\": \"2018-01\", \"arr\": {\"year\": 2018, \"month\": 1, \"link\": [\"2018-01-21_\\u6cf8\\u6cbd\\u6e56.jpg\"], \"text\": [\"\\u6cf8\\u6cbd\\u6e56\"], \"type\": [\"image\"]}}, {\"date\": \"2017-12\", \"arr\": {\"year\": 2017, \"month\": 12, \"link\": [\"2017-12-09_\\u590d\\u53e4\\u4e66\\u5e97\\u7684\\u94a8\\u4e1d\\u706f.jpg\", \"2017-12-14_\\u8d85\\u840c\\u7684\\u72d7\\u72d7.jpg\"], \"text\": [\"\\u590d\\u53e4\\u4e66\\u5e97\\u7684\\u94a8\\u4e1d\\u706f\", \"\\u8d85\\u840c\\u7684\\u72d7\\u72d7\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2017-09\", \"arr\": {\"year\": 2017, \"month\": 9, \"link\": [\"2017-09-03_\\u5ddd\\u5927\\u7684\\u732b.jpg\", \"2017-09-09_\\u6625\\u7199\\u8defIFS.jpg\"], \"text\": [\"\\u5ddd\\u5927\\u7684\\u732b\", \"\\u6625\\u7199\\u8defIFS\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2017-07\", \"arr\": {\"year\": 2017, \"month\": 7, \"link\": [\"2017-07-16_\\u6a58\\u5b50\\u6d32\\u5934.jpg\", \"2017-07-16_\\u957f\\u6c99\\u5c0f\\u9f99\\u867e.jpg\"], \"text\": [\"\\u6a58\\u5b50\\u6d32\\u5934\", \"\\u957f\\u6c99\\u5c0f\\u9f99\\u867e\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2017-06\", \"arr\": {\"year\": 2017, \"month\": 6, \"link\": [\"2017-06-01_\\u6bd5\\u4e1a\\u5b63.jpg\", \"2017-06-22_\\u6bd5\\u4e1a\\u5178\\u793c.jpg\"], \"text\": [\"\\u6bd5\\u4e1a\\u5b63\", \"\\u6bd5\\u4e1a\\u5178\\u793c\"], \"type\": [\"image\", \"image\"]}}, {\"date\": \"2017-04\", \"arr\": {\"year\": 2017, \"month\": 4, \"link\": [\"2017-04-09_\\u94f6\\u5ddd\\u6e7f\\u5730\\u516c\\u56ed.jpg\"], \"text\": [\"\\u94f6\\u5ddd\\u6e7f\\u5730\\u516c\\u56ed\"], \"type\": [\"image\"]}}]}","date":"2022-11-25T05:14:42.833Z","updated":"2022-08-20T17:46:04.602Z","path":"photos/data.json","layout":"false","title":"","comments":1,"_id":"clb218l41000564rg9z256v4y","content":"{\"list\":[{\"date\":\"2022-08\",\"arr\":{\"year\":2022,\"month\":8,\"link\":[\"2022-08-01_和你一起.jpg\",\"2022-08-02_古观音禅寺.jpg\"],\"text\":[\"和你一起\",\"古观音禅寺\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2022-07\",\"arr\":{\"year\":2022,\"month\":7,\"link\":[\"2022-07-28_钟楼.jpg\",\"2022-07-31_一起走夜路.jpg\",\"2022-07-31_大雁塔.jpg\"],\"text\":[\"钟楼\",\"一起走夜路\",\"大雁塔\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2022-06\",\"arr\":{\"year\":2022,\"month\":6,\"link\":[\"2022-06-15_开发区轻轨.jpg\",\"2022-06-30_冰爽气泡水.jpg\"],\"text\":[\"开发区轻轨\",\"冰爽气泡水\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2022-05\",\"arr\":{\"year\":2022,\"month\":5,\"link\":[\"2022-05-20_小惊喜.jpg\"],\"text\":[\"小惊喜\"],\"type\":[\"image\"]}},{\"date\":\"2022-02\",\"arr\":{\"year\":2022,\"month\":2,\"link\":[\"2022-02-02_虎虎虎.jpg\",\"2022-02-02_陕北窗花.jpg\",\"2022-02-05_年夜饭.jpg\",\"2022-02-14_第一个情人节.jpg\"],\"text\":[\"虎虎虎\",\"陕北窗花\",\"年夜饭\",\"第一个情人节\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2021-10\",\"arr\":{\"year\":2021,\"month\":10,\"link\":[\"2021-10-01_清荷.jpg\",\"2021-10-24_生日不孤单.jpg\",\"2021-10-29_秋.jpg\"],\"text\":[\"清荷\",\"生日不孤单\",\"秋\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2021-09\",\"arr\":{\"year\":2021,\"month\":9,\"link\":[\"2021-09-22_桌面一角.jpg\"],\"text\":[\"桌面一角\"],\"type\":[\"image\"]}},{\"date\":\"2021-08\",\"arr\":{\"year\":2021,\"month\":8,\"link\":[\"2021-08-07_向往的生活.jpg\",\"2021-08-14_夏日快乐.jpg\",\"2021-08-14_定制相册.jpg\"],\"text\":[\"向往的生活\",\"夏日快乐\",\"定制相册\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2021-07\",\"arr\":{\"year\":2021,\"month\":7,\"link\":[\"2021-07-17_小幸福.jpg\",\"2021-07-17_远方不远.jpg\"],\"text\":[\"小幸福\",\"远方不远\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2021-06\",\"arr\":{\"year\":2021,\"month\":6,\"link\":[\"2021-06-08_信.jpg\",\"2021-06-17_月季花开.jpg\",\"2021-06-19_毕业季.jpg\"],\"text\":[\"信\",\"月季花开\",\"毕业季\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2021-05\",\"arr\":{\"year\":2021,\"month\":5,\"link\":[\"2021-05-22_滴滴.jpg\",\"2021-05-30_恋爱了.jpg\"],\"text\":[\"滴滴\",\"恋爱了\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2021-04\",\"arr\":{\"year\":2021,\"month\":4,\"link\":[\"2021-04-14_樱花自由.jpg\",\"2021-04-18_玉兰花开.jpg\",\"2021-04-18_落日洒在脸上.jpg\"],\"text\":[\"樱花自由\",\"玉兰花开\",\"落日洒在脸上\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2021-02\",\"arr\":{\"year\":2021,\"month\":2,\"link\":[\"2021-02-09_星海广场.jpg\"],\"text\":[\"星海广场\"],\"type\":[\"image\"]}},{\"date\":\"2020-12\",\"arr\":{\"year\":2020,\"month\":12,\"link\":[\"2020-12-02_烤冷面真香.jpg\",\"2020-12-14_校园冬景.jpg\",\"2020-12-15_矩阵结课.jpg\"],\"text\":[\"烤冷面真香\",\"校园冬景\",\"矩阵结课\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2020-11\",\"arr\":{\"year\":2020,\"month\":11,\"link\":[\"2020-11-02_想起小时候.jpg\"],\"text\":[\"想起小时候\"],\"type\":[\"image\"]}},{\"date\":\"2020-10\",\"arr\":{\"year\":2020,\"month\":10,\"link\":[\"2020-10-15_葫芦娃.jpg\",\"2020-10-24_一个人也要过生日.jpg\"],\"text\":[\"葫芦娃\",\"一个人也要过生日\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2020-08\",\"arr\":{\"year\":2020,\"month\":8,\"link\":[\"2020-08-12_通知书来啦.jpg\",\"2020-08-30_小旅馆.jpg\"],\"text\":[\"通知书来啦\",\"小旅馆\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2020-06\",\"arr\":{\"year\":2020,\"month\":6,\"link\":[\"2020-06-02_玉泉院乌龟.jpg\",\"2020-06-05_太白山我们仨.jpg\",\"2020-06-05_月亮出来了.jpg\",\"2020-06-06_太白山日落.jpg\",\"2020-06-14_浐灞公园的鸭子.jpg\",\"2020-06-25_自驾游就是爽.jpg\"],\"text\":[\"玉泉院乌龟\",\"太白山我们仨\",\"月亮出来了\",\"太白山日落\",\"浐灞公园的鸭子\",\"自驾游就是爽\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2020-05\",\"arr\":{\"year\":2020,\"month\":5,\"link\":[\"2020-05-02_曲江夜景.jpg\"],\"text\":[\"曲江夜景\"],\"type\":[\"image\"]}},{\"date\":\"2020-04\",\"arr\":{\"year\":2020,\"month\":4,\"link\":[\"2020-04-08_DIY贴纸.jpg\"],\"text\":[\"DIY贴纸\"],\"type\":[\"image\"]}},{\"date\":\"2020-02\",\"arr\":{\"year\":2020,\"month\":2,\"link\":[\"2020-02-08_老家烟花.jpg\"],\"text\":[\"老家烟花\"],\"type\":[\"image\"]}},{\"date\":\"2019-09\",\"arr\":{\"year\":2019,\"month\":9,\"link\":[\"2019-09-08_图书馆的路灯.jpg\"],\"text\":[\"图书馆的路灯\"],\"type\":[\"image\"]}},{\"date\":\"2019-08\",\"arr\":{\"year\":2019,\"month\":8,\"link\":[\"2019-08-27_独一份荷花.jpg\"],\"text\":[\"独一份荷花\"],\"type\":[\"image\"]}},{\"date\":\"2019-06\",\"arr\":{\"year\":2019,\"month\":6,\"link\":[\"2019-06-01_哆啦A梦.jpg\"],\"text\":[\"哆啦A梦\"],\"type\":[\"image\"]}},{\"date\":\"2019-05\",\"arr\":{\"year\":2019,\"month\":5,\"link\":[\"2019-05-17_小小蜗牛.jpg\"],\"text\":[\"小小蜗牛\"],\"type\":[\"image\"]}},{\"date\":\"2019-03\",\"arr\":{\"year\":2019,\"month\":3,\"link\":[\"2019-03-17_青龙寺的樱花.jpg\",\"2019-03-24_秦岭踏青.jpg\"],\"text\":[\"青龙寺的樱花\",\"秦岭踏青\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2018-09\",\"arr\":{\"year\":2018,\"month\":9,\"link\":[\"2018-09-19_长沙臭豆腐.jpg\"],\"text\":[\"长沙臭豆腐\"],\"type\":[\"image\"]}},{\"date\":\"2018-07\",\"arr\":{\"year\":2018,\"month\":7,\"link\":[\"2018-07-10_跨考ing.jpg\"],\"text\":[\"跨考ing\"],\"type\":[\"image\"]}},{\"date\":\"2018-06\",\"arr\":{\"year\":2018,\"month\":6,\"link\":[\"2018-06-06_备战观摩会.jpg\",\"2018-06-06_观摩会.jpg\"],\"text\":[\"备战观摩会\",\"观摩会\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2018-05\",\"arr\":{\"year\":2018,\"month\":5,\"link\":[\"2018-05-03_超多鱼.jpg\"],\"text\":[\"超多鱼\"],\"type\":[\"image\"]}},{\"date\":\"2018-04\",\"arr\":{\"year\":2018,\"month\":4,\"link\":[\"2018-04-01_南湖公园.jpg\",\"2018-04-05_巴适下午茶.jpg\",\"2018-04-05_茶室一角.jpg\",\"2018-04-07_欢乐谷.jpg\"],\"text\":[\"南湖公园\",\"巴适下午茶\",\"茶室一角\",\"欢乐谷\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2018-01\",\"arr\":{\"year\":2018,\"month\":1,\"link\":[\"2018-01-21_泸沽湖.jpg\"],\"text\":[\"泸沽湖\"],\"type\":[\"image\"]}},{\"date\":\"2017-12\",\"arr\":{\"year\":2017,\"month\":12,\"link\":[\"2017-12-09_复古书店的钨丝灯.jpg\",\"2017-12-14_超萌的狗狗.jpg\"],\"text\":[\"复古书店的钨丝灯\",\"超萌的狗狗\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2017-09\",\"arr\":{\"year\":2017,\"month\":9,\"link\":[\"2017-09-03_川大的猫.jpg\",\"2017-09-09_春熙路IFS.jpg\"],\"text\":[\"川大的猫\",\"春熙路IFS\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2017-07\",\"arr\":{\"year\":2017,\"month\":7,\"link\":[\"2017-07-16_橘子洲头.jpg\",\"2017-07-16_长沙小龙虾.jpg\"],\"text\":[\"橘子洲头\",\"长沙小龙虾\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2017-06\",\"arr\":{\"year\":2017,\"month\":6,\"link\":[\"2017-06-01_毕业季.jpg\",\"2017-06-22_毕业典礼.jpg\"],\"text\":[\"毕业季\",\"毕业典礼\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2017-04\",\"arr\":{\"year\":2017,\"month\":4,\"link\":[\"2017-04-09_银川湿地公园.jpg\"],\"text\":[\"银川湿地公园\"],\"type\":[\"image\"]}}]}","site":{"data":{}},"excerpt":"","more":"{\"list\":[{\"date\":\"2022-08\",\"arr\":{\"year\":2022,\"month\":8,\"link\":[\"2022-08-01_和你一起.jpg\",\"2022-08-02_古观音禅寺.jpg\"],\"text\":[\"和你一起\",\"古观音禅寺\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2022-07\",\"arr\":{\"year\":2022,\"month\":7,\"link\":[\"2022-07-28_钟楼.jpg\",\"2022-07-31_一起走夜路.jpg\",\"2022-07-31_大雁塔.jpg\"],\"text\":[\"钟楼\",\"一起走夜路\",\"大雁塔\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2022-06\",\"arr\":{\"year\":2022,\"month\":6,\"link\":[\"2022-06-15_开发区轻轨.jpg\",\"2022-06-30_冰爽气泡水.jpg\"],\"text\":[\"开发区轻轨\",\"冰爽气泡水\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2022-05\",\"arr\":{\"year\":2022,\"month\":5,\"link\":[\"2022-05-20_小惊喜.jpg\"],\"text\":[\"小惊喜\"],\"type\":[\"image\"]}},{\"date\":\"2022-02\",\"arr\":{\"year\":2022,\"month\":2,\"link\":[\"2022-02-02_虎虎虎.jpg\",\"2022-02-02_陕北窗花.jpg\",\"2022-02-05_年夜饭.jpg\",\"2022-02-14_第一个情人节.jpg\"],\"text\":[\"虎虎虎\",\"陕北窗花\",\"年夜饭\",\"第一个情人节\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2021-10\",\"arr\":{\"year\":2021,\"month\":10,\"link\":[\"2021-10-01_清荷.jpg\",\"2021-10-24_生日不孤单.jpg\",\"2021-10-29_秋.jpg\"],\"text\":[\"清荷\",\"生日不孤单\",\"秋\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2021-09\",\"arr\":{\"year\":2021,\"month\":9,\"link\":[\"2021-09-22_桌面一角.jpg\"],\"text\":[\"桌面一角\"],\"type\":[\"image\"]}},{\"date\":\"2021-08\",\"arr\":{\"year\":2021,\"month\":8,\"link\":[\"2021-08-07_向往的生活.jpg\",\"2021-08-14_夏日快乐.jpg\",\"2021-08-14_定制相册.jpg\"],\"text\":[\"向往的生活\",\"夏日快乐\",\"定制相册\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2021-07\",\"arr\":{\"year\":2021,\"month\":7,\"link\":[\"2021-07-17_小幸福.jpg\",\"2021-07-17_远方不远.jpg\"],\"text\":[\"小幸福\",\"远方不远\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2021-06\",\"arr\":{\"year\":2021,\"month\":6,\"link\":[\"2021-06-08_信.jpg\",\"2021-06-17_月季花开.jpg\",\"2021-06-19_毕业季.jpg\"],\"text\":[\"信\",\"月季花开\",\"毕业季\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2021-05\",\"arr\":{\"year\":2021,\"month\":5,\"link\":[\"2021-05-22_滴滴.jpg\",\"2021-05-30_恋爱了.jpg\"],\"text\":[\"滴滴\",\"恋爱了\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2021-04\",\"arr\":{\"year\":2021,\"month\":4,\"link\":[\"2021-04-14_樱花自由.jpg\",\"2021-04-18_玉兰花开.jpg\",\"2021-04-18_落日洒在脸上.jpg\"],\"text\":[\"樱花自由\",\"玉兰花开\",\"落日洒在脸上\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2021-02\",\"arr\":{\"year\":2021,\"month\":2,\"link\":[\"2021-02-09_星海广场.jpg\"],\"text\":[\"星海广场\"],\"type\":[\"image\"]}},{\"date\":\"2020-12\",\"arr\":{\"year\":2020,\"month\":12,\"link\":[\"2020-12-02_烤冷面真香.jpg\",\"2020-12-14_校园冬景.jpg\",\"2020-12-15_矩阵结课.jpg\"],\"text\":[\"烤冷面真香\",\"校园冬景\",\"矩阵结课\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2020-11\",\"arr\":{\"year\":2020,\"month\":11,\"link\":[\"2020-11-02_想起小时候.jpg\"],\"text\":[\"想起小时候\"],\"type\":[\"image\"]}},{\"date\":\"2020-10\",\"arr\":{\"year\":2020,\"month\":10,\"link\":[\"2020-10-15_葫芦娃.jpg\",\"2020-10-24_一个人也要过生日.jpg\"],\"text\":[\"葫芦娃\",\"一个人也要过生日\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2020-08\",\"arr\":{\"year\":2020,\"month\":8,\"link\":[\"2020-08-12_通知书来啦.jpg\",\"2020-08-30_小旅馆.jpg\"],\"text\":[\"通知书来啦\",\"小旅馆\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2020-06\",\"arr\":{\"year\":2020,\"month\":6,\"link\":[\"2020-06-02_玉泉院乌龟.jpg\",\"2020-06-05_太白山我们仨.jpg\",\"2020-06-05_月亮出来了.jpg\",\"2020-06-06_太白山日落.jpg\",\"2020-06-14_浐灞公园的鸭子.jpg\",\"2020-06-25_自驾游就是爽.jpg\"],\"text\":[\"玉泉院乌龟\",\"太白山我们仨\",\"月亮出来了\",\"太白山日落\",\"浐灞公园的鸭子\",\"自驾游就是爽\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2020-05\",\"arr\":{\"year\":2020,\"month\":5,\"link\":[\"2020-05-02_曲江夜景.jpg\"],\"text\":[\"曲江夜景\"],\"type\":[\"image\"]}},{\"date\":\"2020-04\",\"arr\":{\"year\":2020,\"month\":4,\"link\":[\"2020-04-08_DIY贴纸.jpg\"],\"text\":[\"DIY贴纸\"],\"type\":[\"image\"]}},{\"date\":\"2020-02\",\"arr\":{\"year\":2020,\"month\":2,\"link\":[\"2020-02-08_老家烟花.jpg\"],\"text\":[\"老家烟花\"],\"type\":[\"image\"]}},{\"date\":\"2019-09\",\"arr\":{\"year\":2019,\"month\":9,\"link\":[\"2019-09-08_图书馆的路灯.jpg\"],\"text\":[\"图书馆的路灯\"],\"type\":[\"image\"]}},{\"date\":\"2019-08\",\"arr\":{\"year\":2019,\"month\":8,\"link\":[\"2019-08-27_独一份荷花.jpg\"],\"text\":[\"独一份荷花\"],\"type\":[\"image\"]}},{\"date\":\"2019-06\",\"arr\":{\"year\":2019,\"month\":6,\"link\":[\"2019-06-01_哆啦A梦.jpg\"],\"text\":[\"哆啦A梦\"],\"type\":[\"image\"]}},{\"date\":\"2019-05\",\"arr\":{\"year\":2019,\"month\":5,\"link\":[\"2019-05-17_小小蜗牛.jpg\"],\"text\":[\"小小蜗牛\"],\"type\":[\"image\"]}},{\"date\":\"2019-03\",\"arr\":{\"year\":2019,\"month\":3,\"link\":[\"2019-03-17_青龙寺的樱花.jpg\",\"2019-03-24_秦岭踏青.jpg\"],\"text\":[\"青龙寺的樱花\",\"秦岭踏青\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2018-09\",\"arr\":{\"year\":2018,\"month\":9,\"link\":[\"2018-09-19_长沙臭豆腐.jpg\"],\"text\":[\"长沙臭豆腐\"],\"type\":[\"image\"]}},{\"date\":\"2018-07\",\"arr\":{\"year\":2018,\"month\":7,\"link\":[\"2018-07-10_跨考ing.jpg\"],\"text\":[\"跨考ing\"],\"type\":[\"image\"]}},{\"date\":\"2018-06\",\"arr\":{\"year\":2018,\"month\":6,\"link\":[\"2018-06-06_备战观摩会.jpg\",\"2018-06-06_观摩会.jpg\"],\"text\":[\"备战观摩会\",\"观摩会\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2018-05\",\"arr\":{\"year\":2018,\"month\":5,\"link\":[\"2018-05-03_超多鱼.jpg\"],\"text\":[\"超多鱼\"],\"type\":[\"image\"]}},{\"date\":\"2018-04\",\"arr\":{\"year\":2018,\"month\":4,\"link\":[\"2018-04-01_南湖公园.jpg\",\"2018-04-05_巴适下午茶.jpg\",\"2018-04-05_茶室一角.jpg\",\"2018-04-07_欢乐谷.jpg\"],\"text\":[\"南湖公园\",\"巴适下午茶\",\"茶室一角\",\"欢乐谷\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2018-01\",\"arr\":{\"year\":2018,\"month\":1,\"link\":[\"2018-01-21_泸沽湖.jpg\"],\"text\":[\"泸沽湖\"],\"type\":[\"image\"]}},{\"date\":\"2017-12\",\"arr\":{\"year\":2017,\"month\":12,\"link\":[\"2017-12-09_复古书店的钨丝灯.jpg\",\"2017-12-14_超萌的狗狗.jpg\"],\"text\":[\"复古书店的钨丝灯\",\"超萌的狗狗\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2017-09\",\"arr\":{\"year\":2017,\"month\":9,\"link\":[\"2017-09-03_川大的猫.jpg\",\"2017-09-09_春熙路IFS.jpg\"],\"text\":[\"川大的猫\",\"春熙路IFS\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2017-07\",\"arr\":{\"year\":2017,\"month\":7,\"link\":[\"2017-07-16_橘子洲头.jpg\",\"2017-07-16_长沙小龙虾.jpg\"],\"text\":[\"橘子洲头\",\"长沙小龙虾\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2017-06\",\"arr\":{\"year\":2017,\"month\":6,\"link\":[\"2017-06-01_毕业季.jpg\",\"2017-06-22_毕业典礼.jpg\"],\"text\":[\"毕业季\",\"毕业典礼\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2017-04\",\"arr\":{\"year\":2017,\"month\":4,\"link\":[\"2017-04-09_银川湿地公园.jpg\"],\"text\":[\"银川湿地公园\"],\"type\":[\"image\"]}}]}"},{"title":"相册","no_word_count":true,"no_toc":true,"no_date":true,"no_declare":true,"no_reward":true,"no_comments":false,"abbrlink":"876e0d9","_content":"\n<link rel=\"stylesheet\" href=\"./static/ins.css\">\n<div class=\"photos-btn-wrap\">\n\t<a class=\"photos-btn active\" href=\"/photos/index.html\">Photos</a>\n\t<a class=\"photos-btn\" href=\"/photos/video.html\">Videos</a>\n</div>\n<div class=\"instagram itemscope\">\n\t<a href=\"https://sanshui.findn.cn/photos/index.html\" target=\"_blank\" class=\"open-ins\">图片正在加载中…</a>\n</div>\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./static/ins.js')\n    }, 0)\n  })()\n</script>","source":"photos/index.ejs","raw":"---\ntitle: 相册\nno_word_count: true\nno_toc: true\nno_date: true\nno_declare: true\nno_reward: true\nno_comments: false\nabbrlink: 876e0d9\n---\n\n<link rel=\"stylesheet\" href=\"./static/ins.css\">\n<div class=\"photos-btn-wrap\">\n\t<a class=\"photos-btn active\" href=\"/photos/index.html\">Photos</a>\n\t<a class=\"photos-btn\" href=\"/photos/video.html\">Videos</a>\n</div>\n<div class=\"instagram itemscope\">\n\t<a href=\"https://sanshui.findn.cn/photos/index.html\" target=\"_blank\" class=\"open-ins\">图片正在加载中…</a>\n</div>\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./static/ins.js')\n    }, 0)\n  })()\n</script>","date":"2022-11-25T05:37:33.577Z","updated":"2022-11-25T05:37:33.577Z","path":"photos/index.html","comments":1,"layout":"page","_id":"clb218l41000664rg960ife8a","content":"\n<link rel=\"stylesheet\" href=\"./static/ins.css\">\n<div class=\"photos-btn-wrap\">\n\t<a class=\"photos-btn active\" href=\"/photos/index.html\">Photos</a>\n\t<a class=\"photos-btn\" href=\"/photos/video.html\">Videos</a>\n</div>\n<div class=\"instagram itemscope\">\n\t<a href=\"https://sanshui.findn.cn/photos/index.html\" target=\"_blank\" class=\"open-ins\">图片正在加载中…</a>\n</div>\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./static/ins.js')\n    }, 0)\n  })()\n</script>","site":{"data":{}},"excerpt":"","more":"\n<link rel=\"stylesheet\" href=\"./static/ins.css\">\n<div class=\"photos-btn-wrap\">\n\t<a class=\"photos-btn active\" href=\"/photos/index.html\">Photos</a>\n\t<a class=\"photos-btn\" href=\"/photos/video.html\">Videos</a>\n</div>\n<div class=\"instagram itemscope\">\n\t<a href=\"https://sanshui.findn.cn/photos/index.html\" target=\"_blank\" class=\"open-ins\">图片正在加载中…</a>\n</div>\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./static/ins.js')\n    }, 0)\n  })()\n</script>"},{"_content":"/* ======photos ===== */\n#post-instagram{\n\tpadding: 30px;\n}\n#post-instagram .article-entry{\n\tpadding-right: 0;\n}\n\n.instagram{\n\tposition: relative;\n\tmin-height: 500px;\n}\n.instagram img {\n\twidth: 100%;\n}\n.instagram .year {\n\tfont-size: 16px;\n\tborder-bottom: none;\n}\n.instagram .open-ins{\n\tpadding: 10px 0;\n\tcolor: #cdcdcd;\n}\n.instagram .open-ins:hover{\n\tcolor: #657b83;\n}\n.instagram .year{\n\tdisplay: inline;\n}\n.instagram .thumb {\n\twidth: 25%;\n\theight: 0; \n\tpadding-bottom: 25%;\n\tposition: relative;\n\tdisplay: inline-block;\n\ttext-align: center;\n\tbackground: #ededed;\n\toutline: 1px solid #ddd;\n}\n.instagram .thumb a {\n\tposition: relative;\n}\n.instagram .album h1 em{\n\tfont-style: normal;\n\tfont-size: 16px;\n\tmargin-left: 10px;\n}\n.instagram .album ul{\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tclear: both;\n\twidth: 100%;\n\ttext-align: left;\n}\n.instagram .album li{\n\tlist-style: none;\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tpadding: 0 5px;\n\tmargin-bottom: -10px;\n\theight: 0;\n\twidth: 25%;\n\tposition: relative;\n\tpadding-bottom: 25%;\n}\n.instagram .album li:before{\n\tdisplay: none;\n}\n.instagram .album div.img-box{\n\tposition: absolute;\n\twidth: 90%;\n\theight: 90%;\n\t-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\t-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\tbox-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n}\n.instagram .album div.img-box img{\n\twidth: 100%;\n\theight: 100%;\n    position: absolute;\n    z-index: 2;\n}\n.instagram .album div.img-box .img-bg{\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tbottom: 0px;\n\twidth: 100%;\n\tmargin: -5px;\n\tpadding: 5px;\n\t-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\tbox-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-webkit-transition: all 0.15s ease-out 0.1s;\n\t-moz-transition: all 0.15s ease-out 0.1s;\n\t-o-transition: all 0.15s ease-out 0.1s;\n\ttransition: all 0.15s ease-out 0.1s;\n\topacity: 0.2;\n\tcursor: pointer;\n\tdisplay: block;\n\tz-index: 3;\n}\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n.instagram .album div.img-box .img-bg:hover{\n\topacity: 0;\n}\n.photos-btn-wrap {\n\tborder-bottom: 1px solid #e5e5e5;\n\tmargin-bottom: 20px;\n}\n.photos-btn {\n\tfont-size: 16px;\n\tcolor: #333;\n\tmargin-bottom: -4px;\n\tpadding: 5px 8px 3px;\n}\n.photos-btn.active {\n\tcolor: #08c;\n\tborder: 1px solid #e5e5e5;\n\tborder-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}\n\n\n/* ====== video ===== */\n .video-container {\n    z-index: 1;\n    position: relative;\n    padding-bottom: 56.25%;\n    margin: 0 auto;\n}\n.video-container iframe, .video-container object, .video-container embed {\n    z-index: 1;\n    position: absolute;\n    top: 0;\n    left: 7%;\n    width: 85%;\n    height: 85%;\n    box-shadow: 0px 0px 20px 2px #888888;\n}\n","source":"photos/static/ins.css","raw":"/* ======photos ===== */\n#post-instagram{\n\tpadding: 30px;\n}\n#post-instagram .article-entry{\n\tpadding-right: 0;\n}\n\n.instagram{\n\tposition: relative;\n\tmin-height: 500px;\n}\n.instagram img {\n\twidth: 100%;\n}\n.instagram .year {\n\tfont-size: 16px;\n\tborder-bottom: none;\n}\n.instagram .open-ins{\n\tpadding: 10px 0;\n\tcolor: #cdcdcd;\n}\n.instagram .open-ins:hover{\n\tcolor: #657b83;\n}\n.instagram .year{\n\tdisplay: inline;\n}\n.instagram .thumb {\n\twidth: 25%;\n\theight: 0; \n\tpadding-bottom: 25%;\n\tposition: relative;\n\tdisplay: inline-block;\n\ttext-align: center;\n\tbackground: #ededed;\n\toutline: 1px solid #ddd;\n}\n.instagram .thumb a {\n\tposition: relative;\n}\n.instagram .album h1 em{\n\tfont-style: normal;\n\tfont-size: 16px;\n\tmargin-left: 10px;\n}\n.instagram .album ul{\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tclear: both;\n\twidth: 100%;\n\ttext-align: left;\n}\n.instagram .album li{\n\tlist-style: none;\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tpadding: 0 5px;\n\tmargin-bottom: -10px;\n\theight: 0;\n\twidth: 25%;\n\tposition: relative;\n\tpadding-bottom: 25%;\n}\n.instagram .album li:before{\n\tdisplay: none;\n}\n.instagram .album div.img-box{\n\tposition: absolute;\n\twidth: 90%;\n\theight: 90%;\n\t-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\t-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\tbox-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n}\n.instagram .album div.img-box img{\n\twidth: 100%;\n\theight: 100%;\n    position: absolute;\n    z-index: 2;\n}\n.instagram .album div.img-box .img-bg{\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tbottom: 0px;\n\twidth: 100%;\n\tmargin: -5px;\n\tpadding: 5px;\n\t-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\tbox-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-webkit-transition: all 0.15s ease-out 0.1s;\n\t-moz-transition: all 0.15s ease-out 0.1s;\n\t-o-transition: all 0.15s ease-out 0.1s;\n\ttransition: all 0.15s ease-out 0.1s;\n\topacity: 0.2;\n\tcursor: pointer;\n\tdisplay: block;\n\tz-index: 3;\n}\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n.instagram .album div.img-box .img-bg:hover{\n\topacity: 0;\n}\n.photos-btn-wrap {\n\tborder-bottom: 1px solid #e5e5e5;\n\tmargin-bottom: 20px;\n}\n.photos-btn {\n\tfont-size: 16px;\n\tcolor: #333;\n\tmargin-bottom: -4px;\n\tpadding: 5px 8px 3px;\n}\n.photos-btn.active {\n\tcolor: #08c;\n\tborder: 1px solid #e5e5e5;\n\tborder-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}\n\n\n/* ====== video ===== */\n .video-container {\n    z-index: 1;\n    position: relative;\n    padding-bottom: 56.25%;\n    margin: 0 auto;\n}\n.video-container iframe, .video-container object, .video-container embed {\n    z-index: 1;\n    position: absolute;\n    top: 0;\n    left: 7%;\n    width: 85%;\n    height: 85%;\n    box-shadow: 0px 0px 20px 2px #888888;\n}\n","date":"2021-10-23T05:09:22.979Z","updated":"2021-10-23T05:09:22.979Z","path":"photos/static/ins.css","layout":"false","title":"","comments":1,"_id":"clb218l42000764rggnjses9t","content":"/* ======photos ===== */\n#post-instagram{\n\tpadding: 30px;\n}\n#post-instagram .article-entry{\n\tpadding-right: 0;\n}\n\n.instagram{\n\tposition: relative;\n\tmin-height: 500px;\n}\n.instagram img {\n\twidth: 100%;\n}\n.instagram .year {\n\tfont-size: 16px;\n\tborder-bottom: none;\n}\n.instagram .open-ins{\n\tpadding: 10px 0;\n\tcolor: #cdcdcd;\n}\n.instagram .open-ins:hover{\n\tcolor: #657b83;\n}\n.instagram .year{\n\tdisplay: inline;\n}\n.instagram .thumb {\n\twidth: 25%;\n\theight: 0; \n\tpadding-bottom: 25%;\n\tposition: relative;\n\tdisplay: inline-block;\n\ttext-align: center;\n\tbackground: #ededed;\n\toutline: 1px solid #ddd;\n}\n.instagram .thumb a {\n\tposition: relative;\n}\n.instagram .album h1 em{\n\tfont-style: normal;\n\tfont-size: 16px;\n\tmargin-left: 10px;\n}\n.instagram .album ul{\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tclear: both;\n\twidth: 100%;\n\ttext-align: left;\n}\n.instagram .album li{\n\tlist-style: none;\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tpadding: 0 5px;\n\tmargin-bottom: -10px;\n\theight: 0;\n\twidth: 25%;\n\tposition: relative;\n\tpadding-bottom: 25%;\n}\n.instagram .album li:before{\n\tdisplay: none;\n}\n.instagram .album div.img-box{\n\tposition: absolute;\n\twidth: 90%;\n\theight: 90%;\n\t-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\t-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\tbox-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n}\n.instagram .album div.img-box img{\n\twidth: 100%;\n\theight: 100%;\n    position: absolute;\n    z-index: 2;\n}\n.instagram .album div.img-box .img-bg{\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tbottom: 0px;\n\twidth: 100%;\n\tmargin: -5px;\n\tpadding: 5px;\n\t-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\tbox-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-webkit-transition: all 0.15s ease-out 0.1s;\n\t-moz-transition: all 0.15s ease-out 0.1s;\n\t-o-transition: all 0.15s ease-out 0.1s;\n\ttransition: all 0.15s ease-out 0.1s;\n\topacity: 0.2;\n\tcursor: pointer;\n\tdisplay: block;\n\tz-index: 3;\n}\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n.instagram .album div.img-box .img-bg:hover{\n\topacity: 0;\n}\n.photos-btn-wrap {\n\tborder-bottom: 1px solid #e5e5e5;\n\tmargin-bottom: 20px;\n}\n.photos-btn {\n\tfont-size: 16px;\n\tcolor: #333;\n\tmargin-bottom: -4px;\n\tpadding: 5px 8px 3px;\n}\n.photos-btn.active {\n\tcolor: #08c;\n\tborder: 1px solid #e5e5e5;\n\tborder-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}\n\n\n/* ====== video ===== */\n .video-container {\n    z-index: 1;\n    position: relative;\n    padding-bottom: 56.25%;\n    margin: 0 auto;\n}\n.video-container iframe, .video-container object, .video-container embed {\n    z-index: 1;\n    position: absolute;\n    top: 0;\n    left: 7%;\n    width: 85%;\n    height: 85%;\n    box-shadow: 0px 0px 20px 2px #888888;\n}\n","site":{"data":{}},"excerpt":"","more":"/* ======photos ===== */\n#post-instagram{\n\tpadding: 30px;\n}\n#post-instagram .article-entry{\n\tpadding-right: 0;\n}\n\n.instagram{\n\tposition: relative;\n\tmin-height: 500px;\n}\n.instagram img {\n\twidth: 100%;\n}\n.instagram .year {\n\tfont-size: 16px;\n\tborder-bottom: none;\n}\n.instagram .open-ins{\n\tpadding: 10px 0;\n\tcolor: #cdcdcd;\n}\n.instagram .open-ins:hover{\n\tcolor: #657b83;\n}\n.instagram .year{\n\tdisplay: inline;\n}\n.instagram .thumb {\n\twidth: 25%;\n\theight: 0; \n\tpadding-bottom: 25%;\n\tposition: relative;\n\tdisplay: inline-block;\n\ttext-align: center;\n\tbackground: #ededed;\n\toutline: 1px solid #ddd;\n}\n.instagram .thumb a {\n\tposition: relative;\n}\n.instagram .album h1 em{\n\tfont-style: normal;\n\tfont-size: 16px;\n\tmargin-left: 10px;\n}\n.instagram .album ul{\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tclear: both;\n\twidth: 100%;\n\ttext-align: left;\n}\n.instagram .album li{\n\tlist-style: none;\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tpadding: 0 5px;\n\tmargin-bottom: -10px;\n\theight: 0;\n\twidth: 25%;\n\tposition: relative;\n\tpadding-bottom: 25%;\n}\n.instagram .album li:before{\n\tdisplay: none;\n}\n.instagram .album div.img-box{\n\tposition: absolute;\n\twidth: 90%;\n\theight: 90%;\n\t-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\t-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\tbox-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n}\n.instagram .album div.img-box img{\n\twidth: 100%;\n\theight: 100%;\n    position: absolute;\n    z-index: 2;\n}\n.instagram .album div.img-box .img-bg{\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tbottom: 0px;\n\twidth: 100%;\n\tmargin: -5px;\n\tpadding: 5px;\n\t-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\tbox-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-webkit-transition: all 0.15s ease-out 0.1s;\n\t-moz-transition: all 0.15s ease-out 0.1s;\n\t-o-transition: all 0.15s ease-out 0.1s;\n\ttransition: all 0.15s ease-out 0.1s;\n\topacity: 0.2;\n\tcursor: pointer;\n\tdisplay: block;\n\tz-index: 3;\n}\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n.instagram .album div.img-box .img-bg:hover{\n\topacity: 0;\n}\n.photos-btn-wrap {\n\tborder-bottom: 1px solid #e5e5e5;\n\tmargin-bottom: 20px;\n}\n.photos-btn {\n\tfont-size: 16px;\n\tcolor: #333;\n\tmargin-bottom: -4px;\n\tpadding: 5px 8px 3px;\n}\n.photos-btn.active {\n\tcolor: #08c;\n\tborder: 1px solid #e5e5e5;\n\tborder-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}\n\n\n/* ====== video ===== */\n .video-container {\n    z-index: 1;\n    position: relative;\n    padding-bottom: 56.25%;\n    margin: 0 auto;\n}\n.video-container iframe, .video-container object, .video-container embed {\n    z-index: 1;\n    position: absolute;\n    top: 0;\n    left: 7%;\n    width: 85%;\n    height: 85%;\n    box-shadow: 0px 0px 20px 2px #888888;\n}\n"},{"title":"视频","no_word_count":true,"no_toc":true,"no_date":true,"no_declare":true,"no_reward":true,"no_comments":false,"abbrlink":"e26d1860","_content":"\n<link rel=\"stylesheet\" href=\"./static/ins.css\">\n<div class=\"photos-btn-wrap\">\t\n  <a class=\"photos-btn\" href=\"/photos/index.html\">Photos</a>\n  <a class=\"photos-btn active\" href=\"/photos/video.html\">Videos</a>\n</div>\n\n\n<center>\n  <h1>李宏毅2021春机器学习课程</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\" >\n  <iframe src=\"//player.bilibili.com/player.html?aid=246993280&bvid=BV1Wv411h7kN&cid=303819228&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%; \"></iframe>\n</div>\n\n<hr>\n<center>\n    <h1>《PyTorch深度学习实践》完结合集 —— 刘二大人</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=97078147&bvid=BV1Y7411d7Ys&cid=165713573&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%;\"></iframe>\n</div>\n\n<hr>\n<center>\n    <h1>动手学深度学习v2 —— 李沐</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=714717789&bvid=BV1oX4y137bC&cid=313097645&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%;\"></iframe>\n</div>\n\n","source":"photos/video.ejs","raw":"---\ntitle: 视频\nno_word_count: true\nno_toc: true\nno_date: true\nno_declare: true\nno_reward: true\nno_comments: false\nabbrlink: e26d1860\n---\n\n<link rel=\"stylesheet\" href=\"./static/ins.css\">\n<div class=\"photos-btn-wrap\">\t\n  <a class=\"photos-btn\" href=\"/photos/index.html\">Photos</a>\n  <a class=\"photos-btn active\" href=\"/photos/video.html\">Videos</a>\n</div>\n\n\n<center>\n  <h1>李宏毅2021春机器学习课程</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\" >\n  <iframe src=\"//player.bilibili.com/player.html?aid=246993280&bvid=BV1Wv411h7kN&cid=303819228&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%; \"></iframe>\n</div>\n\n<hr>\n<center>\n    <h1>《PyTorch深度学习实践》完结合集 —— 刘二大人</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=97078147&bvid=BV1Y7411d7Ys&cid=165713573&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%;\"></iframe>\n</div>\n\n<hr>\n<center>\n    <h1>动手学深度学习v2 —— 李沐</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=714717789&bvid=BV1oX4y137bC&cid=313097645&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%;\"></iframe>\n</div>\n\n","date":"2022-11-25T05:36:55.405Z","updated":"2021-10-24T15:22:04.482Z","path":"photos/video.html","comments":1,"layout":"page","_id":"clb218l42000864rgf473hj6o","content":"\n<link rel=\"stylesheet\" href=\"./static/ins.css\">\n<div class=\"photos-btn-wrap\">\t\n  <a class=\"photos-btn\" href=\"/photos/index.html\">Photos</a>\n  <a class=\"photos-btn active\" href=\"/photos/video.html\">Videos</a>\n</div>\n\n\n<center>\n  <h1>李宏毅2021春机器学习课程</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\" >\n  <iframe src=\"//player.bilibili.com/player.html?aid=246993280&bvid=BV1Wv411h7kN&cid=303819228&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%; \"></iframe>\n</div>\n\n<hr>\n<center>\n    <h1>《PyTorch深度学习实践》完结合集 —— 刘二大人</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=97078147&bvid=BV1Y7411d7Ys&cid=165713573&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%;\"></iframe>\n</div>\n\n<hr>\n<center>\n    <h1>动手学深度学习v2 —— 李沐</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=714717789&bvid=BV1oX4y137bC&cid=313097645&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%;\"></iframe>\n</div>\n\n","site":{"data":{}},"excerpt":"","more":"\n<link rel=\"stylesheet\" href=\"./static/ins.css\">\n<div class=\"photos-btn-wrap\">\t\n  <a class=\"photos-btn\" href=\"/photos/index.html\">Photos</a>\n  <a class=\"photos-btn active\" href=\"/photos/video.html\">Videos</a>\n</div>\n\n\n<center>\n  <h1>李宏毅2021春机器学习课程</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\" >\n  <iframe src=\"//player.bilibili.com/player.html?aid=246993280&bvid=BV1Wv411h7kN&cid=303819228&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%; \"></iframe>\n</div>\n\n<hr>\n<center>\n    <h1>《PyTorch深度学习实践》完结合集 —— 刘二大人</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=97078147&bvid=BV1Y7411d7Ys&cid=165713573&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%;\"></iframe>\n</div>\n\n<hr>\n<center>\n    <h1>动手学深度学习v2 —— 李沐</h1>\n</center>\n<hr>\n<div style=\"position:relative; padding-bottom:75%; width:100%; height:0\">\n    <iframe src=\"//player.bilibili.com/player.html?aid=714717789&bvid=BV1oX4y137bC&cid=313097645&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position:absolute; height: 90%; width: 100%;\"></iframe>\n</div>\n\n"},{"_content":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n    /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n        /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n/************************************************************************/\n/******/\n([\n  /* 0 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    'use strict';\n\n    __webpack_require__(1);\n\n    var _view = __webpack_require__(2);\n\n    var _view2 = _interopRequireDefault(_view);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    /**\n     * @name impush-client \n     * @description 这个项目让我发家致富…\n     * @date 2016-12-1\n     */\n\n    var _collection = [];\n    var _count = 0;\n    var searchData;\n\n    function addMask(elem) {\n      var rect = elem.getBoundingClientRect();\n      var style = getComputedStyle(elem, null);\n\n      var mask = document.createElement('i');\n      mask.className = 'icon-film';\n      mask.style.color = '#fff';\n      mask.style.fontSize = '26px';\n      mask.style.position = 'absolute';\n      mask.style.right = '10px';\n      mask.style.bottom = '10px';\n      mask.style.zIndex = 1;\n      elem.parentNode.appendChild(mask);\n    }\n\n    var createVideoIncon = function createVideoIncon() {\n      var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n      for (var i = 0, len = $videoImg.length; i < len; i++) {\n        addMask($videoImg[i]);\n      }\n    };\n    var render = function render(res) {\n      var ulTmpl = \"\";\n      for (var j = 0, len2 = res.list.length; j < len2; j++) {\n        var data = res.list[j].arr;\n        var liTmpl = \"\";\n        for (var i = 0, len = data.link.length; i < len; i++) {\n          var minSrc = 'https://qiniu.findn.cn/blog/photos/min_photos/' + data.link[i];\n          var src = 'https://qiniu.findn.cn/blog/photos/photos/' + data.link[i];\n          var type = data.type[i];\n          var target = src + (type === 'video' ? '.mp4' : '.jpg');\n          src += '';\n\n          liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/photos/static/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n        }\n        ulTmpl = ulTmpl + '<section class=\"album\"><h1 class=\"year\">' + data.year + '年<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n      }\n      document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n      createVideoIncon();\n      _view2.default.init();\n    };\n\n    var replacer = function replacer(str) {\n      var arr = str.split(\"/\");\n      return \"/assets/ins/\" + arr[arr.length - 1];\n    };\n\n    var ctrler = function ctrler(data) {\n      var imgObj = {};\n      for (var i = 0, len = data.length; i < len; i++) {\n        var y = data[i].y;\n        var m = data[i].m;\n        var src = replacer(data[i].src);\n        var text = data[i].text;\n        var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n        if (imgObj[key]) {\n          imgObj[key].srclist.push(src);\n          imgObj[key].text.push(text);\n        } else {\n          imgObj[key] = {\n            year: y,\n            month: m,\n            srclist: [src],\n            text: [text]\n          };\n        }\n      }\n      render(imgObj);\n    };\n\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './data.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n\n    Ins.init();\n\n    // export default impush;\n\n    /***/\n  },\n  /* 1 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      'use strict';\n\n      var inViewport = __webpack_require__(3);\n      var lazyAttrs = ['data-src'];\n\n      global.lzld = lazyload();\n\n      // Provide libs using getAttribute early to get the good src\n      // and not the fake data-src\n      replaceGetAttribute('Image');\n      replaceGetAttribute('IFrame');\n\n      function registerLazyAttr(attr) {\n        if (indexOf.call(lazyAttrs, attr) === -1) {\n          lazyAttrs.push(attr);\n        }\n      }\n\n      function lazyload(opts) {\n        opts = merge({\n          'offset': 333,\n          'src': 'data-src',\n          'container': false\n        }, opts || {});\n\n        if (typeof opts.src === 'string') {\n          registerLazyAttr(opts.src);\n        }\n\n        var elts = [];\n\n        function show(elt) {\n          var src = findRealSrc(elt);\n\n          if (src) {\n            elt.src = src;\n          }\n\n          elt.setAttribute('data-lzled', true);\n          elts[indexOf.call(elts, elt)] = null;\n        }\n\n        function findRealSrc(elt) {\n          if (typeof opts.src === 'function') {\n            return opts.src(elt);\n          }\n\n          return elt.getAttribute(opts.src);\n        }\n\n        function register(elt) {\n          elt.onload = null;\n          elt.removeAttribute('onload');\n          elt.onerror = null;\n          elt.removeAttribute('onerror');\n\n          if (indexOf.call(elts, elt) === -1) {\n            inViewport(elt, opts, show);\n          }\n        }\n\n        return register;\n      }\n\n      function replaceGetAttribute(elementName) {\n        var fullname = 'HTML' + elementName + 'Element';\n        if (fullname in global === false) {\n          return;\n        }\n\n        var original = global[fullname].prototype.getAttribute;\n        global[fullname].prototype.getAttribute = function(name) {\n          if (name === 'src') {\n            var realSrc;\n            for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n              realSrc = original.call(this, lazyAttrs[i]);\n              if (realSrc) {\n                break;\n              }\n            }\n\n            return realSrc || original.call(this, name);\n          }\n\n          // our own lazyloader will go through theses lines\n          // because we use getAttribute(opts.src)\n          return original.call(this, name);\n        };\n      }\n\n      function merge(defaults, opts) {\n        for (var name in defaults) {\n          if (opts[name] === undefined) {\n            opts[name] = defaults[name];\n          }\n        }\n\n        return opts;\n      }\n\n      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n      function indexOf(value) {\n        for (var i = this.length; i-- && this[i] !== value;) {}\n        return i;\n      }\n\n      module.exports = lazyload;\n\n      // export default impush;\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  },\n  /* 2 */\n  /***/\n  function(module, exports) {\n\n    'use strict';\n\n    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n      // parse slide data (url, title, size ...) from DOM elements \n      // (children of gallerySelector)\n      var parseThumbnailElements = function parseThumbnailElements(el) {\n        el = el.parentNode.parentNode;\n        var thumbElements = el.getElementsByClassName('thumb'),\n          numNodes = thumbElements.length,\n          items = [],\n          figureEl,\n          linkEl,\n          size,\n          type,\n          // video or not\n          target,\n          item;\n\n        for (var i = 0; i < numNodes; i++) {\n\n          figureEl = thumbElements[i]; // \n\n          // include only element nodes \n          if (figureEl.nodeType !== 1) {\n            continue;\n          }\n\n          linkEl = figureEl.children[0]; // \n\n          size = linkEl.getAttribute('data-size').split('x');\n          type = linkEl.getAttribute('data-type');\n          target = linkEl.getAttribute('data-target');\n          // create slide object\n          item = {\n            src: linkEl.getAttribute('href'),\n            w: parseInt(size[0], 10),\n            h: parseInt(size[1], 10)\n          };\n\n          if (figureEl.children.length > 1) {\n            item.title = figureEl.children[1].innerHTML;\n          }\n\n          if (linkEl.children.length > 0) {\n            item.msrc = linkEl.children[0].getAttribute('src');\n            item.type = type;\n            item.target = target;\n            item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n            if (type === 'video') {\n              //item.src = null;\n            }\n          }\n\n          item.el = figureEl; // save link to element for getThumbBoundsFn\n          items.push(item);\n        }\n\n        return items;\n      };\n\n      // find nearest parent element\n      var closest = function closest(el, fn) {\n        return el && (fn(el) ? el : closest(el.parentNode, fn));\n      };\n\n      // triggers when user clicks on thumbnail\n      var onThumbnailsClick = function onThumbnailsClick(e) {\n        e = e || window.event;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n        var eTarget = e.target || e.srcElement;\n\n        // find root element of slide\n        var clickedListItem = closest(eTarget, function(el) {\n          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n        });\n\n        if (!clickedListItem) {\n          return;\n        }\n\n        // find index of clicked item by looping through all child nodes\n        // alternatively, you may define index via data- attribute\n        var clickedGallery = clickedListItem.parentNode,\n\n          // childNodes = clickedListItem.parentNode.childNodes,\n          // numChildNodes = childNodes.length,\n          childNodes = document.getElementsByClassName('thumb'),\n          numChildNodes = childNodes.length,\n          nodeIndex = 0,\n          index;\n\n        for (var i = 0; i < numChildNodes; i++) {\n          if (childNodes[i].nodeType !== 1) {\n            continue;\n          }\n\n          if (childNodes[i] === clickedListItem) {\n            index = nodeIndex;\n            break;\n          }\n          nodeIndex++;\n        }\n\n        if (index >= 0) {\n          // open PhotoSwipe if valid index found\n          openPhotoSwipe(index, clickedGallery);\n        }\n        return false;\n      };\n\n      // parse picture index and gallery index from URL (#&pid=1&gid=2)\n      var photoswipeParseHash = function photoswipeParseHash() {\n        var hash = window.location.hash.substring(1),\n          params = {};\n\n        if (hash.length < 5) {\n          return params;\n        }\n\n        var vars = hash.split('&');\n        for (var i = 0; i < vars.length; i++) {\n          if (!vars[i]) {\n            continue;\n          }\n          var pair = vars[i].split('=');\n          if (pair.length < 2) {\n            continue;\n          }\n          params[pair[0]] = pair[1];\n        }\n\n        if (params.gid) {\n          params.gid = parseInt(params.gid, 10);\n        }\n\n        return params;\n      };\n\n      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n        var pswpElement = document.querySelectorAll('.pswp')[0],\n          gallery,\n          options,\n          items;\n\n        items = parseThumbnailElements(galleryElement);\n        // define options (if needed)\n        options = {\n\n          // define gallery index (for URL)\n          galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n          getThumbBoundsFn: function getThumbBoundsFn(index) {\n            // See Options -> getThumbBoundsFn section of documentation for more info\n            var thumbnail = items[index].el.getElementsByTagName('img')[0],\n              // find thumbnail\n              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n              rect = thumbnail.getBoundingClientRect();\n\n            return {\n              x: rect.left,\n              y: rect.top + pageYScroll,\n              w: rect.width\n            };\n          }\n\n        };\n\n        // PhotoSwipe opened from URL\n        if (fromURL) {\n          if (options.galleryPIDs) {\n            // parse real index when custom PIDs are used \n            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n            for (var j = 0; j < items.length; j++) {\n              if (items[j].pid == index) {\n                options.index = j;\n                break;\n              }\n            }\n          } else {\n            // in URL indexes start from 1\n            options.index = parseInt(index, 10) - 1;\n          }\n        } else {\n          options.index = parseInt(index, 10);\n        }\n\n        // exit if index not found\n        if (isNaN(options.index)) {\n          return;\n        }\n\n        if (disableAnimation) {\n          options.showAnimationDuration = 0;\n        }\n\n        // Pass data to PhotoSwipe and initialize it\n        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n        gallery.init();\n\n        var $tempVideo;\n        var stopVideoHandle = function stopVideoHandle() {\n          if ($tempVideo) {\n            $tempVideo.remove();\n            $tempVideo = null;\n          }\n        };\n        var changeHandle = function changeHandle() {\n          var item = gallery.currItem;\n          stopVideoHandle();\n          if (item.type === 'video') {\n            var $ctn = item.container;\n            var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n            var $video = document.createElement('video');\n            $video.setAttribute('autoplay', 'autoplay');\n            $video.setAttribute('controls', 'controls');\n            $video.setAttribute('src', item.target);\n            $video.style.width = style.width;\n            $video.style.height = style.height;\n            $video.style.position = 'absolute';\n            $video.style.zIndex = 2;\n            $tempVideo = $video;\n            $ctn.appendChild($video);\n          }\n        };\n        gallery.listen('initialZoomIn', changeHandle);\n        gallery.listen('afterChange', changeHandle);\n        gallery.listen('initialZoomOut', stopVideoHandle);\n      };\n\n      // loop through all gallery elements and bind events\n      var galleryElements = document.querySelectorAll(gallerySelector);\n      for (var i = 0, l = galleryElements.length; i < l; i++) {\n        galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n        galleryElements[i].onclick = onThumbnailsClick;\n      }\n\n      // Parse URL and open gallery if it contains #&pid=3&gid=1\n      var hashData = photoswipeParseHash();\n      if (hashData.pid && hashData.gid) {\n        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n      }\n    };\n\n    var Viewer = function() {\n      function init() {\n        initPhotoSwipeFromDOM('.photos');\n      }\n      return {\n        init: init\n      };\n    }();\n\n    module.exports = Viewer;\n\n    /***/\n  },\n  /* 3 */\n  /***/\n  function(module, exports) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      module.exports = inViewport;\n\n      var instances = [];\n      var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n      function inViewport(elt, params, cb) {\n        var opts = {\n          container: global.document.body,\n          offset: 0\n        };\n\n        if (params === undefined || typeof params === 'function') {\n          cb = params;\n          params = {};\n        }\n\n        var container = opts.container = params.container || opts.container;\n        var offset = opts.offset = params.offset || opts.offset;\n\n        for (var i = 0; i < instances.length; i++) {\n          if (instances[i].container === container) {\n            return instances[i].isInViewport(elt, offset, cb);\n          }\n        }\n\n        return instances[\n          instances.push(createInViewport(container)) - 1\n        ].isInViewport(elt, offset, cb);\n      }\n\n      function addEvent(el, type, fn) {\n        if (el.attachEvent) {\n          el.attachEvent('on' + type, fn);\n        } else {\n          el.addEventListener(type, fn, false);\n        }\n      }\n\n      function debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this,\n            args = arguments;\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n          if (callNow) func.apply(context, args);\n\n          function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          }\n        };\n      }\n\n      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n      var contains = function() {\n        if (!global.document) {\n          return true;\n        }\n        return global.document.documentElement.compareDocumentPosition ?\n          function(a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          } :\n          global.document.documentElement.contains ?\n          function(a, b) {\n            return a !== b && (a.contains ? a.contains(b) : false);\n          } :\n          function(a, b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n      }\n\n      function createInViewport(container) {\n        var watches = createWatches();\n\n        var scrollContainer = container === global.document.body ? global : container;\n        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n        addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n        if (scrollContainer === global) {\n          addEvent(global, 'resize', debouncedCheck);\n        }\n\n        if (supportsMutationObserver) {\n          observeDOM(watches, container, debouncedCheck);\n        }\n\n        // failsafe check, every 200ms we check for visible images\n        // usecase: a hidden parent containing eleements\n        // when the parent becomes visible, we have no event that the children\n        // became visible\n        setInterval(debouncedCheck, 150);\n\n        function isInViewport(elt, offset, cb) {\n          if (!cb) {\n            return isVisible(elt, offset);\n          }\n\n          var remote = createRemote(elt, offset, cb);\n          remote.watch();\n          return remote;\n        }\n\n        function createRemote(elt, offset, cb) {\n          function watch() {\n            watches.add(elt, offset, cb);\n          }\n\n          function dispose() {\n            watches.remove(elt);\n          }\n\n          return {\n            watch: watch,\n            dispose: dispose\n          };\n        }\n\n        function watchInViewport(elt, offset, cb) {\n          if (isVisible(elt, offset)) {\n            watches.remove(elt);\n            cb(elt);\n          }\n        }\n\n        function isVisible(elt, offset) {\n          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n            return false;\n          }\n\n          // Check if the element is visible\n          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n          if (!elt.offsetWidth || !elt.offsetHeight) {\n            return false;\n          }\n\n          var eltRect = elt.getBoundingClientRect();\n          var viewport = {};\n\n          if (container === global.document.body) {\n            viewport = {\n              top: -offset,\n              left: -offset,\n              right: global.document.documentElement.clientWidth + offset,\n              bottom: global.document.documentElement.clientHeight + offset\n            };\n          } else {\n            var containerRect = container.getBoundingClientRect();\n            viewport = {\n              top: containerRect.top - offset,\n              left: containerRect.left - offset,\n              right: containerRect.right + offset,\n              bottom: containerRect.bottom + offset\n            };\n          }\n\n          // The element must overlap with the visible part of the viewport\n          var visible =\n            (\n              (eltRect.right > viewport.left) &&\n              (eltRect.left < viewport.right) &&\n              (eltRect.bottom > viewport.top) &&\n              (eltRect.top < viewport.bottom)\n            );\n\n          return visible;\n        }\n\n        return {\n          container: container,\n          isInViewport: isInViewport\n        };\n      }\n\n      function createWatches() {\n        var watches = [];\n\n        function add(elt, offset, cb) {\n          if (!isWatched(elt)) {\n            watches.push([elt, offset, cb]);\n          }\n        }\n\n        function remove(elt) {\n          var pos = indexOf(elt);\n          if (pos !== -1) {\n            watches.splice(pos, 1);\n          }\n        }\n\n        function indexOf(elt) {\n          for (var i = watches.length - 1; i >= 0; i--) {\n            if (watches[i][0] === elt) {\n              return i;\n            }\n          }\n          return -1;\n        }\n\n        function isWatched(elt) {\n          return indexOf(elt) !== -1;\n        }\n\n        function checkAll(cb) {\n          return function() {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              cb.apply(this, watches[i]);\n            }\n          };\n        }\n\n        return {\n          add: add,\n          remove: remove,\n          isWatched: isWatched,\n          checkAll: checkAll\n        };\n      }\n\n      function observeDOM(watches, container, cb) {\n        var observer = new MutationObserver(watch);\n        var filter = Array.prototype.filter;\n        var concat = Array.prototype.concat;\n\n        observer.observe(container, {\n          childList: true,\n          subtree: true,\n          // changes like style/width/height/display will be catched\n          attributes: true\n        });\n\n        function watch(mutations) {\n          // some new DOM nodes where previously watched\n          // we should check their positions\n          if (mutations.some(knownNodes) === true) {\n            setTimeout(cb, 0);\n          }\n        }\n\n        function knownNodes(mutation) {\n          var nodes = concat.call([],\n            Array.prototype.slice.call(mutation.addedNodes),\n            mutation.target\n          );\n          return filter.call(nodes, watches.isWatched).length > 0;\n        }\n      }\n\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  }\n  /******/\n]);","source":"photos/static/ins.js","raw":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n    /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n        /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n/************************************************************************/\n/******/\n([\n  /* 0 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    'use strict';\n\n    __webpack_require__(1);\n\n    var _view = __webpack_require__(2);\n\n    var _view2 = _interopRequireDefault(_view);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    /**\n     * @name impush-client \n     * @description 这个项目让我发家致富…\n     * @date 2016-12-1\n     */\n\n    var _collection = [];\n    var _count = 0;\n    var searchData;\n\n    function addMask(elem) {\n      var rect = elem.getBoundingClientRect();\n      var style = getComputedStyle(elem, null);\n\n      var mask = document.createElement('i');\n      mask.className = 'icon-film';\n      mask.style.color = '#fff';\n      mask.style.fontSize = '26px';\n      mask.style.position = 'absolute';\n      mask.style.right = '10px';\n      mask.style.bottom = '10px';\n      mask.style.zIndex = 1;\n      elem.parentNode.appendChild(mask);\n    }\n\n    var createVideoIncon = function createVideoIncon() {\n      var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n      for (var i = 0, len = $videoImg.length; i < len; i++) {\n        addMask($videoImg[i]);\n      }\n    };\n    var render = function render(res) {\n      var ulTmpl = \"\";\n      for (var j = 0, len2 = res.list.length; j < len2; j++) {\n        var data = res.list[j].arr;\n        var liTmpl = \"\";\n        for (var i = 0, len = data.link.length; i < len; i++) {\n          var minSrc = 'https://qiniu.findn.cn/blog/photos/min_photos/' + data.link[i];\n          var src = 'https://qiniu.findn.cn/blog/photos/photos/' + data.link[i];\n          var type = data.type[i];\n          var target = src + (type === 'video' ? '.mp4' : '.jpg');\n          src += '';\n\n          liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/photos/static/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n        }\n        ulTmpl = ulTmpl + '<section class=\"album\"><h1 class=\"year\">' + data.year + '年<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n      }\n      document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n      createVideoIncon();\n      _view2.default.init();\n    };\n\n    var replacer = function replacer(str) {\n      var arr = str.split(\"/\");\n      return \"/assets/ins/\" + arr[arr.length - 1];\n    };\n\n    var ctrler = function ctrler(data) {\n      var imgObj = {};\n      for (var i = 0, len = data.length; i < len; i++) {\n        var y = data[i].y;\n        var m = data[i].m;\n        var src = replacer(data[i].src);\n        var text = data[i].text;\n        var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n        if (imgObj[key]) {\n          imgObj[key].srclist.push(src);\n          imgObj[key].text.push(text);\n        } else {\n          imgObj[key] = {\n            year: y,\n            month: m,\n            srclist: [src],\n            text: [text]\n          };\n        }\n      }\n      render(imgObj);\n    };\n\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './data.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n\n    Ins.init();\n\n    // export default impush;\n\n    /***/\n  },\n  /* 1 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      'use strict';\n\n      var inViewport = __webpack_require__(3);\n      var lazyAttrs = ['data-src'];\n\n      global.lzld = lazyload();\n\n      // Provide libs using getAttribute early to get the good src\n      // and not the fake data-src\n      replaceGetAttribute('Image');\n      replaceGetAttribute('IFrame');\n\n      function registerLazyAttr(attr) {\n        if (indexOf.call(lazyAttrs, attr) === -1) {\n          lazyAttrs.push(attr);\n        }\n      }\n\n      function lazyload(opts) {\n        opts = merge({\n          'offset': 333,\n          'src': 'data-src',\n          'container': false\n        }, opts || {});\n\n        if (typeof opts.src === 'string') {\n          registerLazyAttr(opts.src);\n        }\n\n        var elts = [];\n\n        function show(elt) {\n          var src = findRealSrc(elt);\n\n          if (src) {\n            elt.src = src;\n          }\n\n          elt.setAttribute('data-lzled', true);\n          elts[indexOf.call(elts, elt)] = null;\n        }\n\n        function findRealSrc(elt) {\n          if (typeof opts.src === 'function') {\n            return opts.src(elt);\n          }\n\n          return elt.getAttribute(opts.src);\n        }\n\n        function register(elt) {\n          elt.onload = null;\n          elt.removeAttribute('onload');\n          elt.onerror = null;\n          elt.removeAttribute('onerror');\n\n          if (indexOf.call(elts, elt) === -1) {\n            inViewport(elt, opts, show);\n          }\n        }\n\n        return register;\n      }\n\n      function replaceGetAttribute(elementName) {\n        var fullname = 'HTML' + elementName + 'Element';\n        if (fullname in global === false) {\n          return;\n        }\n\n        var original = global[fullname].prototype.getAttribute;\n        global[fullname].prototype.getAttribute = function(name) {\n          if (name === 'src') {\n            var realSrc;\n            for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n              realSrc = original.call(this, lazyAttrs[i]);\n              if (realSrc) {\n                break;\n              }\n            }\n\n            return realSrc || original.call(this, name);\n          }\n\n          // our own lazyloader will go through theses lines\n          // because we use getAttribute(opts.src)\n          return original.call(this, name);\n        };\n      }\n\n      function merge(defaults, opts) {\n        for (var name in defaults) {\n          if (opts[name] === undefined) {\n            opts[name] = defaults[name];\n          }\n        }\n\n        return opts;\n      }\n\n      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n      function indexOf(value) {\n        for (var i = this.length; i-- && this[i] !== value;) {}\n        return i;\n      }\n\n      module.exports = lazyload;\n\n      // export default impush;\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  },\n  /* 2 */\n  /***/\n  function(module, exports) {\n\n    'use strict';\n\n    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n      // parse slide data (url, title, size ...) from DOM elements \n      // (children of gallerySelector)\n      var parseThumbnailElements = function parseThumbnailElements(el) {\n        el = el.parentNode.parentNode;\n        var thumbElements = el.getElementsByClassName('thumb'),\n          numNodes = thumbElements.length,\n          items = [],\n          figureEl,\n          linkEl,\n          size,\n          type,\n          // video or not\n          target,\n          item;\n\n        for (var i = 0; i < numNodes; i++) {\n\n          figureEl = thumbElements[i]; // \n\n          // include only element nodes \n          if (figureEl.nodeType !== 1) {\n            continue;\n          }\n\n          linkEl = figureEl.children[0]; // \n\n          size = linkEl.getAttribute('data-size').split('x');\n          type = linkEl.getAttribute('data-type');\n          target = linkEl.getAttribute('data-target');\n          // create slide object\n          item = {\n            src: linkEl.getAttribute('href'),\n            w: parseInt(size[0], 10),\n            h: parseInt(size[1], 10)\n          };\n\n          if (figureEl.children.length > 1) {\n            item.title = figureEl.children[1].innerHTML;\n          }\n\n          if (linkEl.children.length > 0) {\n            item.msrc = linkEl.children[0].getAttribute('src');\n            item.type = type;\n            item.target = target;\n            item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n            if (type === 'video') {\n              //item.src = null;\n            }\n          }\n\n          item.el = figureEl; // save link to element for getThumbBoundsFn\n          items.push(item);\n        }\n\n        return items;\n      };\n\n      // find nearest parent element\n      var closest = function closest(el, fn) {\n        return el && (fn(el) ? el : closest(el.parentNode, fn));\n      };\n\n      // triggers when user clicks on thumbnail\n      var onThumbnailsClick = function onThumbnailsClick(e) {\n        e = e || window.event;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n        var eTarget = e.target || e.srcElement;\n\n        // find root element of slide\n        var clickedListItem = closest(eTarget, function(el) {\n          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n        });\n\n        if (!clickedListItem) {\n          return;\n        }\n\n        // find index of clicked item by looping through all child nodes\n        // alternatively, you may define index via data- attribute\n        var clickedGallery = clickedListItem.parentNode,\n\n          // childNodes = clickedListItem.parentNode.childNodes,\n          // numChildNodes = childNodes.length,\n          childNodes = document.getElementsByClassName('thumb'),\n          numChildNodes = childNodes.length,\n          nodeIndex = 0,\n          index;\n\n        for (var i = 0; i < numChildNodes; i++) {\n          if (childNodes[i].nodeType !== 1) {\n            continue;\n          }\n\n          if (childNodes[i] === clickedListItem) {\n            index = nodeIndex;\n            break;\n          }\n          nodeIndex++;\n        }\n\n        if (index >= 0) {\n          // open PhotoSwipe if valid index found\n          openPhotoSwipe(index, clickedGallery);\n        }\n        return false;\n      };\n\n      // parse picture index and gallery index from URL (#&pid=1&gid=2)\n      var photoswipeParseHash = function photoswipeParseHash() {\n        var hash = window.location.hash.substring(1),\n          params = {};\n\n        if (hash.length < 5) {\n          return params;\n        }\n\n        var vars = hash.split('&');\n        for (var i = 0; i < vars.length; i++) {\n          if (!vars[i]) {\n            continue;\n          }\n          var pair = vars[i].split('=');\n          if (pair.length < 2) {\n            continue;\n          }\n          params[pair[0]] = pair[1];\n        }\n\n        if (params.gid) {\n          params.gid = parseInt(params.gid, 10);\n        }\n\n        return params;\n      };\n\n      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n        var pswpElement = document.querySelectorAll('.pswp')[0],\n          gallery,\n          options,\n          items;\n\n        items = parseThumbnailElements(galleryElement);\n        // define options (if needed)\n        options = {\n\n          // define gallery index (for URL)\n          galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n          getThumbBoundsFn: function getThumbBoundsFn(index) {\n            // See Options -> getThumbBoundsFn section of documentation for more info\n            var thumbnail = items[index].el.getElementsByTagName('img')[0],\n              // find thumbnail\n              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n              rect = thumbnail.getBoundingClientRect();\n\n            return {\n              x: rect.left,\n              y: rect.top + pageYScroll,\n              w: rect.width\n            };\n          }\n\n        };\n\n        // PhotoSwipe opened from URL\n        if (fromURL) {\n          if (options.galleryPIDs) {\n            // parse real index when custom PIDs are used \n            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n            for (var j = 0; j < items.length; j++) {\n              if (items[j].pid == index) {\n                options.index = j;\n                break;\n              }\n            }\n          } else {\n            // in URL indexes start from 1\n            options.index = parseInt(index, 10) - 1;\n          }\n        } else {\n          options.index = parseInt(index, 10);\n        }\n\n        // exit if index not found\n        if (isNaN(options.index)) {\n          return;\n        }\n\n        if (disableAnimation) {\n          options.showAnimationDuration = 0;\n        }\n\n        // Pass data to PhotoSwipe and initialize it\n        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n        gallery.init();\n\n        var $tempVideo;\n        var stopVideoHandle = function stopVideoHandle() {\n          if ($tempVideo) {\n            $tempVideo.remove();\n            $tempVideo = null;\n          }\n        };\n        var changeHandle = function changeHandle() {\n          var item = gallery.currItem;\n          stopVideoHandle();\n          if (item.type === 'video') {\n            var $ctn = item.container;\n            var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n            var $video = document.createElement('video');\n            $video.setAttribute('autoplay', 'autoplay');\n            $video.setAttribute('controls', 'controls');\n            $video.setAttribute('src', item.target);\n            $video.style.width = style.width;\n            $video.style.height = style.height;\n            $video.style.position = 'absolute';\n            $video.style.zIndex = 2;\n            $tempVideo = $video;\n            $ctn.appendChild($video);\n          }\n        };\n        gallery.listen('initialZoomIn', changeHandle);\n        gallery.listen('afterChange', changeHandle);\n        gallery.listen('initialZoomOut', stopVideoHandle);\n      };\n\n      // loop through all gallery elements and bind events\n      var galleryElements = document.querySelectorAll(gallerySelector);\n      for (var i = 0, l = galleryElements.length; i < l; i++) {\n        galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n        galleryElements[i].onclick = onThumbnailsClick;\n      }\n\n      // Parse URL and open gallery if it contains #&pid=3&gid=1\n      var hashData = photoswipeParseHash();\n      if (hashData.pid && hashData.gid) {\n        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n      }\n    };\n\n    var Viewer = function() {\n      function init() {\n        initPhotoSwipeFromDOM('.photos');\n      }\n      return {\n        init: init\n      };\n    }();\n\n    module.exports = Viewer;\n\n    /***/\n  },\n  /* 3 */\n  /***/\n  function(module, exports) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      module.exports = inViewport;\n\n      var instances = [];\n      var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n      function inViewport(elt, params, cb) {\n        var opts = {\n          container: global.document.body,\n          offset: 0\n        };\n\n        if (params === undefined || typeof params === 'function') {\n          cb = params;\n          params = {};\n        }\n\n        var container = opts.container = params.container || opts.container;\n        var offset = opts.offset = params.offset || opts.offset;\n\n        for (var i = 0; i < instances.length; i++) {\n          if (instances[i].container === container) {\n            return instances[i].isInViewport(elt, offset, cb);\n          }\n        }\n\n        return instances[\n          instances.push(createInViewport(container)) - 1\n        ].isInViewport(elt, offset, cb);\n      }\n\n      function addEvent(el, type, fn) {\n        if (el.attachEvent) {\n          el.attachEvent('on' + type, fn);\n        } else {\n          el.addEventListener(type, fn, false);\n        }\n      }\n\n      function debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this,\n            args = arguments;\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n          if (callNow) func.apply(context, args);\n\n          function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          }\n        };\n      }\n\n      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n      var contains = function() {\n        if (!global.document) {\n          return true;\n        }\n        return global.document.documentElement.compareDocumentPosition ?\n          function(a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          } :\n          global.document.documentElement.contains ?\n          function(a, b) {\n            return a !== b && (a.contains ? a.contains(b) : false);\n          } :\n          function(a, b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n      }\n\n      function createInViewport(container) {\n        var watches = createWatches();\n\n        var scrollContainer = container === global.document.body ? global : container;\n        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n        addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n        if (scrollContainer === global) {\n          addEvent(global, 'resize', debouncedCheck);\n        }\n\n        if (supportsMutationObserver) {\n          observeDOM(watches, container, debouncedCheck);\n        }\n\n        // failsafe check, every 200ms we check for visible images\n        // usecase: a hidden parent containing eleements\n        // when the parent becomes visible, we have no event that the children\n        // became visible\n        setInterval(debouncedCheck, 150);\n\n        function isInViewport(elt, offset, cb) {\n          if (!cb) {\n            return isVisible(elt, offset);\n          }\n\n          var remote = createRemote(elt, offset, cb);\n          remote.watch();\n          return remote;\n        }\n\n        function createRemote(elt, offset, cb) {\n          function watch() {\n            watches.add(elt, offset, cb);\n          }\n\n          function dispose() {\n            watches.remove(elt);\n          }\n\n          return {\n            watch: watch,\n            dispose: dispose\n          };\n        }\n\n        function watchInViewport(elt, offset, cb) {\n          if (isVisible(elt, offset)) {\n            watches.remove(elt);\n            cb(elt);\n          }\n        }\n\n        function isVisible(elt, offset) {\n          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n            return false;\n          }\n\n          // Check if the element is visible\n          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n          if (!elt.offsetWidth || !elt.offsetHeight) {\n            return false;\n          }\n\n          var eltRect = elt.getBoundingClientRect();\n          var viewport = {};\n\n          if (container === global.document.body) {\n            viewport = {\n              top: -offset,\n              left: -offset,\n              right: global.document.documentElement.clientWidth + offset,\n              bottom: global.document.documentElement.clientHeight + offset\n            };\n          } else {\n            var containerRect = container.getBoundingClientRect();\n            viewport = {\n              top: containerRect.top - offset,\n              left: containerRect.left - offset,\n              right: containerRect.right + offset,\n              bottom: containerRect.bottom + offset\n            };\n          }\n\n          // The element must overlap with the visible part of the viewport\n          var visible =\n            (\n              (eltRect.right > viewport.left) &&\n              (eltRect.left < viewport.right) &&\n              (eltRect.bottom > viewport.top) &&\n              (eltRect.top < viewport.bottom)\n            );\n\n          return visible;\n        }\n\n        return {\n          container: container,\n          isInViewport: isInViewport\n        };\n      }\n\n      function createWatches() {\n        var watches = [];\n\n        function add(elt, offset, cb) {\n          if (!isWatched(elt)) {\n            watches.push([elt, offset, cb]);\n          }\n        }\n\n        function remove(elt) {\n          var pos = indexOf(elt);\n          if (pos !== -1) {\n            watches.splice(pos, 1);\n          }\n        }\n\n        function indexOf(elt) {\n          for (var i = watches.length - 1; i >= 0; i--) {\n            if (watches[i][0] === elt) {\n              return i;\n            }\n          }\n          return -1;\n        }\n\n        function isWatched(elt) {\n          return indexOf(elt) !== -1;\n        }\n\n        function checkAll(cb) {\n          return function() {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              cb.apply(this, watches[i]);\n            }\n          };\n        }\n\n        return {\n          add: add,\n          remove: remove,\n          isWatched: isWatched,\n          checkAll: checkAll\n        };\n      }\n\n      function observeDOM(watches, container, cb) {\n        var observer = new MutationObserver(watch);\n        var filter = Array.prototype.filter;\n        var concat = Array.prototype.concat;\n\n        observer.observe(container, {\n          childList: true,\n          subtree: true,\n          // changes like style/width/height/display will be catched\n          attributes: true\n        });\n\n        function watch(mutations) {\n          // some new DOM nodes where previously watched\n          // we should check their positions\n          if (mutations.some(knownNodes) === true) {\n            setTimeout(cb, 0);\n          }\n        }\n\n        function knownNodes(mutation) {\n          var nodes = concat.call([],\n            Array.prototype.slice.call(mutation.addedNodes),\n            mutation.target\n          );\n          return filter.call(nodes, watches.isWatched).length > 0;\n        }\n      }\n\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  }\n  /******/\n]);","date":"2021-10-13T17:23:58.633Z","updated":"2021-10-13T17:23:58.633Z","path":"photos/static/ins.js","layout":"false","title":"","comments":1,"_id":"clb218l4a000964rgg0sc9u4o","content":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n    /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n        /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n/************************************************************************/\n/******/\n([\n  /* 0 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    'use strict';\n\n    __webpack_require__(1);\n\n    var _view = __webpack_require__(2);\n\n    var _view2 = _interopRequireDefault(_view);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    /**\n     * @name impush-client \n     * @description 这个项目让我发家致富…\n     * @date 2016-12-1\n     */\n\n    var _collection = [];\n    var _count = 0;\n    var searchData;\n\n    function addMask(elem) {\n      var rect = elem.getBoundingClientRect();\n      var style = getComputedStyle(elem, null);\n\n      var mask = document.createElement('i');\n      mask.className = 'icon-film';\n      mask.style.color = '#fff';\n      mask.style.fontSize = '26px';\n      mask.style.position = 'absolute';\n      mask.style.right = '10px';\n      mask.style.bottom = '10px';\n      mask.style.zIndex = 1;\n      elem.parentNode.appendChild(mask);\n    }\n\n    var createVideoIncon = function createVideoIncon() {\n      var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n      for (var i = 0, len = $videoImg.length; i < len; i++) {\n        addMask($videoImg[i]);\n      }\n    };\n    var render = function render(res) {\n      var ulTmpl = \"\";\n      for (var j = 0, len2 = res.list.length; j < len2; j++) {\n        var data = res.list[j].arr;\n        var liTmpl = \"\";\n        for (var i = 0, len = data.link.length; i < len; i++) {\n          var minSrc = 'https://qiniu.findn.cn/blog/photos/min_photos/' + data.link[i];\n          var src = 'https://qiniu.findn.cn/blog/photos/photos/' + data.link[i];\n          var type = data.type[i];\n          var target = src + (type === 'video' ? '.mp4' : '.jpg');\n          src += '';\n\n          liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/photos/static/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n        }\n        ulTmpl = ulTmpl + '<section class=\"album\"><h1 class=\"year\">' + data.year + '年<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n      }\n      document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n      createVideoIncon();\n      _view2.default.init();\n    };\n\n    var replacer = function replacer(str) {\n      var arr = str.split(\"/\");\n      return \"/assets/ins/\" + arr[arr.length - 1];\n    };\n\n    var ctrler = function ctrler(data) {\n      var imgObj = {};\n      for (var i = 0, len = data.length; i < len; i++) {\n        var y = data[i].y;\n        var m = data[i].m;\n        var src = replacer(data[i].src);\n        var text = data[i].text;\n        var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n        if (imgObj[key]) {\n          imgObj[key].srclist.push(src);\n          imgObj[key].text.push(text);\n        } else {\n          imgObj[key] = {\n            year: y,\n            month: m,\n            srclist: [src],\n            text: [text]\n          };\n        }\n      }\n      render(imgObj);\n    };\n\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './data.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n\n    Ins.init();\n\n    // export default impush;\n\n    /***/\n  },\n  /* 1 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      'use strict';\n\n      var inViewport = __webpack_require__(3);\n      var lazyAttrs = ['data-src'];\n\n      global.lzld = lazyload();\n\n      // Provide libs using getAttribute early to get the good src\n      // and not the fake data-src\n      replaceGetAttribute('Image');\n      replaceGetAttribute('IFrame');\n\n      function registerLazyAttr(attr) {\n        if (indexOf.call(lazyAttrs, attr) === -1) {\n          lazyAttrs.push(attr);\n        }\n      }\n\n      function lazyload(opts) {\n        opts = merge({\n          'offset': 333,\n          'src': 'data-src',\n          'container': false\n        }, opts || {});\n\n        if (typeof opts.src === 'string') {\n          registerLazyAttr(opts.src);\n        }\n\n        var elts = [];\n\n        function show(elt) {\n          var src = findRealSrc(elt);\n\n          if (src) {\n            elt.src = src;\n          }\n\n          elt.setAttribute('data-lzled', true);\n          elts[indexOf.call(elts, elt)] = null;\n        }\n\n        function findRealSrc(elt) {\n          if (typeof opts.src === 'function') {\n            return opts.src(elt);\n          }\n\n          return elt.getAttribute(opts.src);\n        }\n\n        function register(elt) {\n          elt.onload = null;\n          elt.removeAttribute('onload');\n          elt.onerror = null;\n          elt.removeAttribute('onerror');\n\n          if (indexOf.call(elts, elt) === -1) {\n            inViewport(elt, opts, show);\n          }\n        }\n\n        return register;\n      }\n\n      function replaceGetAttribute(elementName) {\n        var fullname = 'HTML' + elementName + 'Element';\n        if (fullname in global === false) {\n          return;\n        }\n\n        var original = global[fullname].prototype.getAttribute;\n        global[fullname].prototype.getAttribute = function(name) {\n          if (name === 'src') {\n            var realSrc;\n            for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n              realSrc = original.call(this, lazyAttrs[i]);\n              if (realSrc) {\n                break;\n              }\n            }\n\n            return realSrc || original.call(this, name);\n          }\n\n          // our own lazyloader will go through theses lines\n          // because we use getAttribute(opts.src)\n          return original.call(this, name);\n        };\n      }\n\n      function merge(defaults, opts) {\n        for (var name in defaults) {\n          if (opts[name] === undefined) {\n            opts[name] = defaults[name];\n          }\n        }\n\n        return opts;\n      }\n\n      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n      function indexOf(value) {\n        for (var i = this.length; i-- && this[i] !== value;) {}\n        return i;\n      }\n\n      module.exports = lazyload;\n\n      // export default impush;\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  },\n  /* 2 */\n  /***/\n  function(module, exports) {\n\n    'use strict';\n\n    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n      // parse slide data (url, title, size ...) from DOM elements \n      // (children of gallerySelector)\n      var parseThumbnailElements = function parseThumbnailElements(el) {\n        el = el.parentNode.parentNode;\n        var thumbElements = el.getElementsByClassName('thumb'),\n          numNodes = thumbElements.length,\n          items = [],\n          figureEl,\n          linkEl,\n          size,\n          type,\n          // video or not\n          target,\n          item;\n\n        for (var i = 0; i < numNodes; i++) {\n\n          figureEl = thumbElements[i]; // \n\n          // include only element nodes \n          if (figureEl.nodeType !== 1) {\n            continue;\n          }\n\n          linkEl = figureEl.children[0]; // \n\n          size = linkEl.getAttribute('data-size').split('x');\n          type = linkEl.getAttribute('data-type');\n          target = linkEl.getAttribute('data-target');\n          // create slide object\n          item = {\n            src: linkEl.getAttribute('href'),\n            w: parseInt(size[0], 10),\n            h: parseInt(size[1], 10)\n          };\n\n          if (figureEl.children.length > 1) {\n            item.title = figureEl.children[1].innerHTML;\n          }\n\n          if (linkEl.children.length > 0) {\n            item.msrc = linkEl.children[0].getAttribute('src');\n            item.type = type;\n            item.target = target;\n            item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n            if (type === 'video') {\n              //item.src = null;\n            }\n          }\n\n          item.el = figureEl; // save link to element for getThumbBoundsFn\n          items.push(item);\n        }\n\n        return items;\n      };\n\n      // find nearest parent element\n      var closest = function closest(el, fn) {\n        return el && (fn(el) ? el : closest(el.parentNode, fn));\n      };\n\n      // triggers when user clicks on thumbnail\n      var onThumbnailsClick = function onThumbnailsClick(e) {\n        e = e || window.event;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n        var eTarget = e.target || e.srcElement;\n\n        // find root element of slide\n        var clickedListItem = closest(eTarget, function(el) {\n          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n        });\n\n        if (!clickedListItem) {\n          return;\n        }\n\n        // find index of clicked item by looping through all child nodes\n        // alternatively, you may define index via data- attribute\n        var clickedGallery = clickedListItem.parentNode,\n\n          // childNodes = clickedListItem.parentNode.childNodes,\n          // numChildNodes = childNodes.length,\n          childNodes = document.getElementsByClassName('thumb'),\n          numChildNodes = childNodes.length,\n          nodeIndex = 0,\n          index;\n\n        for (var i = 0; i < numChildNodes; i++) {\n          if (childNodes[i].nodeType !== 1) {\n            continue;\n          }\n\n          if (childNodes[i] === clickedListItem) {\n            index = nodeIndex;\n            break;\n          }\n          nodeIndex++;\n        }\n\n        if (index >= 0) {\n          // open PhotoSwipe if valid index found\n          openPhotoSwipe(index, clickedGallery);\n        }\n        return false;\n      };\n\n      // parse picture index and gallery index from URL (#&pid=1&gid=2)\n      var photoswipeParseHash = function photoswipeParseHash() {\n        var hash = window.location.hash.substring(1),\n          params = {};\n\n        if (hash.length < 5) {\n          return params;\n        }\n\n        var vars = hash.split('&');\n        for (var i = 0; i < vars.length; i++) {\n          if (!vars[i]) {\n            continue;\n          }\n          var pair = vars[i].split('=');\n          if (pair.length < 2) {\n            continue;\n          }\n          params[pair[0]] = pair[1];\n        }\n\n        if (params.gid) {\n          params.gid = parseInt(params.gid, 10);\n        }\n\n        return params;\n      };\n\n      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n        var pswpElement = document.querySelectorAll('.pswp')[0],\n          gallery,\n          options,\n          items;\n\n        items = parseThumbnailElements(galleryElement);\n        // define options (if needed)\n        options = {\n\n          // define gallery index (for URL)\n          galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n          getThumbBoundsFn: function getThumbBoundsFn(index) {\n            // See Options -> getThumbBoundsFn section of documentation for more info\n            var thumbnail = items[index].el.getElementsByTagName('img')[0],\n              // find thumbnail\n              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n              rect = thumbnail.getBoundingClientRect();\n\n            return {\n              x: rect.left,\n              y: rect.top + pageYScroll,\n              w: rect.width\n            };\n          }\n\n        };\n\n        // PhotoSwipe opened from URL\n        if (fromURL) {\n          if (options.galleryPIDs) {\n            // parse real index when custom PIDs are used \n            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n            for (var j = 0; j < items.length; j++) {\n              if (items[j].pid == index) {\n                options.index = j;\n                break;\n              }\n            }\n          } else {\n            // in URL indexes start from 1\n            options.index = parseInt(index, 10) - 1;\n          }\n        } else {\n          options.index = parseInt(index, 10);\n        }\n\n        // exit if index not found\n        if (isNaN(options.index)) {\n          return;\n        }\n\n        if (disableAnimation) {\n          options.showAnimationDuration = 0;\n        }\n\n        // Pass data to PhotoSwipe and initialize it\n        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n        gallery.init();\n\n        var $tempVideo;\n        var stopVideoHandle = function stopVideoHandle() {\n          if ($tempVideo) {\n            $tempVideo.remove();\n            $tempVideo = null;\n          }\n        };\n        var changeHandle = function changeHandle() {\n          var item = gallery.currItem;\n          stopVideoHandle();\n          if (item.type === 'video') {\n            var $ctn = item.container;\n            var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n            var $video = document.createElement('video');\n            $video.setAttribute('autoplay', 'autoplay');\n            $video.setAttribute('controls', 'controls');\n            $video.setAttribute('src', item.target);\n            $video.style.width = style.width;\n            $video.style.height = style.height;\n            $video.style.position = 'absolute';\n            $video.style.zIndex = 2;\n            $tempVideo = $video;\n            $ctn.appendChild($video);\n          }\n        };\n        gallery.listen('initialZoomIn', changeHandle);\n        gallery.listen('afterChange', changeHandle);\n        gallery.listen('initialZoomOut', stopVideoHandle);\n      };\n\n      // loop through all gallery elements and bind events\n      var galleryElements = document.querySelectorAll(gallerySelector);\n      for (var i = 0, l = galleryElements.length; i < l; i++) {\n        galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n        galleryElements[i].onclick = onThumbnailsClick;\n      }\n\n      // Parse URL and open gallery if it contains #&pid=3&gid=1\n      var hashData = photoswipeParseHash();\n      if (hashData.pid && hashData.gid) {\n        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n      }\n    };\n\n    var Viewer = function() {\n      function init() {\n        initPhotoSwipeFromDOM('.photos');\n      }\n      return {\n        init: init\n      };\n    }();\n\n    module.exports = Viewer;\n\n    /***/\n  },\n  /* 3 */\n  /***/\n  function(module, exports) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      module.exports = inViewport;\n\n      var instances = [];\n      var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n      function inViewport(elt, params, cb) {\n        var opts = {\n          container: global.document.body,\n          offset: 0\n        };\n\n        if (params === undefined || typeof params === 'function') {\n          cb = params;\n          params = {};\n        }\n\n        var container = opts.container = params.container || opts.container;\n        var offset = opts.offset = params.offset || opts.offset;\n\n        for (var i = 0; i < instances.length; i++) {\n          if (instances[i].container === container) {\n            return instances[i].isInViewport(elt, offset, cb);\n          }\n        }\n\n        return instances[\n          instances.push(createInViewport(container)) - 1\n        ].isInViewport(elt, offset, cb);\n      }\n\n      function addEvent(el, type, fn) {\n        if (el.attachEvent) {\n          el.attachEvent('on' + type, fn);\n        } else {\n          el.addEventListener(type, fn, false);\n        }\n      }\n\n      function debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this,\n            args = arguments;\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n          if (callNow) func.apply(context, args);\n\n          function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          }\n        };\n      }\n\n      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n      var contains = function() {\n        if (!global.document) {\n          return true;\n        }\n        return global.document.documentElement.compareDocumentPosition ?\n          function(a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          } :\n          global.document.documentElement.contains ?\n          function(a, b) {\n            return a !== b && (a.contains ? a.contains(b) : false);\n          } :\n          function(a, b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n      }\n\n      function createInViewport(container) {\n        var watches = createWatches();\n\n        var scrollContainer = container === global.document.body ? global : container;\n        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n        addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n        if (scrollContainer === global) {\n          addEvent(global, 'resize', debouncedCheck);\n        }\n\n        if (supportsMutationObserver) {\n          observeDOM(watches, container, debouncedCheck);\n        }\n\n        // failsafe check, every 200ms we check for visible images\n        // usecase: a hidden parent containing eleements\n        // when the parent becomes visible, we have no event that the children\n        // became visible\n        setInterval(debouncedCheck, 150);\n\n        function isInViewport(elt, offset, cb) {\n          if (!cb) {\n            return isVisible(elt, offset);\n          }\n\n          var remote = createRemote(elt, offset, cb);\n          remote.watch();\n          return remote;\n        }\n\n        function createRemote(elt, offset, cb) {\n          function watch() {\n            watches.add(elt, offset, cb);\n          }\n\n          function dispose() {\n            watches.remove(elt);\n          }\n\n          return {\n            watch: watch,\n            dispose: dispose\n          };\n        }\n\n        function watchInViewport(elt, offset, cb) {\n          if (isVisible(elt, offset)) {\n            watches.remove(elt);\n            cb(elt);\n          }\n        }\n\n        function isVisible(elt, offset) {\n          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n            return false;\n          }\n\n          // Check if the element is visible\n          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n          if (!elt.offsetWidth || !elt.offsetHeight) {\n            return false;\n          }\n\n          var eltRect = elt.getBoundingClientRect();\n          var viewport = {};\n\n          if (container === global.document.body) {\n            viewport = {\n              top: -offset,\n              left: -offset,\n              right: global.document.documentElement.clientWidth + offset,\n              bottom: global.document.documentElement.clientHeight + offset\n            };\n          } else {\n            var containerRect = container.getBoundingClientRect();\n            viewport = {\n              top: containerRect.top - offset,\n              left: containerRect.left - offset,\n              right: containerRect.right + offset,\n              bottom: containerRect.bottom + offset\n            };\n          }\n\n          // The element must overlap with the visible part of the viewport\n          var visible =\n            (\n              (eltRect.right > viewport.left) &&\n              (eltRect.left < viewport.right) &&\n              (eltRect.bottom > viewport.top) &&\n              (eltRect.top < viewport.bottom)\n            );\n\n          return visible;\n        }\n\n        return {\n          container: container,\n          isInViewport: isInViewport\n        };\n      }\n\n      function createWatches() {\n        var watches = [];\n\n        function add(elt, offset, cb) {\n          if (!isWatched(elt)) {\n            watches.push([elt, offset, cb]);\n          }\n        }\n\n        function remove(elt) {\n          var pos = indexOf(elt);\n          if (pos !== -1) {\n            watches.splice(pos, 1);\n          }\n        }\n\n        function indexOf(elt) {\n          for (var i = watches.length - 1; i >= 0; i--) {\n            if (watches[i][0] === elt) {\n              return i;\n            }\n          }\n          return -1;\n        }\n\n        function isWatched(elt) {\n          return indexOf(elt) !== -1;\n        }\n\n        function checkAll(cb) {\n          return function() {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              cb.apply(this, watches[i]);\n            }\n          };\n        }\n\n        return {\n          add: add,\n          remove: remove,\n          isWatched: isWatched,\n          checkAll: checkAll\n        };\n      }\n\n      function observeDOM(watches, container, cb) {\n        var observer = new MutationObserver(watch);\n        var filter = Array.prototype.filter;\n        var concat = Array.prototype.concat;\n\n        observer.observe(container, {\n          childList: true,\n          subtree: true,\n          // changes like style/width/height/display will be catched\n          attributes: true\n        });\n\n        function watch(mutations) {\n          // some new DOM nodes where previously watched\n          // we should check their positions\n          if (mutations.some(knownNodes) === true) {\n            setTimeout(cb, 0);\n          }\n        }\n\n        function knownNodes(mutation) {\n          var nodes = concat.call([],\n            Array.prototype.slice.call(mutation.addedNodes),\n            mutation.target\n          );\n          return filter.call(nodes, watches.isWatched).length > 0;\n        }\n      }\n\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  }\n  /******/\n]);","site":{"data":{}},"excerpt":"","more":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n    /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n        /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n/************************************************************************/\n/******/\n([\n  /* 0 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    'use strict';\n\n    __webpack_require__(1);\n\n    var _view = __webpack_require__(2);\n\n    var _view2 = _interopRequireDefault(_view);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    /**\n     * @name impush-client \n     * @description 这个项目让我发家致富…\n     * @date 2016-12-1\n     */\n\n    var _collection = [];\n    var _count = 0;\n    var searchData;\n\n    function addMask(elem) {\n      var rect = elem.getBoundingClientRect();\n      var style = getComputedStyle(elem, null);\n\n      var mask = document.createElement('i');\n      mask.className = 'icon-film';\n      mask.style.color = '#fff';\n      mask.style.fontSize = '26px';\n      mask.style.position = 'absolute';\n      mask.style.right = '10px';\n      mask.style.bottom = '10px';\n      mask.style.zIndex = 1;\n      elem.parentNode.appendChild(mask);\n    }\n\n    var createVideoIncon = function createVideoIncon() {\n      var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n      for (var i = 0, len = $videoImg.length; i < len; i++) {\n        addMask($videoImg[i]);\n      }\n    };\n    var render = function render(res) {\n      var ulTmpl = \"\";\n      for (var j = 0, len2 = res.list.length; j < len2; j++) {\n        var data = res.list[j].arr;\n        var liTmpl = \"\";\n        for (var i = 0, len = data.link.length; i < len; i++) {\n          var minSrc = 'https://qiniu.findn.cn/blog/photos/min_photos/' + data.link[i];\n          var src = 'https://qiniu.findn.cn/blog/photos/photos/' + data.link[i];\n          var type = data.type[i];\n          var target = src + (type === 'video' ? '.mp4' : '.jpg');\n          src += '';\n\n          liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/photos/static/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n        }\n        ulTmpl = ulTmpl + '<section class=\"album\"><h1 class=\"year\">' + data.year + '年<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n      }\n      document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n      createVideoIncon();\n      _view2.default.init();\n    };\n\n    var replacer = function replacer(str) {\n      var arr = str.split(\"/\");\n      return \"/assets/ins/\" + arr[arr.length - 1];\n    };\n\n    var ctrler = function ctrler(data) {\n      var imgObj = {};\n      for (var i = 0, len = data.length; i < len; i++) {\n        var y = data[i].y;\n        var m = data[i].m;\n        var src = replacer(data[i].src);\n        var text = data[i].text;\n        var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n        if (imgObj[key]) {\n          imgObj[key].srclist.push(src);\n          imgObj[key].text.push(text);\n        } else {\n          imgObj[key] = {\n            year: y,\n            month: m,\n            srclist: [src],\n            text: [text]\n          };\n        }\n      }\n      render(imgObj);\n    };\n\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './data.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n\n    Ins.init();\n\n    // export default impush;\n\n    /***/\n  },\n  /* 1 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      'use strict';\n\n      var inViewport = __webpack_require__(3);\n      var lazyAttrs = ['data-src'];\n\n      global.lzld = lazyload();\n\n      // Provide libs using getAttribute early to get the good src\n      // and not the fake data-src\n      replaceGetAttribute('Image');\n      replaceGetAttribute('IFrame');\n\n      function registerLazyAttr(attr) {\n        if (indexOf.call(lazyAttrs, attr) === -1) {\n          lazyAttrs.push(attr);\n        }\n      }\n\n      function lazyload(opts) {\n        opts = merge({\n          'offset': 333,\n          'src': 'data-src',\n          'container': false\n        }, opts || {});\n\n        if (typeof opts.src === 'string') {\n          registerLazyAttr(opts.src);\n        }\n\n        var elts = [];\n\n        function show(elt) {\n          var src = findRealSrc(elt);\n\n          if (src) {\n            elt.src = src;\n          }\n\n          elt.setAttribute('data-lzled', true);\n          elts[indexOf.call(elts, elt)] = null;\n        }\n\n        function findRealSrc(elt) {\n          if (typeof opts.src === 'function') {\n            return opts.src(elt);\n          }\n\n          return elt.getAttribute(opts.src);\n        }\n\n        function register(elt) {\n          elt.onload = null;\n          elt.removeAttribute('onload');\n          elt.onerror = null;\n          elt.removeAttribute('onerror');\n\n          if (indexOf.call(elts, elt) === -1) {\n            inViewport(elt, opts, show);\n          }\n        }\n\n        return register;\n      }\n\n      function replaceGetAttribute(elementName) {\n        var fullname = 'HTML' + elementName + 'Element';\n        if (fullname in global === false) {\n          return;\n        }\n\n        var original = global[fullname].prototype.getAttribute;\n        global[fullname].prototype.getAttribute = function(name) {\n          if (name === 'src') {\n            var realSrc;\n            for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n              realSrc = original.call(this, lazyAttrs[i]);\n              if (realSrc) {\n                break;\n              }\n            }\n\n            return realSrc || original.call(this, name);\n          }\n\n          // our own lazyloader will go through theses lines\n          // because we use getAttribute(opts.src)\n          return original.call(this, name);\n        };\n      }\n\n      function merge(defaults, opts) {\n        for (var name in defaults) {\n          if (opts[name] === undefined) {\n            opts[name] = defaults[name];\n          }\n        }\n\n        return opts;\n      }\n\n      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n      function indexOf(value) {\n        for (var i = this.length; i-- && this[i] !== value;) {}\n        return i;\n      }\n\n      module.exports = lazyload;\n\n      // export default impush;\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  },\n  /* 2 */\n  /***/\n  function(module, exports) {\n\n    'use strict';\n\n    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n      // parse slide data (url, title, size ...) from DOM elements \n      // (children of gallerySelector)\n      var parseThumbnailElements = function parseThumbnailElements(el) {\n        el = el.parentNode.parentNode;\n        var thumbElements = el.getElementsByClassName('thumb'),\n          numNodes = thumbElements.length,\n          items = [],\n          figureEl,\n          linkEl,\n          size,\n          type,\n          // video or not\n          target,\n          item;\n\n        for (var i = 0; i < numNodes; i++) {\n\n          figureEl = thumbElements[i]; // \n\n          // include only element nodes \n          if (figureEl.nodeType !== 1) {\n            continue;\n          }\n\n          linkEl = figureEl.children[0]; // \n\n          size = linkEl.getAttribute('data-size').split('x');\n          type = linkEl.getAttribute('data-type');\n          target = linkEl.getAttribute('data-target');\n          // create slide object\n          item = {\n            src: linkEl.getAttribute('href'),\n            w: parseInt(size[0], 10),\n            h: parseInt(size[1], 10)\n          };\n\n          if (figureEl.children.length > 1) {\n            item.title = figureEl.children[1].innerHTML;\n          }\n\n          if (linkEl.children.length > 0) {\n            item.msrc = linkEl.children[0].getAttribute('src');\n            item.type = type;\n            item.target = target;\n            item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n            if (type === 'video') {\n              //item.src = null;\n            }\n          }\n\n          item.el = figureEl; // save link to element for getThumbBoundsFn\n          items.push(item);\n        }\n\n        return items;\n      };\n\n      // find nearest parent element\n      var closest = function closest(el, fn) {\n        return el && (fn(el) ? el : closest(el.parentNode, fn));\n      };\n\n      // triggers when user clicks on thumbnail\n      var onThumbnailsClick = function onThumbnailsClick(e) {\n        e = e || window.event;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n        var eTarget = e.target || e.srcElement;\n\n        // find root element of slide\n        var clickedListItem = closest(eTarget, function(el) {\n          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n        });\n\n        if (!clickedListItem) {\n          return;\n        }\n\n        // find index of clicked item by looping through all child nodes\n        // alternatively, you may define index via data- attribute\n        var clickedGallery = clickedListItem.parentNode,\n\n          // childNodes = clickedListItem.parentNode.childNodes,\n          // numChildNodes = childNodes.length,\n          childNodes = document.getElementsByClassName('thumb'),\n          numChildNodes = childNodes.length,\n          nodeIndex = 0,\n          index;\n\n        for (var i = 0; i < numChildNodes; i++) {\n          if (childNodes[i].nodeType !== 1) {\n            continue;\n          }\n\n          if (childNodes[i] === clickedListItem) {\n            index = nodeIndex;\n            break;\n          }\n          nodeIndex++;\n        }\n\n        if (index >= 0) {\n          // open PhotoSwipe if valid index found\n          openPhotoSwipe(index, clickedGallery);\n        }\n        return false;\n      };\n\n      // parse picture index and gallery index from URL (#&pid=1&gid=2)\n      var photoswipeParseHash = function photoswipeParseHash() {\n        var hash = window.location.hash.substring(1),\n          params = {};\n\n        if (hash.length < 5) {\n          return params;\n        }\n\n        var vars = hash.split('&');\n        for (var i = 0; i < vars.length; i++) {\n          if (!vars[i]) {\n            continue;\n          }\n          var pair = vars[i].split('=');\n          if (pair.length < 2) {\n            continue;\n          }\n          params[pair[0]] = pair[1];\n        }\n\n        if (params.gid) {\n          params.gid = parseInt(params.gid, 10);\n        }\n\n        return params;\n      };\n\n      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n        var pswpElement = document.querySelectorAll('.pswp')[0],\n          gallery,\n          options,\n          items;\n\n        items = parseThumbnailElements(galleryElement);\n        // define options (if needed)\n        options = {\n\n          // define gallery index (for URL)\n          galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n          getThumbBoundsFn: function getThumbBoundsFn(index) {\n            // See Options -> getThumbBoundsFn section of documentation for more info\n            var thumbnail = items[index].el.getElementsByTagName('img')[0],\n              // find thumbnail\n              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n              rect = thumbnail.getBoundingClientRect();\n\n            return {\n              x: rect.left,\n              y: rect.top + pageYScroll,\n              w: rect.width\n            };\n          }\n\n        };\n\n        // PhotoSwipe opened from URL\n        if (fromURL) {\n          if (options.galleryPIDs) {\n            // parse real index when custom PIDs are used \n            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n            for (var j = 0; j < items.length; j++) {\n              if (items[j].pid == index) {\n                options.index = j;\n                break;\n              }\n            }\n          } else {\n            // in URL indexes start from 1\n            options.index = parseInt(index, 10) - 1;\n          }\n        } else {\n          options.index = parseInt(index, 10);\n        }\n\n        // exit if index not found\n        if (isNaN(options.index)) {\n          return;\n        }\n\n        if (disableAnimation) {\n          options.showAnimationDuration = 0;\n        }\n\n        // Pass data to PhotoSwipe and initialize it\n        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n        gallery.init();\n\n        var $tempVideo;\n        var stopVideoHandle = function stopVideoHandle() {\n          if ($tempVideo) {\n            $tempVideo.remove();\n            $tempVideo = null;\n          }\n        };\n        var changeHandle = function changeHandle() {\n          var item = gallery.currItem;\n          stopVideoHandle();\n          if (item.type === 'video') {\n            var $ctn = item.container;\n            var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n            var $video = document.createElement('video');\n            $video.setAttribute('autoplay', 'autoplay');\n            $video.setAttribute('controls', 'controls');\n            $video.setAttribute('src', item.target);\n            $video.style.width = style.width;\n            $video.style.height = style.height;\n            $video.style.position = 'absolute';\n            $video.style.zIndex = 2;\n            $tempVideo = $video;\n            $ctn.appendChild($video);\n          }\n        };\n        gallery.listen('initialZoomIn', changeHandle);\n        gallery.listen('afterChange', changeHandle);\n        gallery.listen('initialZoomOut', stopVideoHandle);\n      };\n\n      // loop through all gallery elements and bind events\n      var galleryElements = document.querySelectorAll(gallerySelector);\n      for (var i = 0, l = galleryElements.length; i < l; i++) {\n        galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n        galleryElements[i].onclick = onThumbnailsClick;\n      }\n\n      // Parse URL and open gallery if it contains #&pid=3&gid=1\n      var hashData = photoswipeParseHash();\n      if (hashData.pid && hashData.gid) {\n        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n      }\n    };\n\n    var Viewer = function() {\n      function init() {\n        initPhotoSwipeFromDOM('.photos');\n      }\n      return {\n        init: init\n      };\n    }();\n\n    module.exports = Viewer;\n\n    /***/\n  },\n  /* 3 */\n  /***/\n  function(module, exports) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      module.exports = inViewport;\n\n      var instances = [];\n      var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n      function inViewport(elt, params, cb) {\n        var opts = {\n          container: global.document.body,\n          offset: 0\n        };\n\n        if (params === undefined || typeof params === 'function') {\n          cb = params;\n          params = {};\n        }\n\n        var container = opts.container = params.container || opts.container;\n        var offset = opts.offset = params.offset || opts.offset;\n\n        for (var i = 0; i < instances.length; i++) {\n          if (instances[i].container === container) {\n            return instances[i].isInViewport(elt, offset, cb);\n          }\n        }\n\n        return instances[\n          instances.push(createInViewport(container)) - 1\n        ].isInViewport(elt, offset, cb);\n      }\n\n      function addEvent(el, type, fn) {\n        if (el.attachEvent) {\n          el.attachEvent('on' + type, fn);\n        } else {\n          el.addEventListener(type, fn, false);\n        }\n      }\n\n      function debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this,\n            args = arguments;\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n          if (callNow) func.apply(context, args);\n\n          function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          }\n        };\n      }\n\n      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n      var contains = function() {\n        if (!global.document) {\n          return true;\n        }\n        return global.document.documentElement.compareDocumentPosition ?\n          function(a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          } :\n          global.document.documentElement.contains ?\n          function(a, b) {\n            return a !== b && (a.contains ? a.contains(b) : false);\n          } :\n          function(a, b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n      }\n\n      function createInViewport(container) {\n        var watches = createWatches();\n\n        var scrollContainer = container === global.document.body ? global : container;\n        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n        addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n        if (scrollContainer === global) {\n          addEvent(global, 'resize', debouncedCheck);\n        }\n\n        if (supportsMutationObserver) {\n          observeDOM(watches, container, debouncedCheck);\n        }\n\n        // failsafe check, every 200ms we check for visible images\n        // usecase: a hidden parent containing eleements\n        // when the parent becomes visible, we have no event that the children\n        // became visible\n        setInterval(debouncedCheck, 150);\n\n        function isInViewport(elt, offset, cb) {\n          if (!cb) {\n            return isVisible(elt, offset);\n          }\n\n          var remote = createRemote(elt, offset, cb);\n          remote.watch();\n          return remote;\n        }\n\n        function createRemote(elt, offset, cb) {\n          function watch() {\n            watches.add(elt, offset, cb);\n          }\n\n          function dispose() {\n            watches.remove(elt);\n          }\n\n          return {\n            watch: watch,\n            dispose: dispose\n          };\n        }\n\n        function watchInViewport(elt, offset, cb) {\n          if (isVisible(elt, offset)) {\n            watches.remove(elt);\n            cb(elt);\n          }\n        }\n\n        function isVisible(elt, offset) {\n          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n            return false;\n          }\n\n          // Check if the element is visible\n          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n          if (!elt.offsetWidth || !elt.offsetHeight) {\n            return false;\n          }\n\n          var eltRect = elt.getBoundingClientRect();\n          var viewport = {};\n\n          if (container === global.document.body) {\n            viewport = {\n              top: -offset,\n              left: -offset,\n              right: global.document.documentElement.clientWidth + offset,\n              bottom: global.document.documentElement.clientHeight + offset\n            };\n          } else {\n            var containerRect = container.getBoundingClientRect();\n            viewport = {\n              top: containerRect.top - offset,\n              left: containerRect.left - offset,\n              right: containerRect.right + offset,\n              bottom: containerRect.bottom + offset\n            };\n          }\n\n          // The element must overlap with the visible part of the viewport\n          var visible =\n            (\n              (eltRect.right > viewport.left) &&\n              (eltRect.left < viewport.right) &&\n              (eltRect.bottom > viewport.top) &&\n              (eltRect.top < viewport.bottom)\n            );\n\n          return visible;\n        }\n\n        return {\n          container: container,\n          isInViewport: isInViewport\n        };\n      }\n\n      function createWatches() {\n        var watches = [];\n\n        function add(elt, offset, cb) {\n          if (!isWatched(elt)) {\n            watches.push([elt, offset, cb]);\n          }\n        }\n\n        function remove(elt) {\n          var pos = indexOf(elt);\n          if (pos !== -1) {\n            watches.splice(pos, 1);\n          }\n        }\n\n        function indexOf(elt) {\n          for (var i = watches.length - 1; i >= 0; i--) {\n            if (watches[i][0] === elt) {\n              return i;\n            }\n          }\n          return -1;\n        }\n\n        function isWatched(elt) {\n          return indexOf(elt) !== -1;\n        }\n\n        function checkAll(cb) {\n          return function() {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              cb.apply(this, watches[i]);\n            }\n          };\n        }\n\n        return {\n          add: add,\n          remove: remove,\n          isWatched: isWatched,\n          checkAll: checkAll\n        };\n      }\n\n      function observeDOM(watches, container, cb) {\n        var observer = new MutationObserver(watch);\n        var filter = Array.prototype.filter;\n        var concat = Array.prototype.concat;\n\n        observer.observe(container, {\n          childList: true,\n          subtree: true,\n          // changes like style/width/height/display will be catched\n          attributes: true\n        });\n\n        function watch(mutations) {\n          // some new DOM nodes where previously watched\n          // we should check their positions\n          if (mutations.some(knownNodes) === true) {\n            setTimeout(cb, 0);\n          }\n        }\n\n        function knownNodes(mutation) {\n          var nodes = concat.call([],\n            Array.prototype.slice.call(mutation.addedNodes),\n            mutation.target\n          );\n          return filter.call(nodes, watches.isWatched).length > 0;\n        }\n      }\n\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  }\n  /******/\n]);"}],"Post":[{"title":"LeetCode刷题 Day3 链表 | 203.移除链表元素 707.设计链表 206.反转链表","article_type":0,"abbrlink":"8fa119fc","date":"2022-11-21T16:00:00.000Z","_content":"\n- LeetCode 203.移除链表元素\n- LeetCode 707.设计链表\n- LeetCode 206.反转链表\n\n<!-- more -->\n\n## 203.移除链表元素\n\n> [力扣题目链接](https://leetcode.cn/problems/remove-linked-list-elements/)\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n\n示例 1：\n```\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n```\n\n示例 2：\n```\n输入：head = [7,7,7,7], val = 7\n输出：[]\n```\n\n### 思路\n\n在单链表中 删除头结点 和 删除其他结点 的操作方式是不一样（删除其他结点时，都是通过该结点的前一个结点来删除该节点）。\n\n> 设置虚拟头结点来统一删除操作\n\n- 这样删除头结点和中间结点就变得统一起来，不用分情况讨论。\n\n### python代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        dummy_head = ListNode(next=head)  # 设置一个虚拟头节点dummy_head，这样删除头结点和中间结点就变得统一起来，不用分情况讨论。\n        cur = dummy_head  # 当前指针指向dummy_head（因为删除节点时，必须知道前一个节点的信息）\n\n        while cur and cur.next:  # 比较值得时候需要cur.next.val，所以cur 和 cur.next 必须有意义（不为空）\n            while cur.next and cur.next.val == val:  # 只要满足条件，就执行删除操作\n                cur.next =  cur.next.next  # 删除cur.next节点\n\n            cur = cur.next  # cur向后移动\n        \n        return dummy_head.next\n```\n\n## 707.设计链表\n\n> [力扣题目链接](https://leetcode.cn/problems/design-linked-list/)\n\n在链表类中实现这些功能：\n\n- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\n- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\n- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\n- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\n- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\n示例：\n```\nMyLinkedList linkedList = new MyLinkedList();\nlinkedList.addAtHead(1);\nlinkedList.addAtTail(3);\nlinkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3\nlinkedList.get(1);            //返回2\nlinkedList.deleteAtIndex(1);  //现在链表是1-> 3\nlinkedList.get(1);            //返回3\n```\n\n### 思路\n\n实现单向链表，即每个节点仅存储本身的值和后继节点。除此之外，我们还需要一个虚拟头结点作为头结点，和一个 length 参数保存有效节点数。\n\n> 单链表实现\n\n- 初始化一个虚拟头节点，方便链表增删操作\n- 实现 addAtHead(val) 和addAtTail(val) 时，可以借助 addAtIndex(index, val) 来实现\n\n\n\n### python代码\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):  # 初始化链表\n        self.dummy_head = ListNode()  # 虚拟头节点，方便链表增删操作\n        self.length = 0  # 当前链表的长度，链表长度为n的时候，index为0 ~ (n-1)\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.length:  # 先判断index是否有效，有效区间应该为[0, self.length -1]\n            return -1\n\n        cur = self.head.next  # 查找时先走到索引为0的结点\n        for _ in range(index):  # 当index为0时不进入for循环，所以后面直接返回cur.val\n            cur = cur.next\n        return cur.val\n\n    def addAtHead(self, val: int) -> None:  \n        self.addAtIndex(0, val)  # addAtHead相当于在index=0前添加结点\n\n    def addAtTail(self, val: int) -> None:\n        self.addAtIndex(self.length, val)  # addATail相当于在index=length前(最后一个结点后)添加结点\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0:  # 如果index小于0，则在头部插入节点\n            index = 0\n        if index <= self.length:  # 插入的合法范围为[0, length]\n            cur = self.head\n            for _ in range(index):\n                cur = cur.next\n            cur.next = ListNode(val, cur.next)\n            self.length += 1  # 更新size\n\n    def deleteAtIndex(self, index: int) -> None:\n        if  0 <= index < self.length:  # 删除的合法范围为[0, length-1]\n            cur = self.head\n            for _ in range(index):\n                cur = cur.next\n            cur.next = cur.next.next\n            self.length -= 1  # 更新size\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)\n```\n\n## 206.反转链表\n\n> [力扣题目链接](https://leetcode.cn/problems/reverse-linked-list/)\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n\n示例 1：\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n示例 2：\n```\n输入：head = []\n输出：[]\n```\n\n### 思路\n\n\n>\n\n- \n\n### python代码\n\n```python\n\n```\n","source":"_drafts/07 LeetCode刷题 Day3 链表 203.移除链表元素 707.设计链表 206.反转链表.md","raw":"---\ntitle: LeetCode刷题 Day3 链表 | 203.移除链表元素 707.设计链表 206.反转链表\ntag:\n  - LeetCode\ncategories:\n  - - 算法刷题\n    - 代码随想录\narticle_type: 0\nabbrlink: 8fa119fc\ndate: 2022-11-22\n---\n\n- LeetCode 203.移除链表元素\n- LeetCode 707.设计链表\n- LeetCode 206.反转链表\n\n<!-- more -->\n\n## 203.移除链表元素\n\n> [力扣题目链接](https://leetcode.cn/problems/remove-linked-list-elements/)\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n\n示例 1：\n```\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n```\n\n示例 2：\n```\n输入：head = [7,7,7,7], val = 7\n输出：[]\n```\n\n### 思路\n\n在单链表中 删除头结点 和 删除其他结点 的操作方式是不一样（删除其他结点时，都是通过该结点的前一个结点来删除该节点）。\n\n> 设置虚拟头结点来统一删除操作\n\n- 这样删除头结点和中间结点就变得统一起来，不用分情况讨论。\n\n### python代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        dummy_head = ListNode(next=head)  # 设置一个虚拟头节点dummy_head，这样删除头结点和中间结点就变得统一起来，不用分情况讨论。\n        cur = dummy_head  # 当前指针指向dummy_head（因为删除节点时，必须知道前一个节点的信息）\n\n        while cur and cur.next:  # 比较值得时候需要cur.next.val，所以cur 和 cur.next 必须有意义（不为空）\n            while cur.next and cur.next.val == val:  # 只要满足条件，就执行删除操作\n                cur.next =  cur.next.next  # 删除cur.next节点\n\n            cur = cur.next  # cur向后移动\n        \n        return dummy_head.next\n```\n\n## 707.设计链表\n\n> [力扣题目链接](https://leetcode.cn/problems/design-linked-list/)\n\n在链表类中实现这些功能：\n\n- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\n- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\n- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\n- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\n- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\n示例：\n```\nMyLinkedList linkedList = new MyLinkedList();\nlinkedList.addAtHead(1);\nlinkedList.addAtTail(3);\nlinkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3\nlinkedList.get(1);            //返回2\nlinkedList.deleteAtIndex(1);  //现在链表是1-> 3\nlinkedList.get(1);            //返回3\n```\n\n### 思路\n\n实现单向链表，即每个节点仅存储本身的值和后继节点。除此之外，我们还需要一个虚拟头结点作为头结点，和一个 length 参数保存有效节点数。\n\n> 单链表实现\n\n- 初始化一个虚拟头节点，方便链表增删操作\n- 实现 addAtHead(val) 和addAtTail(val) 时，可以借助 addAtIndex(index, val) 来实现\n\n\n\n### python代码\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):  # 初始化链表\n        self.dummy_head = ListNode()  # 虚拟头节点，方便链表增删操作\n        self.length = 0  # 当前链表的长度，链表长度为n的时候，index为0 ~ (n-1)\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.length:  # 先判断index是否有效，有效区间应该为[0, self.length -1]\n            return -1\n\n        cur = self.head.next  # 查找时先走到索引为0的结点\n        for _ in range(index):  # 当index为0时不进入for循环，所以后面直接返回cur.val\n            cur = cur.next\n        return cur.val\n\n    def addAtHead(self, val: int) -> None:  \n        self.addAtIndex(0, val)  # addAtHead相当于在index=0前添加结点\n\n    def addAtTail(self, val: int) -> None:\n        self.addAtIndex(self.length, val)  # addATail相当于在index=length前(最后一个结点后)添加结点\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0:  # 如果index小于0，则在头部插入节点\n            index = 0\n        if index <= self.length:  # 插入的合法范围为[0, length]\n            cur = self.head\n            for _ in range(index):\n                cur = cur.next\n            cur.next = ListNode(val, cur.next)\n            self.length += 1  # 更新size\n\n    def deleteAtIndex(self, index: int) -> None:\n        if  0 <= index < self.length:  # 删除的合法范围为[0, length-1]\n            cur = self.head\n            for _ in range(index):\n                cur = cur.next\n            cur.next = cur.next.next\n            self.length -= 1  # 更新size\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)\n```\n\n## 206.反转链表\n\n> [力扣题目链接](https://leetcode.cn/problems/reverse-linked-list/)\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n\n示例 1：\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n示例 2：\n```\n输入：head = []\n输出：[]\n```\n\n### 思路\n\n\n>\n\n- \n\n### python代码\n\n```python\n\n```\n","slug":"07 LeetCode刷题 Day3 链表 203.移除链表元素 707.设计链表 206.反转链表","published":0,"updated":"2022-11-26T20:38:51.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4a000a64rghqdf1jov","content":"<ul>\n<li>LeetCode 203.移除链表元素</li>\n<li>LeetCode 707.设计链表</li>\n<li>LeetCode 206.反转链表</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203.移除链表元素\"></a>203.移除链表元素</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/remove-linked-list-elements/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class=\"line\">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [7,7,7,7], val = 7</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>在单链表中 删除头结点 和 删除其他结点 的操作方式是不一样（删除其他结点时，都是通过该结点的前一个结点来删除该节点）。</p>\n<blockquote>\n<p>设置虚拟头结点来统一删除操作</p>\n</blockquote>\n<ul>\n<li>这样删除头结点和中间结点就变得统一起来，不用分情况讨论。</li>\n</ul>\n<h3 id=\"python代码\"><a href=\"#python代码\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, val=0, next=None):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = val</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = next</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">removeElements</span>(<span class=\"params\">self, head: <span class=\"type\">Optional</span>[ListNode], val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">Optional</span>[ListNode]:</span><br><span class=\"line\">        dummy_head = ListNode(<span class=\"built_in\">next</span>=head)  <span class=\"comment\"># 设置一个虚拟头节点dummy_head，这样删除头结点和中间结点就变得统一起来，不用分情况讨论。</span></span><br><span class=\"line\">        cur = dummy_head  <span class=\"comment\"># 当前指针指向dummy_head（因为删除节点时，必须知道前一个节点的信息）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur <span class=\"keyword\">and</span> cur.<span class=\"built_in\">next</span>:  <span class=\"comment\"># 比较值得时候需要cur.next.val，所以cur 和 cur.next 必须有意义（不为空）</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> cur.<span class=\"built_in\">next</span> <span class=\"keyword\">and</span> cur.<span class=\"built_in\">next</span>.val == val:  <span class=\"comment\"># 只要满足条件，就执行删除操作</span></span><br><span class=\"line\">                cur.<span class=\"built_in\">next</span> =  cur.<span class=\"built_in\">next</span>.<span class=\"built_in\">next</span>  <span class=\"comment\"># 删除cur.next节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">            cur = cur.<span class=\"built_in\">next</span>  <span class=\"comment\"># cur向后移动</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy_head.<span class=\"built_in\">next</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"707-设计链表\"><a href=\"#707-设计链表\" class=\"headerlink\" title=\"707.设计链表\"></a>707.设计链表</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/design-linked-list/\">力扣题目链接</a></p>\n</blockquote>\n<p>在链表类中实现这些功能：</p>\n<ul>\n<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>\n<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>\n<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>\n<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>\n<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyLinkedList linkedList = new MyLinkedList();</span><br><span class=\"line\">linkedList.addAtHead(1);</span><br><span class=\"line\">linkedList.addAtTail(3);</span><br><span class=\"line\">linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3</span><br><span class=\"line\">linkedList.get(1);            //返回2</span><br><span class=\"line\">linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3</span><br><span class=\"line\">linkedList.get(1);            //返回3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>实现单向链表，即每个节点仅存储本身的值和后继节点。除此之外，我们还需要一个虚拟头结点作为头结点，和一个 length 参数保存有效节点数。</p>\n<blockquote>\n<p>单链表实现</p>\n</blockquote>\n<ul>\n<li>初始化一个虚拟头节点，方便链表增删操作</li>\n<li>实现 addAtHead(val) 和addAtTail(val) 时，可以借助 addAtIndex(index, val) 来实现</li>\n</ul>\n<h3 id=\"python代码-1\"><a href=\"#python代码-1\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ListNode</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, val=<span class=\"number\">0</span>, <span class=\"built_in\">next</span>=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        self.val = val</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"built_in\">next</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLinkedList</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 初始化链表</span></span><br><span class=\"line\">        self.dummy_head = ListNode()  <span class=\"comment\"># 虚拟头节点，方便链表增删操作</span></span><br><span class=\"line\">        self.length = <span class=\"number\">0</span>  <span class=\"comment\"># 当前链表的长度，链表长度为n的时候，index为0 ~ (n-1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get</span>(<span class=\"params\">self, index: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> index &gt;= self.length:  <span class=\"comment\"># 先判断index是否有效，有效区间应该为[0, self.length -1]</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        cur = self.head.<span class=\"built_in\">next</span>  <span class=\"comment\"># 查找时先走到索引为0的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(index):  <span class=\"comment\"># 当index为0时不进入for循环，所以后面直接返回cur.val</span></span><br><span class=\"line\">            cur = cur.<span class=\"built_in\">next</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur.val</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">addAtHead</span>(<span class=\"params\">self, val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:  </span><br><span class=\"line\">        self.addAtIndex(<span class=\"number\">0</span>, val)  <span class=\"comment\"># addAtHead相当于在index=0前添加结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">addAtTail</span>(<span class=\"params\">self, val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        self.addAtIndex(self.length, val)  <span class=\"comment\"># addATail相当于在index=length前(最后一个结点后)添加结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">addAtIndex</span>(<span class=\"params\">self, index: <span class=\"built_in\">int</span>, val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span>:  <span class=\"comment\"># 如果index小于0，则在头部插入节点</span></span><br><span class=\"line\">            index = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt;= self.length:  <span class=\"comment\"># 插入的合法范围为[0, length]</span></span><br><span class=\"line\">            cur = self.head</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(index):</span><br><span class=\"line\">                cur = cur.<span class=\"built_in\">next</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">next</span> = ListNode(val, cur.<span class=\"built_in\">next</span>)</span><br><span class=\"line\">            self.length += <span class=\"number\">1</span>  <span class=\"comment\"># 更新size</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">deleteAtIndex</span>(<span class=\"params\">self, index: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  <span class=\"number\">0</span> &lt;= index &lt; self.length:  <span class=\"comment\"># 删除的合法范围为[0, length-1]</span></span><br><span class=\"line\">            cur = self.head</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(index):</span><br><span class=\"line\">                cur = cur.<span class=\"built_in\">next</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">next</span> = cur.<span class=\"built_in\">next</span>.<span class=\"built_in\">next</span></span><br><span class=\"line\">            self.length -= <span class=\"number\">1</span>  <span class=\"comment\"># 更新size</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"># obj = MyLinkedList()</span></span><br><span class=\"line\"><span class=\"comment\"># param_1 = obj.get(index)</span></span><br><span class=\"line\"><span class=\"comment\"># obj.addAtHead(val)</span></span><br><span class=\"line\"><span class=\"comment\"># obj.addAtTail(val)</span></span><br><span class=\"line\"><span class=\"comment\"># obj.addAtIndex(index,val)</span></span><br><span class=\"line\"><span class=\"comment\"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206.反转链表\"></a>206.反转链表</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/reverse-linked-list/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,3,4,5]</span><br><span class=\"line\">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><blockquote>\n</blockquote>\n<ul>\n<li></li>\n</ul>\n<h3 id=\"python代码-2\"><a href=\"#python代码-2\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<ul>\n<li>LeetCode 203.移除链表元素</li>\n<li>LeetCode 707.设计链表</li>\n<li>LeetCode 206.反转链表</li>\n</ul>","more":"<h2 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203.移除链表元素\"></a>203.移除链表元素</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/remove-linked-list-elements/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class=\"line\">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [7,7,7,7], val = 7</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>在单链表中 删除头结点 和 删除其他结点 的操作方式是不一样（删除其他结点时，都是通过该结点的前一个结点来删除该节点）。</p>\n<blockquote>\n<p>设置虚拟头结点来统一删除操作</p>\n</blockquote>\n<ul>\n<li>这样删除头结点和中间结点就变得统一起来，不用分情况讨论。</li>\n</ul>\n<h3 id=\"python代码\"><a href=\"#python代码\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, val=0, next=None):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = val</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = next</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">removeElements</span>(<span class=\"params\">self, head: <span class=\"type\">Optional</span>[ListNode], val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">Optional</span>[ListNode]:</span><br><span class=\"line\">        dummy_head = ListNode(<span class=\"built_in\">next</span>=head)  <span class=\"comment\"># 设置一个虚拟头节点dummy_head，这样删除头结点和中间结点就变得统一起来，不用分情况讨论。</span></span><br><span class=\"line\">        cur = dummy_head  <span class=\"comment\"># 当前指针指向dummy_head（因为删除节点时，必须知道前一个节点的信息）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur <span class=\"keyword\">and</span> cur.<span class=\"built_in\">next</span>:  <span class=\"comment\"># 比较值得时候需要cur.next.val，所以cur 和 cur.next 必须有意义（不为空）</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> cur.<span class=\"built_in\">next</span> <span class=\"keyword\">and</span> cur.<span class=\"built_in\">next</span>.val == val:  <span class=\"comment\"># 只要满足条件，就执行删除操作</span></span><br><span class=\"line\">                cur.<span class=\"built_in\">next</span> =  cur.<span class=\"built_in\">next</span>.<span class=\"built_in\">next</span>  <span class=\"comment\"># 删除cur.next节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">            cur = cur.<span class=\"built_in\">next</span>  <span class=\"comment\"># cur向后移动</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy_head.<span class=\"built_in\">next</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"707-设计链表\"><a href=\"#707-设计链表\" class=\"headerlink\" title=\"707.设计链表\"></a>707.设计链表</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/design-linked-list/\">力扣题目链接</a></p>\n</blockquote>\n<p>在链表类中实现这些功能：</p>\n<ul>\n<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>\n<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>\n<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>\n<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>\n<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyLinkedList linkedList = new MyLinkedList();</span><br><span class=\"line\">linkedList.addAtHead(1);</span><br><span class=\"line\">linkedList.addAtTail(3);</span><br><span class=\"line\">linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3</span><br><span class=\"line\">linkedList.get(1);            //返回2</span><br><span class=\"line\">linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3</span><br><span class=\"line\">linkedList.get(1);            //返回3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>实现单向链表，即每个节点仅存储本身的值和后继节点。除此之外，我们还需要一个虚拟头结点作为头结点，和一个 length 参数保存有效节点数。</p>\n<blockquote>\n<p>单链表实现</p>\n</blockquote>\n<ul>\n<li>初始化一个虚拟头节点，方便链表增删操作</li>\n<li>实现 addAtHead(val) 和addAtTail(val) 时，可以借助 addAtIndex(index, val) 来实现</li>\n</ul>\n<h3 id=\"python代码-1\"><a href=\"#python代码-1\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ListNode</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, val=<span class=\"number\">0</span>, <span class=\"built_in\">next</span>=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        self.val = val</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"built_in\">next</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLinkedList</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 初始化链表</span></span><br><span class=\"line\">        self.dummy_head = ListNode()  <span class=\"comment\"># 虚拟头节点，方便链表增删操作</span></span><br><span class=\"line\">        self.length = <span class=\"number\">0</span>  <span class=\"comment\"># 当前链表的长度，链表长度为n的时候，index为0 ~ (n-1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get</span>(<span class=\"params\">self, index: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> index &gt;= self.length:  <span class=\"comment\"># 先判断index是否有效，有效区间应该为[0, self.length -1]</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        cur = self.head.<span class=\"built_in\">next</span>  <span class=\"comment\"># 查找时先走到索引为0的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(index):  <span class=\"comment\"># 当index为0时不进入for循环，所以后面直接返回cur.val</span></span><br><span class=\"line\">            cur = cur.<span class=\"built_in\">next</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur.val</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">addAtHead</span>(<span class=\"params\">self, val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:  </span><br><span class=\"line\">        self.addAtIndex(<span class=\"number\">0</span>, val)  <span class=\"comment\"># addAtHead相当于在index=0前添加结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">addAtTail</span>(<span class=\"params\">self, val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        self.addAtIndex(self.length, val)  <span class=\"comment\"># addATail相当于在index=length前(最后一个结点后)添加结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">addAtIndex</span>(<span class=\"params\">self, index: <span class=\"built_in\">int</span>, val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span>:  <span class=\"comment\"># 如果index小于0，则在头部插入节点</span></span><br><span class=\"line\">            index = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt;= self.length:  <span class=\"comment\"># 插入的合法范围为[0, length]</span></span><br><span class=\"line\">            cur = self.head</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(index):</span><br><span class=\"line\">                cur = cur.<span class=\"built_in\">next</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">next</span> = ListNode(val, cur.<span class=\"built_in\">next</span>)</span><br><span class=\"line\">            self.length += <span class=\"number\">1</span>  <span class=\"comment\"># 更新size</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">deleteAtIndex</span>(<span class=\"params\">self, index: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  <span class=\"number\">0</span> &lt;= index &lt; self.length:  <span class=\"comment\"># 删除的合法范围为[0, length-1]</span></span><br><span class=\"line\">            cur = self.head</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(index):</span><br><span class=\"line\">                cur = cur.<span class=\"built_in\">next</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">next</span> = cur.<span class=\"built_in\">next</span>.<span class=\"built_in\">next</span></span><br><span class=\"line\">            self.length -= <span class=\"number\">1</span>  <span class=\"comment\"># 更新size</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"># obj = MyLinkedList()</span></span><br><span class=\"line\"><span class=\"comment\"># param_1 = obj.get(index)</span></span><br><span class=\"line\"><span class=\"comment\"># obj.addAtHead(val)</span></span><br><span class=\"line\"><span class=\"comment\"># obj.addAtTail(val)</span></span><br><span class=\"line\"><span class=\"comment\"># obj.addAtIndex(index,val)</span></span><br><span class=\"line\"><span class=\"comment\"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206.反转链表\"></a>206.反转链表</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/reverse-linked-list/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,3,4,5]</span><br><span class=\"line\">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><blockquote>\n</blockquote>\n<ul>\n<li></li>\n</ul>\n<h3 id=\"python代码-2\"><a href=\"#python代码-2\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"用BusyBox制作最小根文件系统","article_type":0,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"top":null,"_content":"\n本文是Linux内核实验的第二部分，想查看之前的内容可以点这里：[Linux 内核裁剪及编译](/post/8283904e.html)。\n\nBusyBox 包含了一些简单的工具，例如ls、cat和echo等等。它提供了一个比较完善的环境，可以适用于任何小的嵌入式系统，我们将下载并编译BusyBox，并在它的基础上制作最小根文件系统。\n\n<!-- more -->\n\nBusyBox官网：[https://www.busybox.net/](https://www.busybox.net/)\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image14.png\" alt=\"BusyBox官网\" style=\"zoom:60%;\" />\n\n# 下载并编译BusyBox源码\n\n（1）下载并解压BusyBox到mini-linux文件夹\n\n```bash\nwget https://busybox.net/downloads/busybox-1.33.2.tar.bz2\ntar -xvf busybox-1.33.2.tar.bz2\ncd busybox-1.33.2\n```\n\n（2）配置BusyBox\n\n```bash\nmake menuconfig\n```\n\n相信经过Linux内核编译，你对menuconfig操作比较熟悉了吧\n\n这里我们把BusyBox配置为静态编译，这样BusyBox在运行的时候就不需要额外的动态链接库了。\n\n进入Settings下，勾选“Build static binary (no shared libs)”。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image15.png\" alt=\"BusyBox编译配置界面\" style=\"zoom:60%;\" />\n\n同样在Settings下，勾选“Don't use /usr”。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image16.png\" alt=\"不配置/usr\" style=\"zoom:60%;\" />\n\n​    选项配置完毕，按Exit退出，选择Yes保存。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image17.png\" alt=\"保存并退出\" style=\"zoom:60%;\" />\n\n（3）编译和安装\n\n```bash\nmake -j8 && make install\n```\n\n（编译耗时一分钟）\n\n编译好的文件在BusyBox-1.33.2/_install/ 目录下\n\n# 完善最小文件系统\n\n（1）返回到mini-linux文件夹\n\n```bash\ncd .. \n```\n\n（2）创建文件系统文件夹\n\n```bash\nmkdir rootfs\n```\n\n（3）拷贝编译好的BusyBox文件到rootfs\n\n```bash\ncp -rfa busybox-1.33.2/_install/* rootfs/\n\ncp -rfa busybox-1.33.2/examples/bootfloppy/etc/ rootfs/\n```\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image18.png\" alt=\"image18\" style=\"zoom:60%;\" />\n\n（4）修改`rootfs/etc/init.d/rcS`文件\n\n```bash\nvim rootfs/etc/init.d/rcS\n```\n\n改为如下：\n\n```bash\n#! /bin/sh                                 \n/bin/mount -a\nexport PATH=/bin:/sbin:/usr/bin:/usr/sbin\nexport LD_LIBRARY_PATH=/lib/\n```\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image19.png\" alt=\"image19\" style=\"zoom: 60%;\" />\n\n退出vim\n\n","source":"_drafts/用BusyBox制作最小根文件系统.md","raw":"---\ntitle: 用BusyBox制作最小根文件系统\ntag:\n  - linux\ncategories:\n  - linux\narticle_type: 0\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\ntop:\n---\n\n本文是Linux内核实验的第二部分，想查看之前的内容可以点这里：[Linux 内核裁剪及编译](/post/8283904e.html)。\n\nBusyBox 包含了一些简单的工具，例如ls、cat和echo等等。它提供了一个比较完善的环境，可以适用于任何小的嵌入式系统，我们将下载并编译BusyBox，并在它的基础上制作最小根文件系统。\n\n<!-- more -->\n\nBusyBox官网：[https://www.busybox.net/](https://www.busybox.net/)\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image14.png\" alt=\"BusyBox官网\" style=\"zoom:60%;\" />\n\n# 下载并编译BusyBox源码\n\n（1）下载并解压BusyBox到mini-linux文件夹\n\n```bash\nwget https://busybox.net/downloads/busybox-1.33.2.tar.bz2\ntar -xvf busybox-1.33.2.tar.bz2\ncd busybox-1.33.2\n```\n\n（2）配置BusyBox\n\n```bash\nmake menuconfig\n```\n\n相信经过Linux内核编译，你对menuconfig操作比较熟悉了吧\n\n这里我们把BusyBox配置为静态编译，这样BusyBox在运行的时候就不需要额外的动态链接库了。\n\n进入Settings下，勾选“Build static binary (no shared libs)”。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image15.png\" alt=\"BusyBox编译配置界面\" style=\"zoom:60%;\" />\n\n同样在Settings下，勾选“Don't use /usr”。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image16.png\" alt=\"不配置/usr\" style=\"zoom:60%;\" />\n\n​    选项配置完毕，按Exit退出，选择Yes保存。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image17.png\" alt=\"保存并退出\" style=\"zoom:60%;\" />\n\n（3）编译和安装\n\n```bash\nmake -j8 && make install\n```\n\n（编译耗时一分钟）\n\n编译好的文件在BusyBox-1.33.2/_install/ 目录下\n\n# 完善最小文件系统\n\n（1）返回到mini-linux文件夹\n\n```bash\ncd .. \n```\n\n（2）创建文件系统文件夹\n\n```bash\nmkdir rootfs\n```\n\n（3）拷贝编译好的BusyBox文件到rootfs\n\n```bash\ncp -rfa busybox-1.33.2/_install/* rootfs/\n\ncp -rfa busybox-1.33.2/examples/bootfloppy/etc/ rootfs/\n```\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image18.png\" alt=\"image18\" style=\"zoom:60%;\" />\n\n（4）修改`rootfs/etc/init.d/rcS`文件\n\n```bash\nvim rootfs/etc/init.d/rcS\n```\n\n改为如下：\n\n```bash\n#! /bin/sh                                 \n/bin/mount -a\nexport PATH=/bin:/sbin:/usr/bin:/usr/sbin\nexport LD_LIBRARY_PATH=/lib/\n```\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image19.png\" alt=\"image19\" style=\"zoom: 60%;\" />\n\n退出vim\n\n","slug":"用BusyBox制作最小根文件系统","published":0,"date":"2022-11-24T13:36:19.849Z","updated":"2021-12-30T11:56:19.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4e000b64rg7pk0d3qo","content":"<p>本文是Linux内核实验的第二部分，想查看之前的内容可以点这里：<a href=\"/post/8283904e.html\">Linux 内核裁剪及编译</a>。</p>\n<p>BusyBox 包含了一些简单的工具，例如ls、cat和echo等等。它提供了一个比较完善的环境，可以适用于任何小的嵌入式系统，我们将下载并编译BusyBox，并在它的基础上制作最小根文件系统。</p>\n<span id=\"more\"></span>\n\n<p>BusyBox官网：<a href=\"https://www.busybox.net/\">https://www.busybox.net/</a></p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image14.png\" alt=\"BusyBox官网\" style=\"zoom:60%;\" />\n\n<h1 id=\"下载并编译BusyBox源码\"><a href=\"#下载并编译BusyBox源码\" class=\"headerlink\" title=\"下载并编译BusyBox源码\"></a>下载并编译BusyBox源码</h1><p>（1）下载并解压BusyBox到mini-linux文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://busybox.net/downloads/busybox-1.33.2.tar.bz2</span><br><span class=\"line\">tar -xvf busybox-1.33.2.tar.bz2</span><br><span class=\"line\"><span class=\"built_in\">cd</span> busybox-1.33.2</span><br></pre></td></tr></table></figure>\n\n<p>（2）配置BusyBox</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make menuconfig</span><br></pre></td></tr></table></figure>\n\n<p>相信经过Linux内核编译，你对menuconfig操作比较熟悉了吧</p>\n<p>这里我们把BusyBox配置为静态编译，这样BusyBox在运行的时候就不需要额外的动态链接库了。</p>\n<p>进入Settings下，勾选“Build static binary (no shared libs)”。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image15.png\" alt=\"BusyBox编译配置界面\" style=\"zoom:60%;\" />\n\n<p>同样在Settings下，勾选“Don’t use /usr”。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image16.png\" alt=\"不配置/usr\" style=\"zoom:60%;\" />\n\n<p>​    选项配置完毕，按Exit退出，选择Yes保存。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image17.png\" alt=\"保存并退出\" style=\"zoom:60%;\" />\n\n<p>（3）编译和安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -j8 &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n\n<p>（编译耗时一分钟）</p>\n<p>编译好的文件在BusyBox-1.33.2/_install/ 目录下</p>\n<h1 id=\"完善最小文件系统\"><a href=\"#完善最小文件系统\" class=\"headerlink\" title=\"完善最小文件系统\"></a>完善最小文件系统</h1><p>（1）返回到mini-linux文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> .. </span><br></pre></td></tr></table></figure>\n\n<p>（2）创建文件系统文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> rootfs</span><br></pre></td></tr></table></figure>\n\n<p>（3）拷贝编译好的BusyBox文件到rootfs</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> -rfa busybox-1.33.2/_install/* rootfs/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span> -rfa busybox-1.33.2/examples/bootfloppy/etc/ rootfs/</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image18.png\" alt=\"image18\" style=\"zoom:60%;\" />\n\n<p>（4）修改<code>rootfs/etc/init.d/rcS</code>文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim rootfs/etc/init.d/rcS</span><br></pre></td></tr></table></figure>\n\n<p>改为如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#! /bin/sh                                 </span></span><br><span class=\"line\">/bin/mount -a</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/lib/</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image19.png\" alt=\"image19\" style=\"zoom: 60%;\" />\n\n<p>退出vim</p>\n","site":{"data":{}},"excerpt":"<p>本文是Linux内核实验的第二部分，想查看之前的内容可以点这里：<a href=\"/post/8283904e.html\">Linux 内核裁剪及编译</a>。</p>\n<p>BusyBox 包含了一些简单的工具，例如ls、cat和echo等等。它提供了一个比较完善的环境，可以适用于任何小的嵌入式系统，我们将下载并编译BusyBox，并在它的基础上制作最小根文件系统。</p>","more":"<p>BusyBox官网：<a href=\"https://www.busybox.net/\">https://www.busybox.net/</a></p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image14.png\" alt=\"BusyBox官网\" style=\"zoom:60%;\" />\n\n<h1 id=\"下载并编译BusyBox源码\"><a href=\"#下载并编译BusyBox源码\" class=\"headerlink\" title=\"下载并编译BusyBox源码\"></a>下载并编译BusyBox源码</h1><p>（1）下载并解压BusyBox到mini-linux文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://busybox.net/downloads/busybox-1.33.2.tar.bz2</span><br><span class=\"line\">tar -xvf busybox-1.33.2.tar.bz2</span><br><span class=\"line\"><span class=\"built_in\">cd</span> busybox-1.33.2</span><br></pre></td></tr></table></figure>\n\n<p>（2）配置BusyBox</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make menuconfig</span><br></pre></td></tr></table></figure>\n\n<p>相信经过Linux内核编译，你对menuconfig操作比较熟悉了吧</p>\n<p>这里我们把BusyBox配置为静态编译，这样BusyBox在运行的时候就不需要额外的动态链接库了。</p>\n<p>进入Settings下，勾选“Build static binary (no shared libs)”。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image15.png\" alt=\"BusyBox编译配置界面\" style=\"zoom:60%;\" />\n\n<p>同样在Settings下，勾选“Don’t use /usr”。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image16.png\" alt=\"不配置/usr\" style=\"zoom:60%;\" />\n\n<p>​    选项配置完毕，按Exit退出，选择Yes保存。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image17.png\" alt=\"保存并退出\" style=\"zoom:60%;\" />\n\n<p>（3）编译和安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -j8 &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n\n<p>（编译耗时一分钟）</p>\n<p>编译好的文件在BusyBox-1.33.2/_install/ 目录下</p>\n<h1 id=\"完善最小文件系统\"><a href=\"#完善最小文件系统\" class=\"headerlink\" title=\"完善最小文件系统\"></a>完善最小文件系统</h1><p>（1）返回到mini-linux文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> .. </span><br></pre></td></tr></table></figure>\n\n<p>（2）创建文件系统文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> rootfs</span><br></pre></td></tr></table></figure>\n\n<p>（3）拷贝编译好的BusyBox文件到rootfs</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> -rfa busybox-1.33.2/_install/* rootfs/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span> -rfa busybox-1.33.2/examples/bootfloppy/etc/ rootfs/</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image18.png\" alt=\"image18\" style=\"zoom:60%;\" />\n\n<p>（4）修改<code>rootfs/etc/init.d/rcS</code>文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim rootfs/etc/init.d/rcS</span><br></pre></td></tr></table></figure>\n\n<p>改为如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#! /bin/sh                                 </span></span><br><span class=\"line\">/bin/mount -a</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/lib/</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image19.png\" alt=\"image19\" style=\"zoom: 60%;\" />\n\n<p>退出vim</p>"},{"title":"论文阅读|Learning Rich Features for Image Manipulation Detection(CVPR2018-图像篡改)","article_type":0,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"abbrlink":"f3d19c30","top":null,"_content":"\n**简介**\n\n网络包含RGB流和噪声流，其中RGB流用于提取RGB图像的特征，以发现篡改的伪像，例如强烈的对比度差异，不自然的篡改边界等，另一个是噪声流，它利用从富隐写分析模型分析的滤波器层（SRM）提取的噪声特征来发现真实区域和篡改区域之间的噪声不一致。然后，通过双线性池化层融合来自两个流的特征根据丰富的特征，根据RGB特征和噪声特征来检测图像篡改区域和篡改的方式。\n\n**噪声流的线索依据**.\n\n为什么要再加入一个噪声流，这是因为采用了局部噪声特征的方法。由于RGB通道不足以解决所有不同的篡改攻击方式，尤其是，经过精心后处理以隐藏拼接边界并减少对比度差异的篡改图像，这种情况对于仅用RGB流而言是较为困难的。当从一个图像（源）中删除一个对象并将其粘贴到另一个图像（目标）中时，源和目标图像之间的噪声特征不匹配。那么如何实现给图像增加噪声呢？作者希望通过Steganalysis Rich Model获得噪声图片。\n\nSteganalysis Rich Model 最早是应用在隐写术（是一种将消息嵌入到数字载体的技术如图像、视频等），SRM功能从30个基本滤波器开始，滤波后在输出附近使用最大值和最小值等非线性操作, 从该过程中获得的特征可以被视为局部噪声描述符。作者在实验中发现，仅使用 SRM 其中的3个滤波器就可以实现不错的性能，而应用所有30个内核并不能显着提高性能，因此使用下面3个滤波器获取像素值与相邻像素的差值估计来实现图片添加噪声的功能。\n\n![img](https://qiniuy.tzle1.com/Fgig0qWQZ5sW6seA2aAi7HXttRft)\n\n下图是分别经过拼接，复制移动和擦除填充后的篡改图像，以及通过SRM层的噪声图，从图中可以清晰的看出加入噪声后篡改区域的噪声与真实区域的较大区别。\n\n![img](https://qiniuy.tzle1.com/Fl8aoktp9XeZw9QrfCOdP2vpYWO3)\n\n**网络结构**\n\n作者采用了一个双流的FasterRCNN 的结构, 分别包括RGB流和噪声流。RGB流输入RGB图像， 噪声流中输入SRM图像。两部分共享相同的 ROI 层，同时执行分类和边界框回归两个操作。作者通过双线性池融合两个流的特征进行分类，RPN利用RGB流的特征进行边界框的回归。\n\n- **RGB Stream**\n\n\tRGB流采用的是单个Faster RCNN 网络提取RGB图像特征并用分类和边界框回归，主干使用的是 ResNet 101 网络提取图像特征，ResNet的最后一个卷积层的输出 feature map用于分类篡改类型。RGB流中的RPN网络利用这些特征为边界框回归提供 propose RoI，Loss function 如下：\n\t$$\n\t\\begin{array}{r}\n\tL_{R P N}\\left(g_{i}, f_{i}\\right)=\\frac{1}{N_{c l s}} \\sum_{i} L_{c l s}\\left(g_{i}, g_{i}^{\\star}\\right) \n\t+\\lambda \\frac{1}{N_{r e g}} \\sum_{i} g_{i}^{\\star} L_{r e g}\\left(f_{i}, f_{i}^{\\star}\\right)\n\t\\end{array}\n\t$$\n\n\ngigi 表示 anchor i 在一个 batch 中是潜在的被篡改区域的概率， g⋆igi⋆ 表示对于 anchor i 的 ground-truth 是 positive，fifi 和 f⋆ifi⋆分别是anchor i 和 ground-truth 的四维边界框坐标。LclsLcls表示RPN网络的交叉熵，LregLreg表示用于平滑提议边界框回归的L1损失。NclsNcls表示在RPN中 batch 的 大小，LregLreg是anchor location的数目。λ用来平衡这个两个损失。\n\n- **Noise Stream**\n\n\t噪声流和RGB流的结构采用一样的主干结构 ResNet 101 网络。原图经过SRM层变成噪声图片输入噪声流当中，ResNet 101 网络提取噪声特征。噪声流与 RGB 流共享相同的 ROI 层，提取出的特征仅用于分类。需要注意的是对于边界框回归，作者只使用 RGB 通道，因为作者经过实验，发现RGB 特征在 RPN 网络中的性能优于噪声特征。\n\n- **Bilinear Pooling**\n\n\t作者采用双线性池（BilinearPooling）的方法将 RGB 流与噪声流结合起来进行篡改检测。Bilinear Pooling 双线性池 可以很好的结合了双流 cnn 网络中的特征，同时保留空间信息，以提高检测置信度。下面是双线性池的结构。\n\t\n\t![img](https://qiniuy.tzle1.com/FnNjLvZdJl6wKxyt-_nhJt6QowdS)\n\t\n\t直观上理解，所谓bilinear pooling，就是先把在同一位置上的两个特征双线性融合（相乘）后得到矩阵 ，对所有位置进行sum pooling（也可以是max pooling，但一般采用sum pooling以方便进行矩阵运算）得到矩阵，最后把矩阵展开成一个向量，记为bilinear vector。对进行sqrt操作和L2归一化操作后，就得到融合后的特征。将RGB特征和噪声特征经过双线性池融合的特征用于分类，经过全连接层和 softmax 层获得 RoI regions 的篡改类型。总的损失函数如下：\n\n$$\nL_{\\text {total }}=L_{R P N}+L_{\\text {tamper }}\\left(f_{R G B}, f_{N}\\right)+L_{b b o x}\\left(f_{R G B}\\right)\n$$\n\nLRPNLRPN是RPN网络中的loss。LtamperLtamper表示最后的交叉熵分类损失；LbboxLbbox表示最后的边界框回归损失；fRGBfRGB和fNfN表示来自RGB和noise stream的RoI features。\n","source":"_drafts/论文阅读-Learning Rich Features for Image Manipulation Detection(CVPR 2018 - 图像篡改检测).md","raw":"---\ntitle: 论文阅读|Learning Rich Features for Image Manipulation Detection(CVPR2018-图像篡改)\ntag:\n  - 论文阅读\n  - 图像篡改\ncategories:\n  - 论文阅读\n  -   CV\n  - 图像篡改\narticle_type: 0\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\nabbrlink: f3d19c30\ntop:\n---\n\n**简介**\n\n网络包含RGB流和噪声流，其中RGB流用于提取RGB图像的特征，以发现篡改的伪像，例如强烈的对比度差异，不自然的篡改边界等，另一个是噪声流，它利用从富隐写分析模型分析的滤波器层（SRM）提取的噪声特征来发现真实区域和篡改区域之间的噪声不一致。然后，通过双线性池化层融合来自两个流的特征根据丰富的特征，根据RGB特征和噪声特征来检测图像篡改区域和篡改的方式。\n\n**噪声流的线索依据**.\n\n为什么要再加入一个噪声流，这是因为采用了局部噪声特征的方法。由于RGB通道不足以解决所有不同的篡改攻击方式，尤其是，经过精心后处理以隐藏拼接边界并减少对比度差异的篡改图像，这种情况对于仅用RGB流而言是较为困难的。当从一个图像（源）中删除一个对象并将其粘贴到另一个图像（目标）中时，源和目标图像之间的噪声特征不匹配。那么如何实现给图像增加噪声呢？作者希望通过Steganalysis Rich Model获得噪声图片。\n\nSteganalysis Rich Model 最早是应用在隐写术（是一种将消息嵌入到数字载体的技术如图像、视频等），SRM功能从30个基本滤波器开始，滤波后在输出附近使用最大值和最小值等非线性操作, 从该过程中获得的特征可以被视为局部噪声描述符。作者在实验中发现，仅使用 SRM 其中的3个滤波器就可以实现不错的性能，而应用所有30个内核并不能显着提高性能，因此使用下面3个滤波器获取像素值与相邻像素的差值估计来实现图片添加噪声的功能。\n\n![img](https://qiniuy.tzle1.com/Fgig0qWQZ5sW6seA2aAi7HXttRft)\n\n下图是分别经过拼接，复制移动和擦除填充后的篡改图像，以及通过SRM层的噪声图，从图中可以清晰的看出加入噪声后篡改区域的噪声与真实区域的较大区别。\n\n![img](https://qiniuy.tzle1.com/Fl8aoktp9XeZw9QrfCOdP2vpYWO3)\n\n**网络结构**\n\n作者采用了一个双流的FasterRCNN 的结构, 分别包括RGB流和噪声流。RGB流输入RGB图像， 噪声流中输入SRM图像。两部分共享相同的 ROI 层，同时执行分类和边界框回归两个操作。作者通过双线性池融合两个流的特征进行分类，RPN利用RGB流的特征进行边界框的回归。\n\n- **RGB Stream**\n\n\tRGB流采用的是单个Faster RCNN 网络提取RGB图像特征并用分类和边界框回归，主干使用的是 ResNet 101 网络提取图像特征，ResNet的最后一个卷积层的输出 feature map用于分类篡改类型。RGB流中的RPN网络利用这些特征为边界框回归提供 propose RoI，Loss function 如下：\n\t$$\n\t\\begin{array}{r}\n\tL_{R P N}\\left(g_{i}, f_{i}\\right)=\\frac{1}{N_{c l s}} \\sum_{i} L_{c l s}\\left(g_{i}, g_{i}^{\\star}\\right) \n\t+\\lambda \\frac{1}{N_{r e g}} \\sum_{i} g_{i}^{\\star} L_{r e g}\\left(f_{i}, f_{i}^{\\star}\\right)\n\t\\end{array}\n\t$$\n\n\ngigi 表示 anchor i 在一个 batch 中是潜在的被篡改区域的概率， g⋆igi⋆ 表示对于 anchor i 的 ground-truth 是 positive，fifi 和 f⋆ifi⋆分别是anchor i 和 ground-truth 的四维边界框坐标。LclsLcls表示RPN网络的交叉熵，LregLreg表示用于平滑提议边界框回归的L1损失。NclsNcls表示在RPN中 batch 的 大小，LregLreg是anchor location的数目。λ用来平衡这个两个损失。\n\n- **Noise Stream**\n\n\t噪声流和RGB流的结构采用一样的主干结构 ResNet 101 网络。原图经过SRM层变成噪声图片输入噪声流当中，ResNet 101 网络提取噪声特征。噪声流与 RGB 流共享相同的 ROI 层，提取出的特征仅用于分类。需要注意的是对于边界框回归，作者只使用 RGB 通道，因为作者经过实验，发现RGB 特征在 RPN 网络中的性能优于噪声特征。\n\n- **Bilinear Pooling**\n\n\t作者采用双线性池（BilinearPooling）的方法将 RGB 流与噪声流结合起来进行篡改检测。Bilinear Pooling 双线性池 可以很好的结合了双流 cnn 网络中的特征，同时保留空间信息，以提高检测置信度。下面是双线性池的结构。\n\t\n\t![img](https://qiniuy.tzle1.com/FnNjLvZdJl6wKxyt-_nhJt6QowdS)\n\t\n\t直观上理解，所谓bilinear pooling，就是先把在同一位置上的两个特征双线性融合（相乘）后得到矩阵 ，对所有位置进行sum pooling（也可以是max pooling，但一般采用sum pooling以方便进行矩阵运算）得到矩阵，最后把矩阵展开成一个向量，记为bilinear vector。对进行sqrt操作和L2归一化操作后，就得到融合后的特征。将RGB特征和噪声特征经过双线性池融合的特征用于分类，经过全连接层和 softmax 层获得 RoI regions 的篡改类型。总的损失函数如下：\n\n$$\nL_{\\text {total }}=L_{R P N}+L_{\\text {tamper }}\\left(f_{R G B}, f_{N}\\right)+L_{b b o x}\\left(f_{R G B}\\right)\n$$\n\nLRPNLRPN是RPN网络中的loss。LtamperLtamper表示最后的交叉熵分类损失；LbboxLbbox表示最后的边界框回归损失；fRGBfRGB和fNfN表示来自RGB和noise stream的RoI features。\n","slug":"论文阅读-Learning Rich Features for Image Manipulation Detection(CVPR 2018 - 图像篡改检测)","published":0,"date":"2022-11-24T13:36:19.853Z","updated":"2021-10-28T11:36:00.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4g000d64rg9ejs4oru","content":"<p><strong>简介</strong></p>\n<p>网络包含RGB流和噪声流，其中RGB流用于提取RGB图像的特征，以发现篡改的伪像，例如强烈的对比度差异，不自然的篡改边界等，另一个是噪声流，它利用从富隐写分析模型分析的滤波器层（SRM）提取的噪声特征来发现真实区域和篡改区域之间的噪声不一致。然后，通过双线性池化层融合来自两个流的特征根据丰富的特征，根据RGB特征和噪声特征来检测图像篡改区域和篡改的方式。</p>\n<p><strong>噪声流的线索依据</strong>.</p>\n<p>为什么要再加入一个噪声流，这是因为采用了局部噪声特征的方法。由于RGB通道不足以解决所有不同的篡改攻击方式，尤其是，经过精心后处理以隐藏拼接边界并减少对比度差异的篡改图像，这种情况对于仅用RGB流而言是较为困难的。当从一个图像（源）中删除一个对象并将其粘贴到另一个图像（目标）中时，源和目标图像之间的噪声特征不匹配。那么如何实现给图像增加噪声呢？作者希望通过Steganalysis Rich Model获得噪声图片。</p>\n<p>Steganalysis Rich Model 最早是应用在隐写术（是一种将消息嵌入到数字载体的技术如图像、视频等），SRM功能从30个基本滤波器开始，滤波后在输出附近使用最大值和最小值等非线性操作, 从该过程中获得的特征可以被视为局部噪声描述符。作者在实验中发现，仅使用 SRM 其中的3个滤波器就可以实现不错的性能，而应用所有30个内核并不能显着提高性能，因此使用下面3个滤波器获取像素值与相邻像素的差值估计来实现图片添加噪声的功能。</p>\n<p><img src=\"https://qiniuy.tzle1.com/Fgig0qWQZ5sW6seA2aAi7HXttRft\" alt=\"img\"></p>\n<p>下图是分别经过拼接，复制移动和擦除填充后的篡改图像，以及通过SRM层的噪声图，从图中可以清晰的看出加入噪声后篡改区域的噪声与真实区域的较大区别。</p>\n<p><img src=\"https://qiniuy.tzle1.com/Fl8aoktp9XeZw9QrfCOdP2vpYWO3\" alt=\"img\"></p>\n<p><strong>网络结构</strong></p>\n<p>作者采用了一个双流的FasterRCNN 的结构, 分别包括RGB流和噪声流。RGB流输入RGB图像， 噪声流中输入SRM图像。两部分共享相同的 ROI 层，同时执行分类和边界框回归两个操作。作者通过双线性池融合两个流的特征进行分类，RPN利用RGB流的特征进行边界框的回归。</p>\n<ul>\n<li><p><strong>RGB Stream</strong></p>\n<p>  RGB流采用的是单个Faster RCNN 网络提取RGB图像特征并用分类和边界框回归，主干使用的是 ResNet 101 网络提取图像特征，ResNet的最后一个卷积层的输出 feature map用于分类篡改类型。RGB流中的RPN网络利用这些特征为边界框回归提供 propose RoI，Loss function 如下：<br>  $$<br>  \\begin{array}{r}<br>  L_{R P N}\\left(g_{i}, f_{i}\\right)=\\frac{1}{N_{c l s}} \\sum_{i} L_{c l s}\\left(g_{i}, g_{i}^{\\star}\\right)<br>  +\\lambda \\frac{1}{N_{r e g}} \\sum_{i} g_{i}^{\\star} L_{r e g}\\left(f_{i}, f_{i}^{\\star}\\right)<br>  \\end{array}<br>  $$</p>\n</li>\n</ul>\n<p>gigi 表示 anchor i 在一个 batch 中是潜在的被篡改区域的概率， g⋆igi⋆ 表示对于 anchor i 的 ground-truth 是 positive，fifi 和 f⋆ifi⋆分别是anchor i 和 ground-truth 的四维边界框坐标。LclsLcls表示RPN网络的交叉熵，LregLreg表示用于平滑提议边界框回归的L1损失。NclsNcls表示在RPN中 batch 的 大小，LregLreg是anchor location的数目。λ用来平衡这个两个损失。</p>\n<ul>\n<li><p><strong>Noise Stream</strong></p>\n<p>  噪声流和RGB流的结构采用一样的主干结构 ResNet 101 网络。原图经过SRM层变成噪声图片输入噪声流当中，ResNet 101 网络提取噪声特征。噪声流与 RGB 流共享相同的 ROI 层，提取出的特征仅用于分类。需要注意的是对于边界框回归，作者只使用 RGB 通道，因为作者经过实验，发现RGB 特征在 RPN 网络中的性能优于噪声特征。</p>\n</li>\n<li><p><strong>Bilinear Pooling</strong></p>\n<p>  作者采用双线性池（BilinearPooling）的方法将 RGB 流与噪声流结合起来进行篡改检测。Bilinear Pooling 双线性池 可以很好的结合了双流 cnn 网络中的特征，同时保留空间信息，以提高检测置信度。下面是双线性池的结构。</p>\n<p>  <img src=\"https://qiniuy.tzle1.com/FnNjLvZdJl6wKxyt-_nhJt6QowdS\" alt=\"img\"></p>\n<p>  直观上理解，所谓bilinear pooling，就是先把在同一位置上的两个特征双线性融合（相乘）后得到矩阵 ，对所有位置进行sum pooling（也可以是max pooling，但一般采用sum pooling以方便进行矩阵运算）得到矩阵，最后把矩阵展开成一个向量，记为bilinear vector。对进行sqrt操作和L2归一化操作后，就得到融合后的特征。将RGB特征和噪声特征经过双线性池融合的特征用于分类，经过全连接层和 softmax 层获得 RoI regions 的篡改类型。总的损失函数如下：</p>\n</li>\n</ul>\n<p>$$<br>L_{\\text {total }}=L_{R P N}+L_{\\text {tamper }}\\left(f_{R G B}, f_{N}\\right)+L_{b b o x}\\left(f_{R G B}\\right)<br>$$</p>\n<p>LRPNLRPN是RPN网络中的loss。LtamperLtamper表示最后的交叉熵分类损失；LbboxLbbox表示最后的边界框回归损失；fRGBfRGB和fNfN表示来自RGB和noise stream的RoI features。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>简介</strong></p>\n<p>网络包含RGB流和噪声流，其中RGB流用于提取RGB图像的特征，以发现篡改的伪像，例如强烈的对比度差异，不自然的篡改边界等，另一个是噪声流，它利用从富隐写分析模型分析的滤波器层（SRM）提取的噪声特征来发现真实区域和篡改区域之间的噪声不一致。然后，通过双线性池化层融合来自两个流的特征根据丰富的特征，根据RGB特征和噪声特征来检测图像篡改区域和篡改的方式。</p>\n<p><strong>噪声流的线索依据</strong>.</p>\n<p>为什么要再加入一个噪声流，这是因为采用了局部噪声特征的方法。由于RGB通道不足以解决所有不同的篡改攻击方式，尤其是，经过精心后处理以隐藏拼接边界并减少对比度差异的篡改图像，这种情况对于仅用RGB流而言是较为困难的。当从一个图像（源）中删除一个对象并将其粘贴到另一个图像（目标）中时，源和目标图像之间的噪声特征不匹配。那么如何实现给图像增加噪声呢？作者希望通过Steganalysis Rich Model获得噪声图片。</p>\n<p>Steganalysis Rich Model 最早是应用在隐写术（是一种将消息嵌入到数字载体的技术如图像、视频等），SRM功能从30个基本滤波器开始，滤波后在输出附近使用最大值和最小值等非线性操作, 从该过程中获得的特征可以被视为局部噪声描述符。作者在实验中发现，仅使用 SRM 其中的3个滤波器就可以实现不错的性能，而应用所有30个内核并不能显着提高性能，因此使用下面3个滤波器获取像素值与相邻像素的差值估计来实现图片添加噪声的功能。</p>\n<p><img src=\"https://qiniuy.tzle1.com/Fgig0qWQZ5sW6seA2aAi7HXttRft\" alt=\"img\"></p>\n<p>下图是分别经过拼接，复制移动和擦除填充后的篡改图像，以及通过SRM层的噪声图，从图中可以清晰的看出加入噪声后篡改区域的噪声与真实区域的较大区别。</p>\n<p><img src=\"https://qiniuy.tzle1.com/Fl8aoktp9XeZw9QrfCOdP2vpYWO3\" alt=\"img\"></p>\n<p><strong>网络结构</strong></p>\n<p>作者采用了一个双流的FasterRCNN 的结构, 分别包括RGB流和噪声流。RGB流输入RGB图像， 噪声流中输入SRM图像。两部分共享相同的 ROI 层，同时执行分类和边界框回归两个操作。作者通过双线性池融合两个流的特征进行分类，RPN利用RGB流的特征进行边界框的回归。</p>\n<ul>\n<li><p><strong>RGB Stream</strong></p>\n<p>  RGB流采用的是单个Faster RCNN 网络提取RGB图像特征并用分类和边界框回归，主干使用的是 ResNet 101 网络提取图像特征，ResNet的最后一个卷积层的输出 feature map用于分类篡改类型。RGB流中的RPN网络利用这些特征为边界框回归提供 propose RoI，Loss function 如下：<br>  $$<br>  \\begin{array}{r}<br>  L_{R P N}\\left(g_{i}, f_{i}\\right)=\\frac{1}{N_{c l s}} \\sum_{i} L_{c l s}\\left(g_{i}, g_{i}^{\\star}\\right)<br>  +\\lambda \\frac{1}{N_{r e g}} \\sum_{i} g_{i}^{\\star} L_{r e g}\\left(f_{i}, f_{i}^{\\star}\\right)<br>  \\end{array}<br>  $$</p>\n</li>\n</ul>\n<p>gigi 表示 anchor i 在一个 batch 中是潜在的被篡改区域的概率， g⋆igi⋆ 表示对于 anchor i 的 ground-truth 是 positive，fifi 和 f⋆ifi⋆分别是anchor i 和 ground-truth 的四维边界框坐标。LclsLcls表示RPN网络的交叉熵，LregLreg表示用于平滑提议边界框回归的L1损失。NclsNcls表示在RPN中 batch 的 大小，LregLreg是anchor location的数目。λ用来平衡这个两个损失。</p>\n<ul>\n<li><p><strong>Noise Stream</strong></p>\n<p>  噪声流和RGB流的结构采用一样的主干结构 ResNet 101 网络。原图经过SRM层变成噪声图片输入噪声流当中，ResNet 101 网络提取噪声特征。噪声流与 RGB 流共享相同的 ROI 层，提取出的特征仅用于分类。需要注意的是对于边界框回归，作者只使用 RGB 通道，因为作者经过实验，发现RGB 特征在 RPN 网络中的性能优于噪声特征。</p>\n</li>\n<li><p><strong>Bilinear Pooling</strong></p>\n<p>  作者采用双线性池（BilinearPooling）的方法将 RGB 流与噪声流结合起来进行篡改检测。Bilinear Pooling 双线性池 可以很好的结合了双流 cnn 网络中的特征，同时保留空间信息，以提高检测置信度。下面是双线性池的结构。</p>\n<p>  <img src=\"https://qiniuy.tzle1.com/FnNjLvZdJl6wKxyt-_nhJt6QowdS\" alt=\"img\"></p>\n<p>  直观上理解，所谓bilinear pooling，就是先把在同一位置上的两个特征双线性融合（相乘）后得到矩阵 ，对所有位置进行sum pooling（也可以是max pooling，但一般采用sum pooling以方便进行矩阵运算）得到矩阵，最后把矩阵展开成一个向量，记为bilinear vector。对进行sqrt操作和L2归一化操作后，就得到融合后的特征。将RGB特征和噪声特征经过双线性池融合的特征用于分类，经过全连接层和 softmax 层获得 RoI regions 的篡改类型。总的损失函数如下：</p>\n</li>\n</ul>\n<p>$$<br>L_{\\text {total }}=L_{R P N}+L_{\\text {tamper }}\\left(f_{R G B}, f_{N}\\right)+L_{b b o x}\\left(f_{R G B}\\right)<br>$$</p>\n<p>LRPNLRPN是RPN网络中的loss。LtamperLtamper表示最后的交叉熵分类损失；LbboxLbbox表示最后的边界框回归损失；fRGBfRGB和fNfN表示来自RGB和noise stream的RoI features。</p>\n"},{"title":"图像篡改检测技术及数据集总结","no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"mathjax":false,"abbrlink":"3f292744","article_type":null,"date":"2021-10-27T16:00:00.000Z","top":null,"_content":"\n篡改在英文文献中常用`manipulation`、`tamper`、`forgery`这三个词表达。广义上的图像篡改指的是**对原始图像做了改动的操作**，这种改动操可以是：图像属性改变、图像格式转换、形态学处理、模糊处理、缩放剪裁（seam carving）等等。\n\n图像篡改类别可以粗略划分为`图像处理操作(manipulation)`和`图像篡改操作(tamper)`两类（按英文直译，manipulation是操作的意思，此类篡改有点类似仅对图像做非内容性的处理，而tamper按直译，则是对图像做了内容性的处理）：\n\n**Manipulation**：滤波处理（如中值滤波 Median Filtering）、模糊处理（如高斯模糊 Gaussian Blurring）、添加噪声（如高斯白噪声 Additive White Gaussian Noise）、重采样（Resampling）、压缩处理（如JPEG压缩 JPEG Compression）等。\n\n**Tamper** ：删除（Removal）、添加（Adding）、复制（Copy-move）、拼接（Splicing）等。\n\n图像篡改检测技术涉及以下领域:\n\n- 司法鉴定和公安办案中照片的真伪鉴定\n- 保险事故中照片的真伪鉴别\n- 新闻摄影和赛事照片的真伪鉴别\n- 电子交易票据图像的真伪鉴别\n\n<!-- more -->\n\n## 概述\n\n篡改检测问题实际上就是要检测出图像当中做过**改动的区域**。近几年，学术上更趋于集中研究splicing、copy-move、removal这三个类型图像篡改的检测问题。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/篡改检测-分类.jpg\"  alt=\"篡改检测-分类\" style=\"zoom: 33%;\" />\n\n如上图：\n\n- 图像拼接(Splicing)：将一张图的内容抠下来贴在另一张图上；\n- 复制移动(Copy-move)：将同一张图上的内容复制粘贴到另一个位置；\n- 擦除填充(removal)：操作将同一张图上的内容擦除掉。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/篡改检测-人脸和文字.jpg\" alt=\"篡改检测-人脸和文字\" style=\"zoom: 33%;\" />\n\n此外，对图像篡改检测的研究也有专门只针对人脸和文字的，上图上幅来自[Andreas Rossler et al., 2018](https://arxiv.org/abs/1803.09179)，是专门针对人脸篡改的检测；下幅来自[Yulia S. Chernyshova et al., 2018](https://arxiv.org/abs/1810.08016)，是专门针对文字篡改的检测。\n\n## 数据集\n\n| 数据集          | 图片数   | 篡改类型                      | 描述                                        | 链接                                                         |\n| --------------- | -------- | ----------------------------- | ------------------------------------------- | ------------------------------------------------------------ |\n| CASIA v1.0/v2.0 | 921/5123 | splicing; copy move;          | 只提供原图、篡改图，不包含GroundTruth;      | [Kaggle(提供原图、篡改图)](https://www.kaggle.com/sophatvathana/casia-dataset); [@namtpham(在原图、篡改图的基础上提供了GroundTruth)](https://github.com/namtpham/casia2groundtruth) |\n| Columbia        | 183      | splicing;                     | **基于未压缩图像的拼接**，提供GroundTruth;  | [Columbia Uncompressed Image Splicing Detection Evaluation Dataset](https://www.ee.columbia.edu/ln/dvmm/downloads/authsplcuncmp/) |\n| NIST 2016       | 564      | splicing; copy move; removal; | 提供GroundTruth;                            | [NIST Public Media Forensics Data](https://mfc.nist.gov/)    |\n| COVERAGE        | 100      | copy move                     | **专注于copy-move**，提供GroundTruth;       | [Coverage](https://github.com/wenbihan/coverage)             |\n| Pawel           | 220      | object-insertion; removal     | **手工篡改数据集**，非常走心的;             | [Pawel korus-Realistic Tampering Dataset](https://pkorus.pl/downloads) |\n| PS-Battles      | 40.2G    | 类型诸多                      | **PS社区手工篡改**，篡改类型多，篡改更真实; | [Ps Battle DataSet](https://github.com/MuskAI/PS-Battles-master); [原论文](https://arxiv.org/abs/1804.04866) |\n\n百度网盘链接：（包含 NIST, COVERAGE, Columbia）\n链接：https://pan.baidu.com/s/1Rn18JLDV7WviUvP8UsRZVQ \n提取码：ptur \n\n##  Related Work\n\n人类在识别复制移动方面可能比检测拼接和移除更好。这是因为在复制移动图像中，人眼可以感觉到类似物体的重复。对于拼接和移除图像，人类在很大程度上依靠寻找明显的边缘不连续和照明不一致来确定是否发生了篡改。因此，当在经过良好篡改的图像中视觉上看不到不一致之处时，人类将无法检测到篡改。之前传统的图像处理方法提出了探索边缘不连续和照明不一致性的算法，以协助并超越人类在篡改检测任务中的能力。\n\n当前深度学习的图像篡改区域定位方法主要有以下三种方向：\n\n- 将篡改区域定位认为是像素级的二分类，采用图像分割的算法来定位篡改区域。\n- 将篡改区域定位当作是目标检测任务，采用目标检测算法来定位篡改区域。\n- 将篡改区域定位当作是局部异常检测，采用CNN + LSTM网络检测图像中的局部异常。\n\n接下来总结近几年这三个方向具有代表性的图像篡改区域定位方法。\n\n### RGB-N\n\n**Learning Rich Features for Image Manipulation Detection**\n\n发表在：CVPR 2018\n\n论文：https://arxiv.org/abs/1805.04953\n\n代码：https://github.com/LarryJiang134/Image_manipulation_detection\n\n类型：拼接、移除\n\n方法：提出了一种双流的Faster R-CNN网络，给定manipulated image，对其进行端到端的训练，以便检测被篡改的区域。双流分别为RGB stream、noise stream。其中，RGB stream主要目的是从RGB图像输入中提取特征，从而发现篡改区域强烈对比差异，非自然的篡改边界等之类的tampering artifacts。Noise stream 主要利用噪声特征去发现在真实区域和篡改区域之间的噪声不一致性，噪声特征是从steganalysis rich model filter layer中提取的。之后，通过bilinear pooling layer融合两个流的特征，以便进一步结合这两种模态的空间信息。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/FsNgw8pkib9mH2an56FHoiuU5QVs\" alt=\"RGB-N\" style=\"zoom: 80%;\" />\n\n实验结果：CASIA 2.0作为训练集 CASIA1.0作为测试集。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fo7Gx_G7E6ysL2U4IuNkgqo-uZrW\" alt=\"RGB-N Result\" />\n\n**简评：**\n\n- 该方法利用篡改区域与原图噪声不一致的线索，提出了**双流Fast RCNN**，这种方法的优势在于其具有很好的鲁棒性，这是由于**当篡改者利用JEPG压缩或者resize**隐藏时，噪声不一致的线索会更加突显出来，因此其具有很好的鲁棒性和抗干扰的能力。作者在文中分享了这一方法的局限也就是**在复制移动的篡改方式下表现不太好**，其原因有两个方面，首先，复制的区域来自同一张图像，这产生了相似的噪声分布，从而混淆了的噪声流。并且，两个区域通常具有相同的对比度。\n\n\n\n### ManTra-Net\n\n**ManTra-Net: Manipulation Tracing Network For Detection And Localization of Image Forgeries With Anomalous Features**\n\n发表在：CVPR2019\n\n论文：https://openaccess.thecvf.com/content_CVPR_2019/html/Wu_ManTra-Net_Manipulation_Tracing_Network_for_Detection_and_Localization_of_Image_CVPR_2019_paper.html\n\n代码：https://github.com/ISICV/ManTraNet\n\n类型：拼接、移除、复制粘贴 \n\n方法：作者提出了一个不需要额外的预处理和后处理的篡改检测网络ManTra-Net。此网络是一个全卷积网络，可以处理任意尺寸的图像和多种篡改类型。主要的贡献在于用一个自监督学习的方式从385篡改类型中学习特征，可以概括为压缩（JPEG一次、二次）、模糊（高斯、中值、小波）、形态学(膨胀 腐蚀)、插值（线性、二次、三次）、噪声（高斯、脉冲、均匀）、对比度、直方图均衡化等，并且将篡改定位问题当做一个局部异常点检测问题来解决。使用Z-score特征表示局部异常，使用long short-term memory solution进行评估。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fkm-o0qyQw_j_Cb9mcQ2EVQ0lvL6\" alt=\"ManTra-Net\"/>\n\n实验结果：CASIA 2.0作为训练集 CASIA1.0作为测试集。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fk5s46y_eiAhNBQLLqHvapvKxKjZ\" alt=\"ManTra-Net Result\" style=\"zoom:;\" />\n\n**简评：**\n\n- ManTra-Net 的创新之处在于设计了一个简单而有效的**自我监督学习任务**，以通过对385种图像操作类型进行分类来学习强大的图像操作轨迹。此外，我们**将伪造定位问题公式化为局部异常检测问题，设计Z分数功能以捕获局部异常**。ManTra-Net的优点主要在于它对于绝大多数的篡改攻击方式的有效果，因为它利用了自监督学习篡改的类型，因此有效的检测多种篡改方式，并且具有不错的鲁棒性，可以说是每个方式都有优势，但单独一种方式下不一定是最优的方法。\n\n​\t\n\n### RRU-Net\n\n**RRU-Net: The Ringed Residual U-Net for Image Splicing Forgery Detection**\n\n发表在：CVPRW 2019\n论文：https://ieeexplore.ieee.org/document/9025485\n代码：https://github.com/yelusaleng/RRU-Net\n类型：拼接\n方法：作者基于 U-Net 提出了一种环状残差网络 RRU-Net 用于图像拼接伪造检测。**RRU-Net 是一个端到端的图像本质属性分割网络**，无需任何预处理和后处理即可完成伪造区域检测。RRU-Net 的核心思想是加强 CNN 的学习方式，并由CNN中残差的传播和反馈过程实现。残差传播调用输入的特征信息以解决更深层网络中的梯度退化问题；残差反馈合并输入特征信息，使未篡改区域和篡改区域之间的图像属性差异更加明显。\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Ft7ySxL1_DlI0SGPRrEoDSACPhPi\" alt=\"RRU-Net\" style=\"zoom:80%;\"/>\n\n实验结果：RRU-NET 在 CASIA1.0 和 COLUMB 两个伪造图像数据集上的实验结果，CASIA 1.0 包括的篡改方式有拼接和复制粘贴攻击方式，但是本文只选取了其中的拼接攻击方式的数据集。COLUMB 是只包含拼接攻击的数据集。\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fr-Jmx8q_wE7e3EVP6JH5ZwEgEVk\" alt=\"RRU-Net\" style=\"zoom:80%;\"/>\n\n**简评：**\n\n- RRU-Net的主要创新体现在 Ringed Residual Structure，与其它方法不同是 RRU-Net 不直接设置检测伪造图像痕迹的特征，而是通过 residual feedback 机制让 CNN 自己去学习图片属性的差异特征，属于一种强化 CNN 学习的方法，并且经过实验证明了这种利用残差反馈方式自动学习图片属性差异的特征是有效的。\n\n## 比赛\n\n###  [**天池 - 伪造图像的篡改检测 - 长期赛**](https://tianchi.aliyun.com/competition/entrance/531812/information)\n\n**赛题背景**\n\n本次比赛的背景是由于随着各种P图工具的普及，篡改伪造出视觉无痕迹的假图门槛大幅降低，于是我们看到大量的假图用于散播谣言、编造虚假新闻、非法获取经济利益，更有甚者，还可能会被用来恶意地充当法庭证据。因此需要设计出能够准确检测出图像篡改区域的算法，避免假图造成的危害。\n\n**题目描述**\n\n比赛采用的数据为证书文档类图像，其中包括10类不同图像。\n\n比赛的任务是通过提供的训练集学习出有效的检测算法，对测试集的伪造图像进行篡改定位。比赛的难点在于其分割区域是不能依靠边缘轮廓，因为篡改特征是偏向于弱信号特征（不可视的，跟内容特征弱相关），而且相对要分割出来的区域可能面积偏小。\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fk-_XfgIrmSXAmGnahiX8GARxPqz\" alt=\"篡改检测比赛\"/>\n\n\n\n### 比赛TOP3分享\n\n[天池伪造图像的篡改检测比赛TOP3分享](https://mp.weixin.qq.com/s?__biz=MzU4MzQ4NTk5NQ==&mid=2247492758&idx=1&sn=7a8537b7e23957ea559bf5fd66a88ee0)\n\n\n\n参考资料：\n[1]. [图像的篡改取证应用前景](http://blog.sina.com.cn/s/blog_8fde4dbf0101ay5g.html)\n[2]. [PaperReadingGroup-2-篡改检测小综述](https://zhuanlan.zhihu.com/p/85030394)\n[3]. [图像篡改检测方法总结](https://mp.weixin.qq.com/s/gdCv4SLsVibolPHQ62Z1dw)\n[4]. [梁君牧-cnblog](https://www.cnblogs.com/lwp-nicol)\n\n\n\n\n\n","source":"_posts/02 图像篡改检测技术及数据集总结.md","raw":"---\ntitle: 图像篡改检测技术及数据集总结\ntag:\n  - 论文阅读\n  - 图像篡改\ncategories:\n  - [论文阅读, 图像篡改]\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\nmathjax: false\nabbrlink: 3f292744\narticle_type:\ndate: 2021-10-28\ntop:\n---\n\n篡改在英文文献中常用`manipulation`、`tamper`、`forgery`这三个词表达。广义上的图像篡改指的是**对原始图像做了改动的操作**，这种改动操可以是：图像属性改变、图像格式转换、形态学处理、模糊处理、缩放剪裁（seam carving）等等。\n\n图像篡改类别可以粗略划分为`图像处理操作(manipulation)`和`图像篡改操作(tamper)`两类（按英文直译，manipulation是操作的意思，此类篡改有点类似仅对图像做非内容性的处理，而tamper按直译，则是对图像做了内容性的处理）：\n\n**Manipulation**：滤波处理（如中值滤波 Median Filtering）、模糊处理（如高斯模糊 Gaussian Blurring）、添加噪声（如高斯白噪声 Additive White Gaussian Noise）、重采样（Resampling）、压缩处理（如JPEG压缩 JPEG Compression）等。\n\n**Tamper** ：删除（Removal）、添加（Adding）、复制（Copy-move）、拼接（Splicing）等。\n\n图像篡改检测技术涉及以下领域:\n\n- 司法鉴定和公安办案中照片的真伪鉴定\n- 保险事故中照片的真伪鉴别\n- 新闻摄影和赛事照片的真伪鉴别\n- 电子交易票据图像的真伪鉴别\n\n<!-- more -->\n\n## 概述\n\n篡改检测问题实际上就是要检测出图像当中做过**改动的区域**。近几年，学术上更趋于集中研究splicing、copy-move、removal这三个类型图像篡改的检测问题。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/篡改检测-分类.jpg\"  alt=\"篡改检测-分类\" style=\"zoom: 33%;\" />\n\n如上图：\n\n- 图像拼接(Splicing)：将一张图的内容抠下来贴在另一张图上；\n- 复制移动(Copy-move)：将同一张图上的内容复制粘贴到另一个位置；\n- 擦除填充(removal)：操作将同一张图上的内容擦除掉。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/篡改检测-人脸和文字.jpg\" alt=\"篡改检测-人脸和文字\" style=\"zoom: 33%;\" />\n\n此外，对图像篡改检测的研究也有专门只针对人脸和文字的，上图上幅来自[Andreas Rossler et al., 2018](https://arxiv.org/abs/1803.09179)，是专门针对人脸篡改的检测；下幅来自[Yulia S. Chernyshova et al., 2018](https://arxiv.org/abs/1810.08016)，是专门针对文字篡改的检测。\n\n## 数据集\n\n| 数据集          | 图片数   | 篡改类型                      | 描述                                        | 链接                                                         |\n| --------------- | -------- | ----------------------------- | ------------------------------------------- | ------------------------------------------------------------ |\n| CASIA v1.0/v2.0 | 921/5123 | splicing; copy move;          | 只提供原图、篡改图，不包含GroundTruth;      | [Kaggle(提供原图、篡改图)](https://www.kaggle.com/sophatvathana/casia-dataset); [@namtpham(在原图、篡改图的基础上提供了GroundTruth)](https://github.com/namtpham/casia2groundtruth) |\n| Columbia        | 183      | splicing;                     | **基于未压缩图像的拼接**，提供GroundTruth;  | [Columbia Uncompressed Image Splicing Detection Evaluation Dataset](https://www.ee.columbia.edu/ln/dvmm/downloads/authsplcuncmp/) |\n| NIST 2016       | 564      | splicing; copy move; removal; | 提供GroundTruth;                            | [NIST Public Media Forensics Data](https://mfc.nist.gov/)    |\n| COVERAGE        | 100      | copy move                     | **专注于copy-move**，提供GroundTruth;       | [Coverage](https://github.com/wenbihan/coverage)             |\n| Pawel           | 220      | object-insertion; removal     | **手工篡改数据集**，非常走心的;             | [Pawel korus-Realistic Tampering Dataset](https://pkorus.pl/downloads) |\n| PS-Battles      | 40.2G    | 类型诸多                      | **PS社区手工篡改**，篡改类型多，篡改更真实; | [Ps Battle DataSet](https://github.com/MuskAI/PS-Battles-master); [原论文](https://arxiv.org/abs/1804.04866) |\n\n百度网盘链接：（包含 NIST, COVERAGE, Columbia）\n链接：https://pan.baidu.com/s/1Rn18JLDV7WviUvP8UsRZVQ \n提取码：ptur \n\n##  Related Work\n\n人类在识别复制移动方面可能比检测拼接和移除更好。这是因为在复制移动图像中，人眼可以感觉到类似物体的重复。对于拼接和移除图像，人类在很大程度上依靠寻找明显的边缘不连续和照明不一致来确定是否发生了篡改。因此，当在经过良好篡改的图像中视觉上看不到不一致之处时，人类将无法检测到篡改。之前传统的图像处理方法提出了探索边缘不连续和照明不一致性的算法，以协助并超越人类在篡改检测任务中的能力。\n\n当前深度学习的图像篡改区域定位方法主要有以下三种方向：\n\n- 将篡改区域定位认为是像素级的二分类，采用图像分割的算法来定位篡改区域。\n- 将篡改区域定位当作是目标检测任务，采用目标检测算法来定位篡改区域。\n- 将篡改区域定位当作是局部异常检测，采用CNN + LSTM网络检测图像中的局部异常。\n\n接下来总结近几年这三个方向具有代表性的图像篡改区域定位方法。\n\n### RGB-N\n\n**Learning Rich Features for Image Manipulation Detection**\n\n发表在：CVPR 2018\n\n论文：https://arxiv.org/abs/1805.04953\n\n代码：https://github.com/LarryJiang134/Image_manipulation_detection\n\n类型：拼接、移除\n\n方法：提出了一种双流的Faster R-CNN网络，给定manipulated image，对其进行端到端的训练，以便检测被篡改的区域。双流分别为RGB stream、noise stream。其中，RGB stream主要目的是从RGB图像输入中提取特征，从而发现篡改区域强烈对比差异，非自然的篡改边界等之类的tampering artifacts。Noise stream 主要利用噪声特征去发现在真实区域和篡改区域之间的噪声不一致性，噪声特征是从steganalysis rich model filter layer中提取的。之后，通过bilinear pooling layer融合两个流的特征，以便进一步结合这两种模态的空间信息。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/FsNgw8pkib9mH2an56FHoiuU5QVs\" alt=\"RGB-N\" style=\"zoom: 80%;\" />\n\n实验结果：CASIA 2.0作为训练集 CASIA1.0作为测试集。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fo7Gx_G7E6ysL2U4IuNkgqo-uZrW\" alt=\"RGB-N Result\" />\n\n**简评：**\n\n- 该方法利用篡改区域与原图噪声不一致的线索，提出了**双流Fast RCNN**，这种方法的优势在于其具有很好的鲁棒性，这是由于**当篡改者利用JEPG压缩或者resize**隐藏时，噪声不一致的线索会更加突显出来，因此其具有很好的鲁棒性和抗干扰的能力。作者在文中分享了这一方法的局限也就是**在复制移动的篡改方式下表现不太好**，其原因有两个方面，首先，复制的区域来自同一张图像，这产生了相似的噪声分布，从而混淆了的噪声流。并且，两个区域通常具有相同的对比度。\n\n\n\n### ManTra-Net\n\n**ManTra-Net: Manipulation Tracing Network For Detection And Localization of Image Forgeries With Anomalous Features**\n\n发表在：CVPR2019\n\n论文：https://openaccess.thecvf.com/content_CVPR_2019/html/Wu_ManTra-Net_Manipulation_Tracing_Network_for_Detection_and_Localization_of_Image_CVPR_2019_paper.html\n\n代码：https://github.com/ISICV/ManTraNet\n\n类型：拼接、移除、复制粘贴 \n\n方法：作者提出了一个不需要额外的预处理和后处理的篡改检测网络ManTra-Net。此网络是一个全卷积网络，可以处理任意尺寸的图像和多种篡改类型。主要的贡献在于用一个自监督学习的方式从385篡改类型中学习特征，可以概括为压缩（JPEG一次、二次）、模糊（高斯、中值、小波）、形态学(膨胀 腐蚀)、插值（线性、二次、三次）、噪声（高斯、脉冲、均匀）、对比度、直方图均衡化等，并且将篡改定位问题当做一个局部异常点检测问题来解决。使用Z-score特征表示局部异常，使用long short-term memory solution进行评估。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fkm-o0qyQw_j_Cb9mcQ2EVQ0lvL6\" alt=\"ManTra-Net\"/>\n\n实验结果：CASIA 2.0作为训练集 CASIA1.0作为测试集。\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fk5s46y_eiAhNBQLLqHvapvKxKjZ\" alt=\"ManTra-Net Result\" style=\"zoom:;\" />\n\n**简评：**\n\n- ManTra-Net 的创新之处在于设计了一个简单而有效的**自我监督学习任务**，以通过对385种图像操作类型进行分类来学习强大的图像操作轨迹。此外，我们**将伪造定位问题公式化为局部异常检测问题，设计Z分数功能以捕获局部异常**。ManTra-Net的优点主要在于它对于绝大多数的篡改攻击方式的有效果，因为它利用了自监督学习篡改的类型，因此有效的检测多种篡改方式，并且具有不错的鲁棒性，可以说是每个方式都有优势，但单独一种方式下不一定是最优的方法。\n\n​\t\n\n### RRU-Net\n\n**RRU-Net: The Ringed Residual U-Net for Image Splicing Forgery Detection**\n\n发表在：CVPRW 2019\n论文：https://ieeexplore.ieee.org/document/9025485\n代码：https://github.com/yelusaleng/RRU-Net\n类型：拼接\n方法：作者基于 U-Net 提出了一种环状残差网络 RRU-Net 用于图像拼接伪造检测。**RRU-Net 是一个端到端的图像本质属性分割网络**，无需任何预处理和后处理即可完成伪造区域检测。RRU-Net 的核心思想是加强 CNN 的学习方式，并由CNN中残差的传播和反馈过程实现。残差传播调用输入的特征信息以解决更深层网络中的梯度退化问题；残差反馈合并输入特征信息，使未篡改区域和篡改区域之间的图像属性差异更加明显。\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Ft7ySxL1_DlI0SGPRrEoDSACPhPi\" alt=\"RRU-Net\" style=\"zoom:80%;\"/>\n\n实验结果：RRU-NET 在 CASIA1.0 和 COLUMB 两个伪造图像数据集上的实验结果，CASIA 1.0 包括的篡改方式有拼接和复制粘贴攻击方式，但是本文只选取了其中的拼接攻击方式的数据集。COLUMB 是只包含拼接攻击的数据集。\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fr-Jmx8q_wE7e3EVP6JH5ZwEgEVk\" alt=\"RRU-Net\" style=\"zoom:80%;\"/>\n\n**简评：**\n\n- RRU-Net的主要创新体现在 Ringed Residual Structure，与其它方法不同是 RRU-Net 不直接设置检测伪造图像痕迹的特征，而是通过 residual feedback 机制让 CNN 自己去学习图片属性的差异特征，属于一种强化 CNN 学习的方法，并且经过实验证明了这种利用残差反馈方式自动学习图片属性差异的特征是有效的。\n\n## 比赛\n\n###  [**天池 - 伪造图像的篡改检测 - 长期赛**](https://tianchi.aliyun.com/competition/entrance/531812/information)\n\n**赛题背景**\n\n本次比赛的背景是由于随着各种P图工具的普及，篡改伪造出视觉无痕迹的假图门槛大幅降低，于是我们看到大量的假图用于散播谣言、编造虚假新闻、非法获取经济利益，更有甚者，还可能会被用来恶意地充当法庭证据。因此需要设计出能够准确检测出图像篡改区域的算法，避免假图造成的危害。\n\n**题目描述**\n\n比赛采用的数据为证书文档类图像，其中包括10类不同图像。\n\n比赛的任务是通过提供的训练集学习出有效的检测算法，对测试集的伪造图像进行篡改定位。比赛的难点在于其分割区域是不能依靠边缘轮廓，因为篡改特征是偏向于弱信号特征（不可视的，跟内容特征弱相关），而且相对要分割出来的区域可能面积偏小。\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fk-_XfgIrmSXAmGnahiX8GARxPqz\" alt=\"篡改检测比赛\"/>\n\n\n\n### 比赛TOP3分享\n\n[天池伪造图像的篡改检测比赛TOP3分享](https://mp.weixin.qq.com/s?__biz=MzU4MzQ4NTk5NQ==&mid=2247492758&idx=1&sn=7a8537b7e23957ea559bf5fd66a88ee0)\n\n\n\n参考资料：\n[1]. [图像的篡改取证应用前景](http://blog.sina.com.cn/s/blog_8fde4dbf0101ay5g.html)\n[2]. [PaperReadingGroup-2-篡改检测小综述](https://zhuanlan.zhihu.com/p/85030394)\n[3]. [图像篡改检测方法总结](https://mp.weixin.qq.com/s/gdCv4SLsVibolPHQ62Z1dw)\n[4]. [梁君牧-cnblog](https://www.cnblogs.com/lwp-nicol)\n\n\n\n\n\n","slug":"02 图像篡改检测技术及数据集总结","published":1,"updated":"2022-11-26T20:35:06.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4i000f64rghshqdrfi","content":"<p>篡改在英文文献中常用<code>manipulation</code>、<code>tamper</code>、<code>forgery</code>这三个词表达。广义上的图像篡改指的是<strong>对原始图像做了改动的操作</strong>，这种改动操可以是：图像属性改变、图像格式转换、形态学处理、模糊处理、缩放剪裁（seam carving）等等。</p>\n<p>图像篡改类别可以粗略划分为<code>图像处理操作(manipulation)</code>和<code>图像篡改操作(tamper)</code>两类（按英文直译，manipulation是操作的意思，此类篡改有点类似仅对图像做非内容性的处理，而tamper按直译，则是对图像做了内容性的处理）：</p>\n<p><strong>Manipulation</strong>：滤波处理（如中值滤波 Median Filtering）、模糊处理（如高斯模糊 Gaussian Blurring）、添加噪声（如高斯白噪声 Additive White Gaussian Noise）、重采样（Resampling）、压缩处理（如JPEG压缩 JPEG Compression）等。</p>\n<p><strong>Tamper</strong> ：删除（Removal）、添加（Adding）、复制（Copy-move）、拼接（Splicing）等。</p>\n<p>图像篡改检测技术涉及以下领域:</p>\n<ul>\n<li>司法鉴定和公安办案中照片的真伪鉴定</li>\n<li>保险事故中照片的真伪鉴别</li>\n<li>新闻摄影和赛事照片的真伪鉴别</li>\n<li>电子交易票据图像的真伪鉴别</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>篡改检测问题实际上就是要检测出图像当中做过<strong>改动的区域</strong>。近几年，学术上更趋于集中研究splicing、copy-move、removal这三个类型图像篡改的检测问题。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/篡改检测-分类.jpg\"  alt=\"篡改检测-分类\" style=\"zoom: 33%;\" />\n\n<p>如上图：</p>\n<ul>\n<li>图像拼接(Splicing)：将一张图的内容抠下来贴在另一张图上；</li>\n<li>复制移动(Copy-move)：将同一张图上的内容复制粘贴到另一个位置；</li>\n<li>擦除填充(removal)：操作将同一张图上的内容擦除掉。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/篡改检测-人脸和文字.jpg\" alt=\"篡改检测-人脸和文字\" style=\"zoom: 33%;\" />\n\n<p>此外，对图像篡改检测的研究也有专门只针对人脸和文字的，上图上幅来自<a href=\"https://arxiv.org/abs/1803.09179\">Andreas Rossler et al., 2018</a>，是专门针对人脸篡改的检测；下幅来自<a href=\"https://arxiv.org/abs/1810.08016\">Yulia S. Chernyshova et al., 2018</a>，是专门针对文字篡改的检测。</p>\n<h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>图片数</th>\n<th>篡改类型</th>\n<th>描述</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CASIA v1.0/v2.0</td>\n<td>921/5123</td>\n<td>splicing; copy move;</td>\n<td>只提供原图、篡改图，不包含GroundTruth;</td>\n<td><a href=\"https://www.kaggle.com/sophatvathana/casia-dataset\">Kaggle(提供原图、篡改图)</a>; <a href=\"https://github.com/namtpham/casia2groundtruth\">@namtpham(在原图、篡改图的基础上提供了GroundTruth)</a></td>\n</tr>\n<tr>\n<td>Columbia</td>\n<td>183</td>\n<td>splicing;</td>\n<td><strong>基于未压缩图像的拼接</strong>，提供GroundTruth;</td>\n<td><a href=\"https://www.ee.columbia.edu/ln/dvmm/downloads/authsplcuncmp/\">Columbia Uncompressed Image Splicing Detection Evaluation Dataset</a></td>\n</tr>\n<tr>\n<td>NIST 2016</td>\n<td>564</td>\n<td>splicing; copy move; removal;</td>\n<td>提供GroundTruth;</td>\n<td><a href=\"https://mfc.nist.gov/\">NIST Public Media Forensics Data</a></td>\n</tr>\n<tr>\n<td>COVERAGE</td>\n<td>100</td>\n<td>copy move</td>\n<td><strong>专注于copy-move</strong>，提供GroundTruth;</td>\n<td><a href=\"https://github.com/wenbihan/coverage\">Coverage</a></td>\n</tr>\n<tr>\n<td>Pawel</td>\n<td>220</td>\n<td>object-insertion; removal</td>\n<td><strong>手工篡改数据集</strong>，非常走心的;</td>\n<td><a href=\"https://pkorus.pl/downloads\">Pawel korus-Realistic Tampering Dataset</a></td>\n</tr>\n<tr>\n<td>PS-Battles</td>\n<td>40.2G</td>\n<td>类型诸多</td>\n<td><strong>PS社区手工篡改</strong>，篡改类型多，篡改更真实;</td>\n<td><a href=\"https://github.com/MuskAI/PS-Battles-master\">Ps Battle DataSet</a>; <a href=\"https://arxiv.org/abs/1804.04866\">原论文</a></td>\n</tr>\n</tbody></table>\n<p>百度网盘链接：（包含 NIST, COVERAGE, Columbia）<br>链接：<a href=\"https://pan.baidu.com/s/1Rn18JLDV7WviUvP8UsRZVQ\">https://pan.baidu.com/s/1Rn18JLDV7WviUvP8UsRZVQ</a><br>提取码：ptur </p>\n<h2 id=\"Related-Work\"><a href=\"#Related-Work\" class=\"headerlink\" title=\"Related Work\"></a>Related Work</h2><p>人类在识别复制移动方面可能比检测拼接和移除更好。这是因为在复制移动图像中，人眼可以感觉到类似物体的重复。对于拼接和移除图像，人类在很大程度上依靠寻找明显的边缘不连续和照明不一致来确定是否发生了篡改。因此，当在经过良好篡改的图像中视觉上看不到不一致之处时，人类将无法检测到篡改。之前传统的图像处理方法提出了探索边缘不连续和照明不一致性的算法，以协助并超越人类在篡改检测任务中的能力。</p>\n<p>当前深度学习的图像篡改区域定位方法主要有以下三种方向：</p>\n<ul>\n<li>将篡改区域定位认为是像素级的二分类，采用图像分割的算法来定位篡改区域。</li>\n<li>将篡改区域定位当作是目标检测任务，采用目标检测算法来定位篡改区域。</li>\n<li>将篡改区域定位当作是局部异常检测，采用CNN + LSTM网络检测图像中的局部异常。</li>\n</ul>\n<p>接下来总结近几年这三个方向具有代表性的图像篡改区域定位方法。</p>\n<h3 id=\"RGB-N\"><a href=\"#RGB-N\" class=\"headerlink\" title=\"RGB-N\"></a>RGB-N</h3><p><strong>Learning Rich Features for Image Manipulation Detection</strong></p>\n<p>发表在：CVPR 2018</p>\n<p>论文：<a href=\"https://arxiv.org/abs/1805.04953\">https://arxiv.org/abs/1805.04953</a></p>\n<p>代码：<a href=\"https://github.com/LarryJiang134/Image_manipulation_detection\">https://github.com/LarryJiang134/Image_manipulation_detection</a></p>\n<p>类型：拼接、移除</p>\n<p>方法：提出了一种双流的Faster R-CNN网络，给定manipulated image，对其进行端到端的训练，以便检测被篡改的区域。双流分别为RGB stream、noise stream。其中，RGB stream主要目的是从RGB图像输入中提取特征，从而发现篡改区域强烈对比差异，非自然的篡改边界等之类的tampering artifacts。Noise stream 主要利用噪声特征去发现在真实区域和篡改区域之间的噪声不一致性，噪声特征是从steganalysis rich model filter layer中提取的。之后，通过bilinear pooling layer融合两个流的特征，以便进一步结合这两种模态的空间信息。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/FsNgw8pkib9mH2an56FHoiuU5QVs\" alt=\"RGB-N\" style=\"zoom: 80%;\" />\n\n<p>实验结果：CASIA 2.0作为训练集 CASIA1.0作为测试集。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fo7Gx_G7E6ysL2U4IuNkgqo-uZrW\" alt=\"RGB-N Result\" />\n\n<p><strong>简评：</strong></p>\n<ul>\n<li>该方法利用篡改区域与原图噪声不一致的线索，提出了<strong>双流Fast RCNN</strong>，这种方法的优势在于其具有很好的鲁棒性，这是由于<strong>当篡改者利用JEPG压缩或者resize</strong>隐藏时，噪声不一致的线索会更加突显出来，因此其具有很好的鲁棒性和抗干扰的能力。作者在文中分享了这一方法的局限也就是<strong>在复制移动的篡改方式下表现不太好</strong>，其原因有两个方面，首先，复制的区域来自同一张图像，这产生了相似的噪声分布，从而混淆了的噪声流。并且，两个区域通常具有相同的对比度。</li>\n</ul>\n<h3 id=\"ManTra-Net\"><a href=\"#ManTra-Net\" class=\"headerlink\" title=\"ManTra-Net\"></a>ManTra-Net</h3><p><strong>ManTra-Net: Manipulation Tracing Network For Detection And Localization of Image Forgeries With Anomalous Features</strong></p>\n<p>发表在：CVPR2019</p>\n<p>论文：<a href=\"https://openaccess.thecvf.com/content_CVPR_2019/html/Wu_ManTra-Net_Manipulation_Tracing_Network_for_Detection_and_Localization_of_Image_CVPR_2019_paper.html\">https://openaccess.thecvf.com/content_CVPR_2019/html/Wu_ManTra-Net_Manipulation_Tracing_Network_for_Detection_and_Localization_of_Image_CVPR_2019_paper.html</a></p>\n<p>代码：<a href=\"https://github.com/ISICV/ManTraNet\">https://github.com/ISICV/ManTraNet</a></p>\n<p>类型：拼接、移除、复制粘贴 </p>\n<p>方法：作者提出了一个不需要额外的预处理和后处理的篡改检测网络ManTra-Net。此网络是一个全卷积网络，可以处理任意尺寸的图像和多种篡改类型。主要的贡献在于用一个自监督学习的方式从385篡改类型中学习特征，可以概括为压缩（JPEG一次、二次）、模糊（高斯、中值、小波）、形态学(膨胀 腐蚀)、插值（线性、二次、三次）、噪声（高斯、脉冲、均匀）、对比度、直方图均衡化等，并且将篡改定位问题当做一个局部异常点检测问题来解决。使用Z-score特征表示局部异常，使用long short-term memory solution进行评估。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fkm-o0qyQw_j_Cb9mcQ2EVQ0lvL6\" alt=\"ManTra-Net\"/>\n\n<p>实验结果：CASIA 2.0作为训练集 CASIA1.0作为测试集。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fk5s46y_eiAhNBQLLqHvapvKxKjZ\" alt=\"ManTra-Net Result\" style=\"zoom:;\" />\n\n<p><strong>简评：</strong></p>\n<ul>\n<li>ManTra-Net 的创新之处在于设计了一个简单而有效的<strong>自我监督学习任务</strong>，以通过对385种图像操作类型进行分类来学习强大的图像操作轨迹。此外，我们<strong>将伪造定位问题公式化为局部异常检测问题，设计Z分数功能以捕获局部异常</strong>。ManTra-Net的优点主要在于它对于绝大多数的篡改攻击方式的有效果，因为它利用了自监督学习篡改的类型，因此有效的检测多种篡改方式，并且具有不错的鲁棒性，可以说是每个方式都有优势，但单独一种方式下不一定是最优的方法。</li>\n</ul>\n<p>​    </p>\n<h3 id=\"RRU-Net\"><a href=\"#RRU-Net\" class=\"headerlink\" title=\"RRU-Net\"></a>RRU-Net</h3><p><strong>RRU-Net: The Ringed Residual U-Net for Image Splicing Forgery Detection</strong></p>\n<p>发表在：CVPRW 2019<br>论文：<a href=\"https://ieeexplore.ieee.org/document/9025485\">https://ieeexplore.ieee.org/document/9025485</a><br>代码：<a href=\"https://github.com/yelusaleng/RRU-Net\">https://github.com/yelusaleng/RRU-Net</a><br>类型：拼接<br>方法：作者基于 U-Net 提出了一种环状残差网络 RRU-Net 用于图像拼接伪造检测。<strong>RRU-Net 是一个端到端的图像本质属性分割网络</strong>，无需任何预处理和后处理即可完成伪造区域检测。RRU-Net 的核心思想是加强 CNN 的学习方式，并由CNN中残差的传播和反馈过程实现。残差传播调用输入的特征信息以解决更深层网络中的梯度退化问题；残差反馈合并输入特征信息，使未篡改区域和篡改区域之间的图像属性差异更加明显。<br><img src=\"https://qiniu.findn.cn/blog/photos/article/Ft7ySxL1_DlI0SGPRrEoDSACPhPi\" alt=\"RRU-Net\" style=\"zoom:80%;\"/></p>\n<p>实验结果：RRU-NET 在 CASIA1.0 和 COLUMB 两个伪造图像数据集上的实验结果，CASIA 1.0 包括的篡改方式有拼接和复制粘贴攻击方式，但是本文只选取了其中的拼接攻击方式的数据集。COLUMB 是只包含拼接攻击的数据集。<br><img src=\"https://qiniu.findn.cn/blog/photos/article/Fr-Jmx8q_wE7e3EVP6JH5ZwEgEVk\" alt=\"RRU-Net\" style=\"zoom:80%;\"/></p>\n<p><strong>简评：</strong></p>\n<ul>\n<li>RRU-Net的主要创新体现在 Ringed Residual Structure，与其它方法不同是 RRU-Net 不直接设置检测伪造图像痕迹的特征，而是通过 residual feedback 机制让 CNN 自己去学习图片属性的差异特征，属于一种强化 CNN 学习的方法，并且经过实验证明了这种利用残差反馈方式自动学习图片属性差异的特征是有效的。</li>\n</ul>\n<h2 id=\"比赛\"><a href=\"#比赛\" class=\"headerlink\" title=\"比赛\"></a>比赛</h2><h3 id=\"天池-伪造图像的篡改检测-长期赛\"><a href=\"#天池-伪造图像的篡改检测-长期赛\" class=\"headerlink\" title=\"天池 - 伪造图像的篡改检测 - 长期赛\"></a><a href=\"https://tianchi.aliyun.com/competition/entrance/531812/information\"><strong>天池 - 伪造图像的篡改检测 - 长期赛</strong></a></h3><p><strong>赛题背景</strong></p>\n<p>本次比赛的背景是由于随着各种P图工具的普及，篡改伪造出视觉无痕迹的假图门槛大幅降低，于是我们看到大量的假图用于散播谣言、编造虚假新闻、非法获取经济利益，更有甚者，还可能会被用来恶意地充当法庭证据。因此需要设计出能够准确检测出图像篡改区域的算法，避免假图造成的危害。</p>\n<p><strong>题目描述</strong></p>\n<p>比赛采用的数据为证书文档类图像，其中包括10类不同图像。</p>\n<p>比赛的任务是通过提供的训练集学习出有效的检测算法，对测试集的伪造图像进行篡改定位。比赛的难点在于其分割区域是不能依靠边缘轮廓，因为篡改特征是偏向于弱信号特征（不可视的，跟内容特征弱相关），而且相对要分割出来的区域可能面积偏小。<br><img src=\"https://qiniu.findn.cn/blog/photos/article/Fk-_XfgIrmSXAmGnahiX8GARxPqz\" alt=\"篡改检测比赛\"/></p>\n<h3 id=\"比赛TOP3分享\"><a href=\"#比赛TOP3分享\" class=\"headerlink\" title=\"比赛TOP3分享\"></a>比赛TOP3分享</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU4MzQ4NTk5NQ==&mid=2247492758&idx=1&sn=7a8537b7e23957ea559bf5fd66a88ee0\">天池伪造图像的篡改检测比赛TOP3分享</a></p>\n<p>参考资料：<br>[1]. <a href=\"http://blog.sina.com.cn/s/blog_8fde4dbf0101ay5g.html\">图像的篡改取证应用前景</a><br>[2]. <a href=\"https://zhuanlan.zhihu.com/p/85030394\">PaperReadingGroup-2-篡改检测小综述</a><br>[3]. <a href=\"https://mp.weixin.qq.com/s/gdCv4SLsVibolPHQ62Z1dw\">图像篡改检测方法总结</a><br>[4]. <a href=\"https://www.cnblogs.com/lwp-nicol\">梁君牧-cnblog</a></p>\n","site":{"data":{}},"excerpt":"<p>篡改在英文文献中常用<code>manipulation</code>、<code>tamper</code>、<code>forgery</code>这三个词表达。广义上的图像篡改指的是<strong>对原始图像做了改动的操作</strong>，这种改动操可以是：图像属性改变、图像格式转换、形态学处理、模糊处理、缩放剪裁（seam carving）等等。</p>\n<p>图像篡改类别可以粗略划分为<code>图像处理操作(manipulation)</code>和<code>图像篡改操作(tamper)</code>两类（按英文直译，manipulation是操作的意思，此类篡改有点类似仅对图像做非内容性的处理，而tamper按直译，则是对图像做了内容性的处理）：</p>\n<p><strong>Manipulation</strong>：滤波处理（如中值滤波 Median Filtering）、模糊处理（如高斯模糊 Gaussian Blurring）、添加噪声（如高斯白噪声 Additive White Gaussian Noise）、重采样（Resampling）、压缩处理（如JPEG压缩 JPEG Compression）等。</p>\n<p><strong>Tamper</strong> ：删除（Removal）、添加（Adding）、复制（Copy-move）、拼接（Splicing）等。</p>\n<p>图像篡改检测技术涉及以下领域:</p>\n<ul>\n<li>司法鉴定和公安办案中照片的真伪鉴定</li>\n<li>保险事故中照片的真伪鉴别</li>\n<li>新闻摄影和赛事照片的真伪鉴别</li>\n<li>电子交易票据图像的真伪鉴别</li>\n</ul>","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>篡改检测问题实际上就是要检测出图像当中做过<strong>改动的区域</strong>。近几年，学术上更趋于集中研究splicing、copy-move、removal这三个类型图像篡改的检测问题。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/篡改检测-分类.jpg\"  alt=\"篡改检测-分类\" style=\"zoom: 33%;\" />\n\n<p>如上图：</p>\n<ul>\n<li>图像拼接(Splicing)：将一张图的内容抠下来贴在另一张图上；</li>\n<li>复制移动(Copy-move)：将同一张图上的内容复制粘贴到另一个位置；</li>\n<li>擦除填充(removal)：操作将同一张图上的内容擦除掉。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/篡改检测-人脸和文字.jpg\" alt=\"篡改检测-人脸和文字\" style=\"zoom: 33%;\" />\n\n<p>此外，对图像篡改检测的研究也有专门只针对人脸和文字的，上图上幅来自<a href=\"https://arxiv.org/abs/1803.09179\">Andreas Rossler et al., 2018</a>，是专门针对人脸篡改的检测；下幅来自<a href=\"https://arxiv.org/abs/1810.08016\">Yulia S. Chernyshova et al., 2018</a>，是专门针对文字篡改的检测。</p>\n<h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>图片数</th>\n<th>篡改类型</th>\n<th>描述</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CASIA v1.0/v2.0</td>\n<td>921/5123</td>\n<td>splicing; copy move;</td>\n<td>只提供原图、篡改图，不包含GroundTruth;</td>\n<td><a href=\"https://www.kaggle.com/sophatvathana/casia-dataset\">Kaggle(提供原图、篡改图)</a>; <a href=\"https://github.com/namtpham/casia2groundtruth\">@namtpham(在原图、篡改图的基础上提供了GroundTruth)</a></td>\n</tr>\n<tr>\n<td>Columbia</td>\n<td>183</td>\n<td>splicing;</td>\n<td><strong>基于未压缩图像的拼接</strong>，提供GroundTruth;</td>\n<td><a href=\"https://www.ee.columbia.edu/ln/dvmm/downloads/authsplcuncmp/\">Columbia Uncompressed Image Splicing Detection Evaluation Dataset</a></td>\n</tr>\n<tr>\n<td>NIST 2016</td>\n<td>564</td>\n<td>splicing; copy move; removal;</td>\n<td>提供GroundTruth;</td>\n<td><a href=\"https://mfc.nist.gov/\">NIST Public Media Forensics Data</a></td>\n</tr>\n<tr>\n<td>COVERAGE</td>\n<td>100</td>\n<td>copy move</td>\n<td><strong>专注于copy-move</strong>，提供GroundTruth;</td>\n<td><a href=\"https://github.com/wenbihan/coverage\">Coverage</a></td>\n</tr>\n<tr>\n<td>Pawel</td>\n<td>220</td>\n<td>object-insertion; removal</td>\n<td><strong>手工篡改数据集</strong>，非常走心的;</td>\n<td><a href=\"https://pkorus.pl/downloads\">Pawel korus-Realistic Tampering Dataset</a></td>\n</tr>\n<tr>\n<td>PS-Battles</td>\n<td>40.2G</td>\n<td>类型诸多</td>\n<td><strong>PS社区手工篡改</strong>，篡改类型多，篡改更真实;</td>\n<td><a href=\"https://github.com/MuskAI/PS-Battles-master\">Ps Battle DataSet</a>; <a href=\"https://arxiv.org/abs/1804.04866\">原论文</a></td>\n</tr>\n</tbody></table>\n<p>百度网盘链接：（包含 NIST, COVERAGE, Columbia）<br>链接：<a href=\"https://pan.baidu.com/s/1Rn18JLDV7WviUvP8UsRZVQ\">https://pan.baidu.com/s/1Rn18JLDV7WviUvP8UsRZVQ</a><br>提取码：ptur </p>\n<h2 id=\"Related-Work\"><a href=\"#Related-Work\" class=\"headerlink\" title=\"Related Work\"></a>Related Work</h2><p>人类在识别复制移动方面可能比检测拼接和移除更好。这是因为在复制移动图像中，人眼可以感觉到类似物体的重复。对于拼接和移除图像，人类在很大程度上依靠寻找明显的边缘不连续和照明不一致来确定是否发生了篡改。因此，当在经过良好篡改的图像中视觉上看不到不一致之处时，人类将无法检测到篡改。之前传统的图像处理方法提出了探索边缘不连续和照明不一致性的算法，以协助并超越人类在篡改检测任务中的能力。</p>\n<p>当前深度学习的图像篡改区域定位方法主要有以下三种方向：</p>\n<ul>\n<li>将篡改区域定位认为是像素级的二分类，采用图像分割的算法来定位篡改区域。</li>\n<li>将篡改区域定位当作是目标检测任务，采用目标检测算法来定位篡改区域。</li>\n<li>将篡改区域定位当作是局部异常检测，采用CNN + LSTM网络检测图像中的局部异常。</li>\n</ul>\n<p>接下来总结近几年这三个方向具有代表性的图像篡改区域定位方法。</p>\n<h3 id=\"RGB-N\"><a href=\"#RGB-N\" class=\"headerlink\" title=\"RGB-N\"></a>RGB-N</h3><p><strong>Learning Rich Features for Image Manipulation Detection</strong></p>\n<p>发表在：CVPR 2018</p>\n<p>论文：<a href=\"https://arxiv.org/abs/1805.04953\">https://arxiv.org/abs/1805.04953</a></p>\n<p>代码：<a href=\"https://github.com/LarryJiang134/Image_manipulation_detection\">https://github.com/LarryJiang134/Image_manipulation_detection</a></p>\n<p>类型：拼接、移除</p>\n<p>方法：提出了一种双流的Faster R-CNN网络，给定manipulated image，对其进行端到端的训练，以便检测被篡改的区域。双流分别为RGB stream、noise stream。其中，RGB stream主要目的是从RGB图像输入中提取特征，从而发现篡改区域强烈对比差异，非自然的篡改边界等之类的tampering artifacts。Noise stream 主要利用噪声特征去发现在真实区域和篡改区域之间的噪声不一致性，噪声特征是从steganalysis rich model filter layer中提取的。之后，通过bilinear pooling layer融合两个流的特征，以便进一步结合这两种模态的空间信息。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/FsNgw8pkib9mH2an56FHoiuU5QVs\" alt=\"RGB-N\" style=\"zoom: 80%;\" />\n\n<p>实验结果：CASIA 2.0作为训练集 CASIA1.0作为测试集。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fo7Gx_G7E6ysL2U4IuNkgqo-uZrW\" alt=\"RGB-N Result\" />\n\n<p><strong>简评：</strong></p>\n<ul>\n<li>该方法利用篡改区域与原图噪声不一致的线索，提出了<strong>双流Fast RCNN</strong>，这种方法的优势在于其具有很好的鲁棒性，这是由于<strong>当篡改者利用JEPG压缩或者resize</strong>隐藏时，噪声不一致的线索会更加突显出来，因此其具有很好的鲁棒性和抗干扰的能力。作者在文中分享了这一方法的局限也就是<strong>在复制移动的篡改方式下表现不太好</strong>，其原因有两个方面，首先，复制的区域来自同一张图像，这产生了相似的噪声分布，从而混淆了的噪声流。并且，两个区域通常具有相同的对比度。</li>\n</ul>\n<h3 id=\"ManTra-Net\"><a href=\"#ManTra-Net\" class=\"headerlink\" title=\"ManTra-Net\"></a>ManTra-Net</h3><p><strong>ManTra-Net: Manipulation Tracing Network For Detection And Localization of Image Forgeries With Anomalous Features</strong></p>\n<p>发表在：CVPR2019</p>\n<p>论文：<a href=\"https://openaccess.thecvf.com/content_CVPR_2019/html/Wu_ManTra-Net_Manipulation_Tracing_Network_for_Detection_and_Localization_of_Image_CVPR_2019_paper.html\">https://openaccess.thecvf.com/content_CVPR_2019/html/Wu_ManTra-Net_Manipulation_Tracing_Network_for_Detection_and_Localization_of_Image_CVPR_2019_paper.html</a></p>\n<p>代码：<a href=\"https://github.com/ISICV/ManTraNet\">https://github.com/ISICV/ManTraNet</a></p>\n<p>类型：拼接、移除、复制粘贴 </p>\n<p>方法：作者提出了一个不需要额外的预处理和后处理的篡改检测网络ManTra-Net。此网络是一个全卷积网络，可以处理任意尺寸的图像和多种篡改类型。主要的贡献在于用一个自监督学习的方式从385篡改类型中学习特征，可以概括为压缩（JPEG一次、二次）、模糊（高斯、中值、小波）、形态学(膨胀 腐蚀)、插值（线性、二次、三次）、噪声（高斯、脉冲、均匀）、对比度、直方图均衡化等，并且将篡改定位问题当做一个局部异常点检测问题来解决。使用Z-score特征表示局部异常，使用long short-term memory solution进行评估。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fkm-o0qyQw_j_Cb9mcQ2EVQ0lvL6\" alt=\"ManTra-Net\"/>\n\n<p>实验结果：CASIA 2.0作为训练集 CASIA1.0作为测试集。</p>\n<img src=\"https://qiniu.findn.cn/blog/photos/article/Fk5s46y_eiAhNBQLLqHvapvKxKjZ\" alt=\"ManTra-Net Result\" style=\"zoom:;\" />\n\n<p><strong>简评：</strong></p>\n<ul>\n<li>ManTra-Net 的创新之处在于设计了一个简单而有效的<strong>自我监督学习任务</strong>，以通过对385种图像操作类型进行分类来学习强大的图像操作轨迹。此外，我们<strong>将伪造定位问题公式化为局部异常检测问题，设计Z分数功能以捕获局部异常</strong>。ManTra-Net的优点主要在于它对于绝大多数的篡改攻击方式的有效果，因为它利用了自监督学习篡改的类型，因此有效的检测多种篡改方式，并且具有不错的鲁棒性，可以说是每个方式都有优势，但单独一种方式下不一定是最优的方法。</li>\n</ul>\n<p>​    </p>\n<h3 id=\"RRU-Net\"><a href=\"#RRU-Net\" class=\"headerlink\" title=\"RRU-Net\"></a>RRU-Net</h3><p><strong>RRU-Net: The Ringed Residual U-Net for Image Splicing Forgery Detection</strong></p>\n<p>发表在：CVPRW 2019<br>论文：<a href=\"https://ieeexplore.ieee.org/document/9025485\">https://ieeexplore.ieee.org/document/9025485</a><br>代码：<a href=\"https://github.com/yelusaleng/RRU-Net\">https://github.com/yelusaleng/RRU-Net</a><br>类型：拼接<br>方法：作者基于 U-Net 提出了一种环状残差网络 RRU-Net 用于图像拼接伪造检测。<strong>RRU-Net 是一个端到端的图像本质属性分割网络</strong>，无需任何预处理和后处理即可完成伪造区域检测。RRU-Net 的核心思想是加强 CNN 的学习方式，并由CNN中残差的传播和反馈过程实现。残差传播调用输入的特征信息以解决更深层网络中的梯度退化问题；残差反馈合并输入特征信息，使未篡改区域和篡改区域之间的图像属性差异更加明显。<br><img src=\"https://qiniu.findn.cn/blog/photos/article/Ft7ySxL1_DlI0SGPRrEoDSACPhPi\" alt=\"RRU-Net\" style=\"zoom:80%;\"/></p>\n<p>实验结果：RRU-NET 在 CASIA1.0 和 COLUMB 两个伪造图像数据集上的实验结果，CASIA 1.0 包括的篡改方式有拼接和复制粘贴攻击方式，但是本文只选取了其中的拼接攻击方式的数据集。COLUMB 是只包含拼接攻击的数据集。<br><img src=\"https://qiniu.findn.cn/blog/photos/article/Fr-Jmx8q_wE7e3EVP6JH5ZwEgEVk\" alt=\"RRU-Net\" style=\"zoom:80%;\"/></p>\n<p><strong>简评：</strong></p>\n<ul>\n<li>RRU-Net的主要创新体现在 Ringed Residual Structure，与其它方法不同是 RRU-Net 不直接设置检测伪造图像痕迹的特征，而是通过 residual feedback 机制让 CNN 自己去学习图片属性的差异特征，属于一种强化 CNN 学习的方法，并且经过实验证明了这种利用残差反馈方式自动学习图片属性差异的特征是有效的。</li>\n</ul>\n<h2 id=\"比赛\"><a href=\"#比赛\" class=\"headerlink\" title=\"比赛\"></a>比赛</h2><h3 id=\"天池-伪造图像的篡改检测-长期赛\"><a href=\"#天池-伪造图像的篡改检测-长期赛\" class=\"headerlink\" title=\"天池 - 伪造图像的篡改检测 - 长期赛\"></a><a href=\"https://tianchi.aliyun.com/competition/entrance/531812/information\"><strong>天池 - 伪造图像的篡改检测 - 长期赛</strong></a></h3><p><strong>赛题背景</strong></p>\n<p>本次比赛的背景是由于随着各种P图工具的普及，篡改伪造出视觉无痕迹的假图门槛大幅降低，于是我们看到大量的假图用于散播谣言、编造虚假新闻、非法获取经济利益，更有甚者，还可能会被用来恶意地充当法庭证据。因此需要设计出能够准确检测出图像篡改区域的算法，避免假图造成的危害。</p>\n<p><strong>题目描述</strong></p>\n<p>比赛采用的数据为证书文档类图像，其中包括10类不同图像。</p>\n<p>比赛的任务是通过提供的训练集学习出有效的检测算法，对测试集的伪造图像进行篡改定位。比赛的难点在于其分割区域是不能依靠边缘轮廓，因为篡改特征是偏向于弱信号特征（不可视的，跟内容特征弱相关），而且相对要分割出来的区域可能面积偏小。<br><img src=\"https://qiniu.findn.cn/blog/photos/article/Fk-_XfgIrmSXAmGnahiX8GARxPqz\" alt=\"篡改检测比赛\"/></p>\n<h3 id=\"比赛TOP3分享\"><a href=\"#比赛TOP3分享\" class=\"headerlink\" title=\"比赛TOP3分享\"></a>比赛TOP3分享</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU4MzQ4NTk5NQ==&mid=2247492758&idx=1&sn=7a8537b7e23957ea559bf5fd66a88ee0\">天池伪造图像的篡改检测比赛TOP3分享</a></p>\n<p>参考资料：<br>[1]. <a href=\"http://blog.sina.com.cn/s/blog_8fde4dbf0101ay5g.html\">图像的篡改取证应用前景</a><br>[2]. <a href=\"https://zhuanlan.zhihu.com/p/85030394\">PaperReadingGroup-2-篡改检测小综述</a><br>[3]. <a href=\"https://mp.weixin.qq.com/s/gdCv4SLsVibolPHQ62Z1dw\">图像篡改检测方法总结</a><br>[4]. <a href=\"https://www.cnblogs.com/lwp-nicol\">梁君牧-cnblog</a></p>"},{"title":"从零开始搭建Hexo博客","article_type":0,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"mathjax":false,"abbrlink":"8d2d3001","date":"2021-10-22T13:12:44.000Z","top":1,"_content":"\n<img src=\"https://qiniu.findn.cn/blog/photos/article/blog.jpg\" alt=\"blog\" style=\"zoom:80%;\" />\n\nHello，朋友，欢迎来到[三水のBlog](https://sanshui.findn.cn/)，耗时2周的博客终于搭建好了，期间踩了不少坑，不过也学到了非常多的内容。\n\n> 博客使用的所有配置我已经打包为开源项目[hexo-theme-new-yilia](https://github.com/jackhanyuan/hexo-theme-new-yilia)，大家可以快速安装，欢迎Star！\n\n<!--more-->\n\n第一篇博文就做一个博客搭建过程的全记录吧，按照我的步骤，你也可以从零搭建一个属于自己的博客，我将按照以下目录逐步更新搭建博客的过程，希望能帮到大家。\n\n- Hexo相关\n\t- Hexo博客入门\n\t- Hexo博客技巧\n\t- Hexo主题推荐\n- Yilia主题相关\n\t- yilia主题bug修复\n\t- yilia主题功能新增\n\t- yilia 主题美化\n- Hexo博客性能优化及部署\n\t- hexo博客性能优化\n\t- hexo博客部署及高阶技巧\n- SEO优化\n\t- 让搜索引擎收录你的文章\n\t- 网站统计分析\n- 工具分享\n\t- PicGo图床上传工具\n\t- Typora文章编辑工具\n\n## Hexo相关\n\n### Hexo博客入门\n\n- 为什么选择hexo\n- 初始化hexo博客\n\n### Hexo博客技巧\n\n- hexo常用命令\n- hexo常用技巧\n\t- 跳过渲染\n\t- 显示摘要\n\n### Hexo主题推荐\n\n- hexo-theme-next\n- hexo-theme-melody\n- hexo-theme-yun\n- hexo-theme-yilia\n- hexo-theme-icarus\n\n## Yilia主题相关\n\n### Yilia主题bug修复\n\n- 修复yilia主题所有文章列表不显示\n- yilia主题头像显示异常\n- 修复手机端toc目录不显示\n- 修复mathjax数学公式js失效及换行问题\n- 移除已经关闭的多说和网易云跟帖评论系统\n- 修复翻页不能正确显示的bug\n- 修复分享到微信二维码失效问题\n- 取消litten.me统计\n\n### Yilia主题功能新增\n\n- 增加文章置顶功能\n- 增加代码块复制功能\n- 增加waline评论功能(含valine后端部署)\n- 增加gittalk评论\n- 增加APlayer播放器(可导入歌单)\n- 增加live2d看板娘\n- 增加归档页\n- 增加分类和标签页\n- 增加music页\n- 增加相册photos和视频videos页\n- 增加404页面(《圈小猫》游戏 和 腾讯公益404)\n\n### Yilia 主题美化\n\n- 文章添加字数统计和阅读时长\n- 文章添加原创和转载标签\n- 增加鼠标悬停头像旋转功能\n- 侧栏left-col增加时钟clock显示\n- 侧栏left-col增加网易云播放器\n- 侧栏增加一言(hitokoto)\n- 增加鼠标点击爱心love和文字特效\n- 增加雪花飘落snow效果\n- 文章底部增加版权声明\n- 利用font-awesome给网站添加图标\n- 侧栏subnav增加自定义图标\n- 手机端增加smart menu按钮\n- 添加不蒜子/busuanzi访问量统计功能\n- footer添加网站运行时间\n- footer添加icp备案信息\n- 友链页面优化\n- 修改css统一yilia主题视觉颜色\n- 自定义背景图片\n- 手机端美化\n\n## Hexo博客性能优化及部署\n\n### hexo博客性能优化\n\n- 利用cdn加速js静态资源\n- 利用七牛云图床存储网站图片\n\n### hexo博客部署及高阶技巧\n\n- 将hexo博客部署到github pages\n- github pages绑定自定义域名并实现https\n- 利用cdn全站加速hexo博客\n- 使用Github Action实现hexo博客自动部署\n- 使用Travis-CI实现hexo博客自动部署\n\n## SEO优化\n\n### 让搜索引擎收录你的文章\n\n- 文章URL链接使用abbrlink持久化\n- robots.txt配置\n- 百度搜索资源平台（百度站长平台）配置\n- 谷歌搜索( google search console)配置\n- 百度主动推送链接配置\n- 百度站长平台自动推送配置\n- sitemap站点地图生成与提交\n\n### 网站统计分析\n\n- 配置谷歌分析(google analytics)\n- 配置百度统计\n\n## 其它\n\n### 工具分享\n\n- PicGo图床上传工具\n- Typora文章编辑工具\n\n### 已知bug\n\n- toc目录跳转和Aplayer冲突\n","source":"_posts/01 从零开始搭建Hexo博客.md","raw":"---\ntitle: 从零开始搭建Hexo博客\ntag:\n  - hexo\n  - yilia\ncategories:\n  - [博客Blog, hexo]\n  - [博客Blog, yilia]\narticle_type: 0\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\nmathjax: false\nabbrlink: 8d2d3001\ndate: 2021-10-22 21:12:44\ntop: 1\n---\n\n<img src=\"https://qiniu.findn.cn/blog/photos/article/blog.jpg\" alt=\"blog\" style=\"zoom:80%;\" />\n\nHello，朋友，欢迎来到[三水のBlog](https://sanshui.findn.cn/)，耗时2周的博客终于搭建好了，期间踩了不少坑，不过也学到了非常多的内容。\n\n> 博客使用的所有配置我已经打包为开源项目[hexo-theme-new-yilia](https://github.com/jackhanyuan/hexo-theme-new-yilia)，大家可以快速安装，欢迎Star！\n\n<!--more-->\n\n第一篇博文就做一个博客搭建过程的全记录吧，按照我的步骤，你也可以从零搭建一个属于自己的博客，我将按照以下目录逐步更新搭建博客的过程，希望能帮到大家。\n\n- Hexo相关\n\t- Hexo博客入门\n\t- Hexo博客技巧\n\t- Hexo主题推荐\n- Yilia主题相关\n\t- yilia主题bug修复\n\t- yilia主题功能新增\n\t- yilia 主题美化\n- Hexo博客性能优化及部署\n\t- hexo博客性能优化\n\t- hexo博客部署及高阶技巧\n- SEO优化\n\t- 让搜索引擎收录你的文章\n\t- 网站统计分析\n- 工具分享\n\t- PicGo图床上传工具\n\t- Typora文章编辑工具\n\n## Hexo相关\n\n### Hexo博客入门\n\n- 为什么选择hexo\n- 初始化hexo博客\n\n### Hexo博客技巧\n\n- hexo常用命令\n- hexo常用技巧\n\t- 跳过渲染\n\t- 显示摘要\n\n### Hexo主题推荐\n\n- hexo-theme-next\n- hexo-theme-melody\n- hexo-theme-yun\n- hexo-theme-yilia\n- hexo-theme-icarus\n\n## Yilia主题相关\n\n### Yilia主题bug修复\n\n- 修复yilia主题所有文章列表不显示\n- yilia主题头像显示异常\n- 修复手机端toc目录不显示\n- 修复mathjax数学公式js失效及换行问题\n- 移除已经关闭的多说和网易云跟帖评论系统\n- 修复翻页不能正确显示的bug\n- 修复分享到微信二维码失效问题\n- 取消litten.me统计\n\n### Yilia主题功能新增\n\n- 增加文章置顶功能\n- 增加代码块复制功能\n- 增加waline评论功能(含valine后端部署)\n- 增加gittalk评论\n- 增加APlayer播放器(可导入歌单)\n- 增加live2d看板娘\n- 增加归档页\n- 增加分类和标签页\n- 增加music页\n- 增加相册photos和视频videos页\n- 增加404页面(《圈小猫》游戏 和 腾讯公益404)\n\n### Yilia 主题美化\n\n- 文章添加字数统计和阅读时长\n- 文章添加原创和转载标签\n- 增加鼠标悬停头像旋转功能\n- 侧栏left-col增加时钟clock显示\n- 侧栏left-col增加网易云播放器\n- 侧栏增加一言(hitokoto)\n- 增加鼠标点击爱心love和文字特效\n- 增加雪花飘落snow效果\n- 文章底部增加版权声明\n- 利用font-awesome给网站添加图标\n- 侧栏subnav增加自定义图标\n- 手机端增加smart menu按钮\n- 添加不蒜子/busuanzi访问量统计功能\n- footer添加网站运行时间\n- footer添加icp备案信息\n- 友链页面优化\n- 修改css统一yilia主题视觉颜色\n- 自定义背景图片\n- 手机端美化\n\n## Hexo博客性能优化及部署\n\n### hexo博客性能优化\n\n- 利用cdn加速js静态资源\n- 利用七牛云图床存储网站图片\n\n### hexo博客部署及高阶技巧\n\n- 将hexo博客部署到github pages\n- github pages绑定自定义域名并实现https\n- 利用cdn全站加速hexo博客\n- 使用Github Action实现hexo博客自动部署\n- 使用Travis-CI实现hexo博客自动部署\n\n## SEO优化\n\n### 让搜索引擎收录你的文章\n\n- 文章URL链接使用abbrlink持久化\n- robots.txt配置\n- 百度搜索资源平台（百度站长平台）配置\n- 谷歌搜索( google search console)配置\n- 百度主动推送链接配置\n- 百度站长平台自动推送配置\n- sitemap站点地图生成与提交\n\n### 网站统计分析\n\n- 配置谷歌分析(google analytics)\n- 配置百度统计\n\n## 其它\n\n### 工具分享\n\n- PicGo图床上传工具\n- Typora文章编辑工具\n\n### 已知bug\n\n- toc目录跳转和Aplayer冲突\n","slug":"01 从零开始搭建Hexo博客","published":1,"updated":"2022-11-29T04:29:30.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4j000g64rg09fd2ufp","content":"<img src=\"https://qiniu.findn.cn/blog/photos/article/blog.jpg\" alt=\"blog\" style=\"zoom:80%;\" />\n\n<p>Hello，朋友，欢迎来到<a href=\"https://sanshui.findn.cn/\">三水のBlog</a>，耗时2周的博客终于搭建好了，期间踩了不少坑，不过也学到了非常多的内容。</p>\n<blockquote>\n<p>博客使用的所有配置我已经打包为开源项目<a href=\"https://github.com/jackhanyuan/hexo-theme-new-yilia\">hexo-theme-new-yilia</a>，大家可以快速安装，欢迎Star！</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>第一篇博文就做一个博客搭建过程的全记录吧，按照我的步骤，你也可以从零搭建一个属于自己的博客，我将按照以下目录逐步更新搭建博客的过程，希望能帮到大家。</p>\n<ul>\n<li>Hexo相关<ul>\n<li>Hexo博客入门</li>\n<li>Hexo博客技巧</li>\n<li>Hexo主题推荐</li>\n</ul>\n</li>\n<li>Yilia主题相关<ul>\n<li>yilia主题bug修复</li>\n<li>yilia主题功能新增</li>\n<li>yilia 主题美化</li>\n</ul>\n</li>\n<li>Hexo博客性能优化及部署<ul>\n<li>hexo博客性能优化</li>\n<li>hexo博客部署及高阶技巧</li>\n</ul>\n</li>\n<li>SEO优化<ul>\n<li>让搜索引擎收录你的文章</li>\n<li>网站统计分析</li>\n</ul>\n</li>\n<li>工具分享<ul>\n<li>PicGo图床上传工具</li>\n<li>Typora文章编辑工具</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Hexo相关\"><a href=\"#Hexo相关\" class=\"headerlink\" title=\"Hexo相关\"></a>Hexo相关</h2><h3 id=\"Hexo博客入门\"><a href=\"#Hexo博客入门\" class=\"headerlink\" title=\"Hexo博客入门\"></a>Hexo博客入门</h3><ul>\n<li>为什么选择hexo</li>\n<li>初始化hexo博客</li>\n</ul>\n<h3 id=\"Hexo博客技巧\"><a href=\"#Hexo博客技巧\" class=\"headerlink\" title=\"Hexo博客技巧\"></a>Hexo博客技巧</h3><ul>\n<li>hexo常用命令</li>\n<li>hexo常用技巧<ul>\n<li>跳过渲染</li>\n<li>显示摘要</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hexo主题推荐\"><a href=\"#Hexo主题推荐\" class=\"headerlink\" title=\"Hexo主题推荐\"></a>Hexo主题推荐</h3><ul>\n<li>hexo-theme-next</li>\n<li>hexo-theme-melody</li>\n<li>hexo-theme-yun</li>\n<li>hexo-theme-yilia</li>\n<li>hexo-theme-icarus</li>\n</ul>\n<h2 id=\"Yilia主题相关\"><a href=\"#Yilia主题相关\" class=\"headerlink\" title=\"Yilia主题相关\"></a>Yilia主题相关</h2><h3 id=\"Yilia主题bug修复\"><a href=\"#Yilia主题bug修复\" class=\"headerlink\" title=\"Yilia主题bug修复\"></a>Yilia主题bug修复</h3><ul>\n<li>修复yilia主题所有文章列表不显示</li>\n<li>yilia主题头像显示异常</li>\n<li>修复手机端toc目录不显示</li>\n<li>修复mathjax数学公式js失效及换行问题</li>\n<li>移除已经关闭的多说和网易云跟帖评论系统</li>\n<li>修复翻页不能正确显示的bug</li>\n<li>修复分享到微信二维码失效问题</li>\n<li>取消litten.me统计</li>\n</ul>\n<h3 id=\"Yilia主题功能新增\"><a href=\"#Yilia主题功能新增\" class=\"headerlink\" title=\"Yilia主题功能新增\"></a>Yilia主题功能新增</h3><ul>\n<li>增加文章置顶功能</li>\n<li>增加代码块复制功能</li>\n<li>增加waline评论功能(含valine后端部署)</li>\n<li>增加gittalk评论</li>\n<li>增加APlayer播放器(可导入歌单)</li>\n<li>增加live2d看板娘</li>\n<li>增加归档页</li>\n<li>增加分类和标签页</li>\n<li>增加music页</li>\n<li>增加相册photos和视频videos页</li>\n<li>增加404页面(《圈小猫》游戏 和 腾讯公益404)</li>\n</ul>\n<h3 id=\"Yilia-主题美化\"><a href=\"#Yilia-主题美化\" class=\"headerlink\" title=\"Yilia 主题美化\"></a>Yilia 主题美化</h3><ul>\n<li>文章添加字数统计和阅读时长</li>\n<li>文章添加原创和转载标签</li>\n<li>增加鼠标悬停头像旋转功能</li>\n<li>侧栏left-col增加时钟clock显示</li>\n<li>侧栏left-col增加网易云播放器</li>\n<li>侧栏增加一言(hitokoto)</li>\n<li>增加鼠标点击爱心love和文字特效</li>\n<li>增加雪花飘落snow效果</li>\n<li>文章底部增加版权声明</li>\n<li>利用font-awesome给网站添加图标</li>\n<li>侧栏subnav增加自定义图标</li>\n<li>手机端增加smart menu按钮</li>\n<li>添加不蒜子/busuanzi访问量统计功能</li>\n<li>footer添加网站运行时间</li>\n<li>footer添加icp备案信息</li>\n<li>友链页面优化</li>\n<li>修改css统一yilia主题视觉颜色</li>\n<li>自定义背景图片</li>\n<li>手机端美化</li>\n</ul>\n<h2 id=\"Hexo博客性能优化及部署\"><a href=\"#Hexo博客性能优化及部署\" class=\"headerlink\" title=\"Hexo博客性能优化及部署\"></a>Hexo博客性能优化及部署</h2><h3 id=\"hexo博客性能优化\"><a href=\"#hexo博客性能优化\" class=\"headerlink\" title=\"hexo博客性能优化\"></a>hexo博客性能优化</h3><ul>\n<li>利用cdn加速js静态资源</li>\n<li>利用七牛云图床存储网站图片</li>\n</ul>\n<h3 id=\"hexo博客部署及高阶技巧\"><a href=\"#hexo博客部署及高阶技巧\" class=\"headerlink\" title=\"hexo博客部署及高阶技巧\"></a>hexo博客部署及高阶技巧</h3><ul>\n<li>将hexo博客部署到github pages</li>\n<li>github pages绑定自定义域名并实现https</li>\n<li>利用cdn全站加速hexo博客</li>\n<li>使用Github Action实现hexo博客自动部署</li>\n<li>使用Travis-CI实现hexo博客自动部署</li>\n</ul>\n<h2 id=\"SEO优化\"><a href=\"#SEO优化\" class=\"headerlink\" title=\"SEO优化\"></a>SEO优化</h2><h3 id=\"让搜索引擎收录你的文章\"><a href=\"#让搜索引擎收录你的文章\" class=\"headerlink\" title=\"让搜索引擎收录你的文章\"></a>让搜索引擎收录你的文章</h3><ul>\n<li>文章URL链接使用abbrlink持久化</li>\n<li>robots.txt配置</li>\n<li>百度搜索资源平台（百度站长平台）配置</li>\n<li>谷歌搜索( google search console)配置</li>\n<li>百度主动推送链接配置</li>\n<li>百度站长平台自动推送配置</li>\n<li>sitemap站点地图生成与提交</li>\n</ul>\n<h3 id=\"网站统计分析\"><a href=\"#网站统计分析\" class=\"headerlink\" title=\"网站统计分析\"></a>网站统计分析</h3><ul>\n<li>配置谷歌分析(google analytics)</li>\n<li>配置百度统计</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><h3 id=\"工具分享\"><a href=\"#工具分享\" class=\"headerlink\" title=\"工具分享\"></a>工具分享</h3><ul>\n<li>PicGo图床上传工具</li>\n<li>Typora文章编辑工具</li>\n</ul>\n<h3 id=\"已知bug\"><a href=\"#已知bug\" class=\"headerlink\" title=\"已知bug\"></a>已知bug</h3><ul>\n<li>toc目录跳转和Aplayer冲突</li>\n</ul>\n","site":{"data":{}},"excerpt":"<img src=\"https://qiniu.findn.cn/blog/photos/article/blog.jpg\" alt=\"blog\" style=\"zoom:80%;\" />\n\n<p>Hello，朋友，欢迎来到<a href=\"https://sanshui.findn.cn/\">三水のBlog</a>，耗时2周的博客终于搭建好了，期间踩了不少坑，不过也学到了非常多的内容。</p>\n<blockquote>\n<p>博客使用的所有配置我已经打包为开源项目<a href=\"https://github.com/jackhanyuan/hexo-theme-new-yilia\">hexo-theme-new-yilia</a>，大家可以快速安装，欢迎Star！</p>\n</blockquote>","more":"<p>第一篇博文就做一个博客搭建过程的全记录吧，按照我的步骤，你也可以从零搭建一个属于自己的博客，我将按照以下目录逐步更新搭建博客的过程，希望能帮到大家。</p>\n<ul>\n<li>Hexo相关<ul>\n<li>Hexo博客入门</li>\n<li>Hexo博客技巧</li>\n<li>Hexo主题推荐</li>\n</ul>\n</li>\n<li>Yilia主题相关<ul>\n<li>yilia主题bug修复</li>\n<li>yilia主题功能新增</li>\n<li>yilia 主题美化</li>\n</ul>\n</li>\n<li>Hexo博客性能优化及部署<ul>\n<li>hexo博客性能优化</li>\n<li>hexo博客部署及高阶技巧</li>\n</ul>\n</li>\n<li>SEO优化<ul>\n<li>让搜索引擎收录你的文章</li>\n<li>网站统计分析</li>\n</ul>\n</li>\n<li>工具分享<ul>\n<li>PicGo图床上传工具</li>\n<li>Typora文章编辑工具</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Hexo相关\"><a href=\"#Hexo相关\" class=\"headerlink\" title=\"Hexo相关\"></a>Hexo相关</h2><h3 id=\"Hexo博客入门\"><a href=\"#Hexo博客入门\" class=\"headerlink\" title=\"Hexo博客入门\"></a>Hexo博客入门</h3><ul>\n<li>为什么选择hexo</li>\n<li>初始化hexo博客</li>\n</ul>\n<h3 id=\"Hexo博客技巧\"><a href=\"#Hexo博客技巧\" class=\"headerlink\" title=\"Hexo博客技巧\"></a>Hexo博客技巧</h3><ul>\n<li>hexo常用命令</li>\n<li>hexo常用技巧<ul>\n<li>跳过渲染</li>\n<li>显示摘要</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hexo主题推荐\"><a href=\"#Hexo主题推荐\" class=\"headerlink\" title=\"Hexo主题推荐\"></a>Hexo主题推荐</h3><ul>\n<li>hexo-theme-next</li>\n<li>hexo-theme-melody</li>\n<li>hexo-theme-yun</li>\n<li>hexo-theme-yilia</li>\n<li>hexo-theme-icarus</li>\n</ul>\n<h2 id=\"Yilia主题相关\"><a href=\"#Yilia主题相关\" class=\"headerlink\" title=\"Yilia主题相关\"></a>Yilia主题相关</h2><h3 id=\"Yilia主题bug修复\"><a href=\"#Yilia主题bug修复\" class=\"headerlink\" title=\"Yilia主题bug修复\"></a>Yilia主题bug修复</h3><ul>\n<li>修复yilia主题所有文章列表不显示</li>\n<li>yilia主题头像显示异常</li>\n<li>修复手机端toc目录不显示</li>\n<li>修复mathjax数学公式js失效及换行问题</li>\n<li>移除已经关闭的多说和网易云跟帖评论系统</li>\n<li>修复翻页不能正确显示的bug</li>\n<li>修复分享到微信二维码失效问题</li>\n<li>取消litten.me统计</li>\n</ul>\n<h3 id=\"Yilia主题功能新增\"><a href=\"#Yilia主题功能新增\" class=\"headerlink\" title=\"Yilia主题功能新增\"></a>Yilia主题功能新增</h3><ul>\n<li>增加文章置顶功能</li>\n<li>增加代码块复制功能</li>\n<li>增加waline评论功能(含valine后端部署)</li>\n<li>增加gittalk评论</li>\n<li>增加APlayer播放器(可导入歌单)</li>\n<li>增加live2d看板娘</li>\n<li>增加归档页</li>\n<li>增加分类和标签页</li>\n<li>增加music页</li>\n<li>增加相册photos和视频videos页</li>\n<li>增加404页面(《圈小猫》游戏 和 腾讯公益404)</li>\n</ul>\n<h3 id=\"Yilia-主题美化\"><a href=\"#Yilia-主题美化\" class=\"headerlink\" title=\"Yilia 主题美化\"></a>Yilia 主题美化</h3><ul>\n<li>文章添加字数统计和阅读时长</li>\n<li>文章添加原创和转载标签</li>\n<li>增加鼠标悬停头像旋转功能</li>\n<li>侧栏left-col增加时钟clock显示</li>\n<li>侧栏left-col增加网易云播放器</li>\n<li>侧栏增加一言(hitokoto)</li>\n<li>增加鼠标点击爱心love和文字特效</li>\n<li>增加雪花飘落snow效果</li>\n<li>文章底部增加版权声明</li>\n<li>利用font-awesome给网站添加图标</li>\n<li>侧栏subnav增加自定义图标</li>\n<li>手机端增加smart menu按钮</li>\n<li>添加不蒜子/busuanzi访问量统计功能</li>\n<li>footer添加网站运行时间</li>\n<li>footer添加icp备案信息</li>\n<li>友链页面优化</li>\n<li>修改css统一yilia主题视觉颜色</li>\n<li>自定义背景图片</li>\n<li>手机端美化</li>\n</ul>\n<h2 id=\"Hexo博客性能优化及部署\"><a href=\"#Hexo博客性能优化及部署\" class=\"headerlink\" title=\"Hexo博客性能优化及部署\"></a>Hexo博客性能优化及部署</h2><h3 id=\"hexo博客性能优化\"><a href=\"#hexo博客性能优化\" class=\"headerlink\" title=\"hexo博客性能优化\"></a>hexo博客性能优化</h3><ul>\n<li>利用cdn加速js静态资源</li>\n<li>利用七牛云图床存储网站图片</li>\n</ul>\n<h3 id=\"hexo博客部署及高阶技巧\"><a href=\"#hexo博客部署及高阶技巧\" class=\"headerlink\" title=\"hexo博客部署及高阶技巧\"></a>hexo博客部署及高阶技巧</h3><ul>\n<li>将hexo博客部署到github pages</li>\n<li>github pages绑定自定义域名并实现https</li>\n<li>利用cdn全站加速hexo博客</li>\n<li>使用Github Action实现hexo博客自动部署</li>\n<li>使用Travis-CI实现hexo博客自动部署</li>\n</ul>\n<h2 id=\"SEO优化\"><a href=\"#SEO优化\" class=\"headerlink\" title=\"SEO优化\"></a>SEO优化</h2><h3 id=\"让搜索引擎收录你的文章\"><a href=\"#让搜索引擎收录你的文章\" class=\"headerlink\" title=\"让搜索引擎收录你的文章\"></a>让搜索引擎收录你的文章</h3><ul>\n<li>文章URL链接使用abbrlink持久化</li>\n<li>robots.txt配置</li>\n<li>百度搜索资源平台（百度站长平台）配置</li>\n<li>谷歌搜索( google search console)配置</li>\n<li>百度主动推送链接配置</li>\n<li>百度站长平台自动推送配置</li>\n<li>sitemap站点地图生成与提交</li>\n</ul>\n<h3 id=\"网站统计分析\"><a href=\"#网站统计分析\" class=\"headerlink\" title=\"网站统计分析\"></a>网站统计分析</h3><ul>\n<li>配置谷歌分析(google analytics)</li>\n<li>配置百度统计</li>\n</ul>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><h3 id=\"工具分享\"><a href=\"#工具分享\" class=\"headerlink\" title=\"工具分享\"></a>工具分享</h3><ul>\n<li>PicGo图床上传工具</li>\n<li>Typora文章编辑工具</li>\n</ul>\n<h3 id=\"已知bug\"><a href=\"#已知bug\" class=\"headerlink\" title=\"已知bug\"></a>已知bug</h3><ul>\n<li>toc目录跳转和Aplayer冲突</li>\n</ul>"},{"title":"公式编辑","article_type":0,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"mathjax":true,"abbrlink":"8d758de9","_content":"\n如 $\\lim_{x \\to 0} \\frac{\\sin x}{x}$ 渲染的是\n\n$$\n\\begin{eqnarray}\n \\lim_{x \\to 0} \\frac{\\sin x + x^2 + x^3}{x} & = & \\lim_{x \\to 0} \\frac{\\sin x }{x} + \\lim_{x \\to 0} \\frac{x^2 }{x} + \\lim_{x \\to 0}\\frac{x^3}{x} \n\\\\\\\\ & = & \\lim_{x \\to 0}\\frac{\\sin x}{x} \n\\\\\\\\ & = & 1\n\\end{eqnarray}\n$$\n\n<!-- more -->\n斐波那契数列$A_n=A_{n-1}+A_{n-2}$,前后两项的比值逐渐收敛到黄金分割比例\n$$\\lim_{n\\to \\infty}\\frac{A_{n-1}}{A_n}=\\frac{\\sqrt{5}-1}{2}.$$\n\n因式分解\n$$\\begin{split}(x−1)(x−3)&=x^2−4x+3 \\\\ \n&=x^2−4x+4−1 \\\\ \n&=(x−2)^2−1\n\\end{split}\n$$\n\n狄利克雷函数\n\n$$\nD(x)=\n\\begin{cases}\n1,& x \\in Q \\\\\n0,& x \\notin Q\n\\end{cases}\n$$\n\n高斯公式\n$$\n\\iiint_{\\Omega}\\left(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z}\\right) d v=\\iint_{\\Sigma} P d y d z+Q d z d x+R d x d y\n$$\n\n## 2 物理公式\n- 牛顿第一定律: $\\sum \\vec{F}_{i}=\\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=0$\n- 牛顿第二定律: $\\vec{F}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\vec{a}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d}^{2} \\vec{r}}{\\mathrm{d} t^{2}}$\n- 牛顿第三定律: $\\overrightarrow{F_{12}}=-\\overrightarrow{F_{21}}$\n- 质能守恒: $E=mc^2$\n\n## 3 化学公式\n离子反应与沉淀: $\\ce{SO4^2- + Ba^2+ -> BaSO4 v}$\n    \n## 4 生物公式\n光合作用\n范德蒙行列式\n$$D_{n-1}=\\left|\\begin{array}{cccc}\n1 & 1 & \\dots & 1 \\\\\nx_{2} & x_{3} & \\dots & x_{n} \\\\\n\\vdots & \\vdots & & \\vdots \\\\\nx_{2}^{n-2} & x_{3}^{n-2} & \\dots & x_{n}^{n-2}\n\\end{array}\\right|=\\prod_{2 \\leq j<i \\leq n}\\left(x_{i}-x_{j}\\right)$$\n\n线性方程组\n$$\\left\\{\\begin{aligned}\na_{11} x_{1}+a_{12} x_{2}+\\cdots+a_{1 n} x_{n} &=b_{1} \\\\\na_{21} x_{1}+a_{22} x_{2}+\\cdots+a_{2 n} x_{n} &=b_{2} \\\\\n\\cdots \\cdots \\cdots \\\\\na_{m 1} x_{1}+a_{m 2} x_{2}+\\cdots+a_{m n} x_{n} &=b_{m}\n\\end{aligned}\\right.$$\n\n## 2 物理公式\n- 牛顿第一定律: $\\sum \\vec{F}_{i}=\\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=0$\n- 牛顿第二定律: $\\vec{F}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\vec{a}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d}^{2} \\vec{r}}{\\mathrm{d} t^{2}}$\n- 牛顿第三定律: $\\overrightarrow{F_{12}}=-\\overrightarrow{F_{21}}$\n- 质能守恒: $E=mc^2$\n\n万有引力定律: $F=\\frac{G M m}{r^{2}}$\n$$G \\frac{m M}{(r+h)^{2}}=m \\frac{\\nu^{2}}{(r+h)}$$\n基尔霍夫定律\n$$[\\frac{(\\Delta_{r} H_{m})}{ T}]_{p}=\\sum_{B} v_{B} C_{p, m}(B)$$\n热力学第二定律\n$$d S \\geq \\frac{\\delta Q}{T}$$\n\n$$\nax^2 + bx + c = 0\n$$","source":"_drafts/公式.md","raw":"---\ntitle: 公式编辑\ntag:\n  - linux\ncategories:\n  - linux\narticle_type: 0\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\nmathjax: true\nabbrlink: 8d758de9\n---\n\n如 $\\lim_{x \\to 0} \\frac{\\sin x}{x}$ 渲染的是\n\n$$\n\\begin{eqnarray}\n \\lim_{x \\to 0} \\frac{\\sin x + x^2 + x^3}{x} & = & \\lim_{x \\to 0} \\frac{\\sin x }{x} + \\lim_{x \\to 0} \\frac{x^2 }{x} + \\lim_{x \\to 0}\\frac{x^3}{x} \n\\\\\\\\ & = & \\lim_{x \\to 0}\\frac{\\sin x}{x} \n\\\\\\\\ & = & 1\n\\end{eqnarray}\n$$\n\n<!-- more -->\n斐波那契数列$A_n=A_{n-1}+A_{n-2}$,前后两项的比值逐渐收敛到黄金分割比例\n$$\\lim_{n\\to \\infty}\\frac{A_{n-1}}{A_n}=\\frac{\\sqrt{5}-1}{2}.$$\n\n因式分解\n$$\\begin{split}(x−1)(x−3)&=x^2−4x+3 \\\\ \n&=x^2−4x+4−1 \\\\ \n&=(x−2)^2−1\n\\end{split}\n$$\n\n狄利克雷函数\n\n$$\nD(x)=\n\\begin{cases}\n1,& x \\in Q \\\\\n0,& x \\notin Q\n\\end{cases}\n$$\n\n高斯公式\n$$\n\\iiint_{\\Omega}\\left(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z}\\right) d v=\\iint_{\\Sigma} P d y d z+Q d z d x+R d x d y\n$$\n\n## 2 物理公式\n- 牛顿第一定律: $\\sum \\vec{F}_{i}=\\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=0$\n- 牛顿第二定律: $\\vec{F}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\vec{a}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d}^{2} \\vec{r}}{\\mathrm{d} t^{2}}$\n- 牛顿第三定律: $\\overrightarrow{F_{12}}=-\\overrightarrow{F_{21}}$\n- 质能守恒: $E=mc^2$\n\n## 3 化学公式\n离子反应与沉淀: $\\ce{SO4^2- + Ba^2+ -> BaSO4 v}$\n    \n## 4 生物公式\n光合作用\n范德蒙行列式\n$$D_{n-1}=\\left|\\begin{array}{cccc}\n1 & 1 & \\dots & 1 \\\\\nx_{2} & x_{3} & \\dots & x_{n} \\\\\n\\vdots & \\vdots & & \\vdots \\\\\nx_{2}^{n-2} & x_{3}^{n-2} & \\dots & x_{n}^{n-2}\n\\end{array}\\right|=\\prod_{2 \\leq j<i \\leq n}\\left(x_{i}-x_{j}\\right)$$\n\n线性方程组\n$$\\left\\{\\begin{aligned}\na_{11} x_{1}+a_{12} x_{2}+\\cdots+a_{1 n} x_{n} &=b_{1} \\\\\na_{21} x_{1}+a_{22} x_{2}+\\cdots+a_{2 n} x_{n} &=b_{2} \\\\\n\\cdots \\cdots \\cdots \\\\\na_{m 1} x_{1}+a_{m 2} x_{2}+\\cdots+a_{m n} x_{n} &=b_{m}\n\\end{aligned}\\right.$$\n\n## 2 物理公式\n- 牛顿第一定律: $\\sum \\vec{F}_{i}=\\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=0$\n- 牛顿第二定律: $\\vec{F}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\vec{a}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d}^{2} \\vec{r}}{\\mathrm{d} t^{2}}$\n- 牛顿第三定律: $\\overrightarrow{F_{12}}=-\\overrightarrow{F_{21}}$\n- 质能守恒: $E=mc^2$\n\n万有引力定律: $F=\\frac{G M m}{r^{2}}$\n$$G \\frac{m M}{(r+h)^{2}}=m \\frac{\\nu^{2}}{(r+h)}$$\n基尔霍夫定律\n$$[\\frac{(\\Delta_{r} H_{m})}{ T}]_{p}=\\sum_{B} v_{B} C_{p, m}(B)$$\n热力学第二定律\n$$d S \\geq \\frac{\\delta Q}{T}$$\n\n$$\nax^2 + bx + c = 0\n$$","slug":"公式","published":0,"date":"2022-11-24T13:36:19.845Z","updated":"2022-08-14T11:16:31.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4l000k64rg6j8p9mkq","content":"<p>如 $\\lim_{x \\to 0} \\frac{\\sin x}{x}$ 渲染的是</p>\n<p>$$<br>\\begin{eqnarray}<br> \\lim_{x \\to 0} \\frac{\\sin x + x^2 + x^3}{x} &amp; = &amp; \\lim_{x \\to 0} \\frac{\\sin x }{x} + \\lim_{x \\to 0} \\frac{x^2 }{x} + \\lim_{x \\to 0}\\frac{x^3}{x}<br>\\\\ &amp; = &amp; \\lim_{x \\to 0}\\frac{\\sin x}{x}<br>\\\\ &amp; = &amp; 1<br>\\end{eqnarray}<br>$$</p>\n<span id=\"more\"></span>\n<p>斐波那契数列$A_n=A_{n-1}+A_{n-2}$,前后两项的比值逐渐收敛到黄金分割比例<br>$$\\lim_{n\\to \\infty}\\frac{A_{n-1}}{A_n}=\\frac{\\sqrt{5}-1}{2}.$$</p>\n<p>因式分解<br>$$\\begin{split}(x−1)(x−3)&amp;=x^2−4x+3 \\<br>&amp;=x^2−4x+4−1 \\<br>&amp;=(x−2)^2−1<br>\\end{split}<br>$$</p>\n<p>狄利克雷函数</p>\n<p>$$<br>D(x)=<br>\\begin{cases}<br>1,&amp; x \\in Q \\<br>0,&amp; x \\notin Q<br>\\end{cases}<br>$$</p>\n<p>高斯公式<br>$$<br>\\iiint_{\\Omega}\\left(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z}\\right) d v=\\iint_{\\Sigma} P d y d z+Q d z d x+R d x d y<br>$$</p>\n<h2 id=\"2-物理公式\"><a href=\"#2-物理公式\" class=\"headerlink\" title=\"2 物理公式\"></a>2 物理公式</h2><ul>\n<li>牛顿第一定律: $\\sum \\vec{F}_{i}=\\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=0$</li>\n<li>牛顿第二定律: $\\vec{F}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\vec{a}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d}^{2} \\vec{r}}{\\mathrm{d} t^{2}}$</li>\n<li>牛顿第三定律: $\\overrightarrow{F_{12}}=-\\overrightarrow{F_{21}}$</li>\n<li>质能守恒: $E=mc^2$</li>\n</ul>\n<h2 id=\"3-化学公式\"><a href=\"#3-化学公式\" class=\"headerlink\" title=\"3 化学公式\"></a>3 化学公式</h2><p>离子反应与沉淀: $\\ce{SO4^2- + Ba^2+ -&gt; BaSO4 v}$</p>\n<h2 id=\"4-生物公式\"><a href=\"#4-生物公式\" class=\"headerlink\" title=\"4 生物公式\"></a>4 生物公式</h2><p>光合作用<br>范德蒙行列式<br>$$D_{n-1}=\\left|\\begin{array}{cccc}<br>1 &amp; 1 &amp; \\dots &amp; 1 \\<br>x_{2} &amp; x_{3} &amp; \\dots &amp; x_{n} \\<br>\\vdots &amp; \\vdots &amp; &amp; \\vdots \\<br>x_{2}^{n-2} &amp; x_{3}^{n-2} &amp; \\dots &amp; x_{n}^{n-2}<br>\\end{array}\\right|=\\prod_{2 \\leq j&lt;i \\leq n}\\left(x_{i}-x_{j}\\right)$$</p>\n<p>线性方程组<br>$$\\left{\\begin{aligned}<br>a_{11} x_{1}+a_{12} x_{2}+\\cdots+a_{1 n} x_{n} &amp;=b_{1} \\<br>a_{21} x_{1}+a_{22} x_{2}+\\cdots+a_{2 n} x_{n} &amp;=b_{2} \\<br>\\cdots \\cdots \\cdots \\<br>a_{m 1} x_{1}+a_{m 2} x_{2}+\\cdots+a_{m n} x_{n} &amp;=b_{m}<br>\\end{aligned}\\right.$$</p>\n<h2 id=\"2-物理公式-1\"><a href=\"#2-物理公式-1\" class=\"headerlink\" title=\"2 物理公式\"></a>2 物理公式</h2><ul>\n<li>牛顿第一定律: $\\sum \\vec{F}_{i}=\\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=0$</li>\n<li>牛顿第二定律: $\\vec{F}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\vec{a}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d}^{2} \\vec{r}}{\\mathrm{d} t^{2}}$</li>\n<li>牛顿第三定律: $\\overrightarrow{F_{12}}=-\\overrightarrow{F_{21}}$</li>\n<li>质能守恒: $E=mc^2$</li>\n</ul>\n<p>万有引力定律: $F=\\frac{G M m}{r^{2}}$<br>$$G \\frac{m M}{(r+h)^{2}}=m \\frac{\\nu^{2}}{(r+h)}$$<br>基尔霍夫定律<br>$$[\\frac{(\\Delta_{r} H_{m})}{ T}]<em>{p}=\\sum</em>{B} v_{B} C_{p, m}(B)$$<br>热力学第二定律<br>$$d S \\geq \\frac{\\delta Q}{T}$$</p>\n<p>$$<br>ax^2 + bx + c = 0<br>$$</p>\n","site":{"data":{}},"excerpt":"<p>如 $\\lim_{x \\to 0} \\frac{\\sin x}{x}$ 渲染的是</p>\n<p>$$<br>\\begin{eqnarray}<br> \\lim_{x \\to 0} \\frac{\\sin x + x^2 + x^3}{x} &amp; = &amp; \\lim_{x \\to 0} \\frac{\\sin x }{x} + \\lim_{x \\to 0} \\frac{x^2 }{x} + \\lim_{x \\to 0}\\frac{x^3}{x}<br>\\\\ &amp; = &amp; \\lim_{x \\to 0}\\frac{\\sin x}{x}<br>\\\\ &amp; = &amp; 1<br>\\end{eqnarray}<br>$$</p>","more":"<p>斐波那契数列$A_n=A_{n-1}+A_{n-2}$,前后两项的比值逐渐收敛到黄金分割比例<br>$$\\lim_{n\\to \\infty}\\frac{A_{n-1}}{A_n}=\\frac{\\sqrt{5}-1}{2}.$$</p>\n<p>因式分解<br>$$\\begin{split}(x−1)(x−3)&amp;=x^2−4x+3 \\<br>&amp;=x^2−4x+4−1 \\<br>&amp;=(x−2)^2−1<br>\\end{split}<br>$$</p>\n<p>狄利克雷函数</p>\n<p>$$<br>D(x)=<br>\\begin{cases}<br>1,&amp; x \\in Q \\<br>0,&amp; x \\notin Q<br>\\end{cases}<br>$$</p>\n<p>高斯公式<br>$$<br>\\iiint_{\\Omega}\\left(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z}\\right) d v=\\iint_{\\Sigma} P d y d z+Q d z d x+R d x d y<br>$$</p>\n<h2 id=\"2-物理公式\"><a href=\"#2-物理公式\" class=\"headerlink\" title=\"2 物理公式\"></a>2 物理公式</h2><ul>\n<li>牛顿第一定律: $\\sum \\vec{F}_{i}=\\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=0$</li>\n<li>牛顿第二定律: $\\vec{F}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\vec{a}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d}^{2} \\vec{r}}{\\mathrm{d} t^{2}}$</li>\n<li>牛顿第三定律: $\\overrightarrow{F_{12}}=-\\overrightarrow{F_{21}}$</li>\n<li>质能守恒: $E=mc^2$</li>\n</ul>\n<h2 id=\"3-化学公式\"><a href=\"#3-化学公式\" class=\"headerlink\" title=\"3 化学公式\"></a>3 化学公式</h2><p>离子反应与沉淀: $\\ce{SO4^2- + Ba^2+ -&gt; BaSO4 v}$</p>\n<h2 id=\"4-生物公式\"><a href=\"#4-生物公式\" class=\"headerlink\" title=\"4 生物公式\"></a>4 生物公式</h2><p>光合作用<br>范德蒙行列式<br>$$D_{n-1}=\\left|\\begin{array}{cccc}<br>1 &amp; 1 &amp; \\dots &amp; 1 \\<br>x_{2} &amp; x_{3} &amp; \\dots &amp; x_{n} \\<br>\\vdots &amp; \\vdots &amp; &amp; \\vdots \\<br>x_{2}^{n-2} &amp; x_{3}^{n-2} &amp; \\dots &amp; x_{n}^{n-2}<br>\\end{array}\\right|=\\prod_{2 \\leq j&lt;i \\leq n}\\left(x_{i}-x_{j}\\right)$$</p>\n<p>线性方程组<br>$$\\left{\\begin{aligned}<br>a_{11} x_{1}+a_{12} x_{2}+\\cdots+a_{1 n} x_{n} &amp;=b_{1} \\<br>a_{21} x_{1}+a_{22} x_{2}+\\cdots+a_{2 n} x_{n} &amp;=b_{2} \\<br>\\cdots \\cdots \\cdots \\<br>a_{m 1} x_{1}+a_{m 2} x_{2}+\\cdots+a_{m n} x_{n} &amp;=b_{m}<br>\\end{aligned}\\right.$$</p>\n<h2 id=\"2-物理公式-1\"><a href=\"#2-物理公式-1\" class=\"headerlink\" title=\"2 物理公式\"></a>2 物理公式</h2><ul>\n<li>牛顿第一定律: $\\sum \\vec{F}_{i}=\\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=0$</li>\n<li>牛顿第二定律: $\\vec{F}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d} \\vec{v}}{\\mathrm{d} t}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\vec{a}=\\frac{\\mathrm{d} m}{\\mathrm{d} t} \\vec{v}+m \\frac{\\mathrm{d}^{2} \\vec{r}}{\\mathrm{d} t^{2}}$</li>\n<li>牛顿第三定律: $\\overrightarrow{F_{12}}=-\\overrightarrow{F_{21}}$</li>\n<li>质能守恒: $E=mc^2$</li>\n</ul>\n<p>万有引力定律: $F=\\frac{G M m}{r^{2}}$<br>$$G \\frac{m M}{(r+h)^{2}}=m \\frac{\\nu^{2}}{(r+h)}$$<br>基尔霍夫定律<br>$$[\\frac{(\\Delta_{r} H_{m})}{ T}]<em>{p}=\\sum</em>{B} v_{B} C_{p, m}(B)$$<br>热力学第二定律<br>$$d S \\geq \\frac{\\delta Q}{T}$$</p>\n<p>$$<br>ax^2 + bx + c = 0<br>$$</p>"},{"title":"Linux 内核裁剪及编译","article_type":0,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"mathjax":false,"abbrlink":"8283904e","date":"2021-12-13T12:47:44.000Z","top":null,"_content":"\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image-20211213231234705.png\" alt=\"Linux Kernel\" style=\"zoom:100%;\" />\n\n好久没更新了，上周，我利用空闲时间设计了linux内核实验的指导书，现在我把实验过程分享给大家。\n\n本次实验的目标是自己动手裁剪并编译linux内核、制作最小根文件系统、并成功把制作的mini-linu启动起来，具体分为以下几步：\n\n- 下载Linux内核，裁剪并编译内核源码。\n- 下载并编译BusyBox，在此基础上制作一个最小的根文件系统。\n- 用编译好的内核和根文件系统制作可启动的mini-Linux系统。\n- 用QEMU启动制作好的mini-Linux系统。 \n\n<!-- more -->\n\n本次实验基于以下软件和环境完成：\n\n- VMware® Workstation 16 Pro \n- Ubuntu 20.04 LTS\n- Linux内核 5.10.83 （建议版本一致）\n- BusyBox 1.33.2 （建议版本一致）\n- grub-install (GRUB) 2.04\n- QEMU 4.2.1\n\n本篇文章，将完成实验的第一步——Linux内核裁剪及编译。\n\n\n\n> Linux的内核是单内核设计风格的，不过Linux的单内核设计采用了微内核设计风格的模块化设计思想，所以使得内核的核心可以很小，而内核所需要提供的其他功能都被设计成了各种内核模块，需要的时候只需将各种内核模块加载进内核的核心即可，我们可以通过编辑Linux源码目录下的”.config”配置文件来裁剪定制linux内核，在此次实验中，我们主要通过“make menuconfig”命令打开图形化界面来配置“.config”文件。\n\n## 下载内核源码\n\n（1）Linux内核官网：[https://www.kernel.org/](https://www.kernel.org/)。\n\n本次实验我们使用的内核版本为长期支持版本`5.10.83`，下载链接如下：[https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz](https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz)。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image-20211214002141124.png\" alt=\"kernel.org\"  />\n\n（2）本次实验采用的是`VMware® Workstation 16 Pro`虚拟机，虚拟机系统为`Ubuntu 20.04 LTS`。打开虚拟机的Ubuntu20.04系统，实验过程将全程在此系统上完成。\n\n（3）打开终端，切换至root用户（以下操作都在root下完成），切换至根目录，创建实验项目文件夹，并将内核源码下载并解压到该目录下。\n\n\n```bash\nsu \ncd /\nmkdir mini-linux\ncd mini-linux\nwget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz\n```\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image2.png\" alt=\"创建mini-linux目录\" style=\"zoom:67%;\" />\n\n（4）解压下载好的内核源码，并进入到linux-5.10.83目录。\n\n```bash\ntar -vxf linux-5.10.83.tar.xz\ncd linux-5.10.83\n```\n\n如果不是第一次编译，请运行以下命令清理：\n\n- makeclean: 删除编译中间文件，但是保留配置。\n- make mrproper：删除包括配置文件的所有构建文件。\n- make distclean：执行mrproper所做的一切，并删除备份文件。\n\n## 配置内核\n\n（1）指定硬件体系架构为`x86`。\n\n```bash\n export ARCH=x86  \n```\n\n（2）生成config文件。\n\nLinux自带很多内核的配置文件，如：\n\n- make defconfig：生成默认的内核配置。\n\n- make allmodconfig：所有的可选的选项构建成模块。\n\n- make allyesconfig：生成全部选择是的内核配置。\n\n- make noconfig：生成全部选择否的内核配置。\n\n（3）本次实验我们根据虚拟机系统，选择 x86_64_defconfig 。\n\n```bash\nmake x86_64_defconfig\n```\n\n此操作会将`./arch/x86/configs/x86_64_defconfig`文件复制为`./.config`，作为我们编译内核的初始配置文件。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image3.png\" alt=\"生成config文件\" style=\"zoom:67%;\" />\n\n（4）使用图形化界面配置内核。\n\n```bash\nmake meunconfig\n```\n\n此时会进入Kernel Configuration图形化配置界面\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image4.png\" alt=\"Kernel Configuration图形化配置界面\" style=\"zoom:67%;\" />\n\n（5）我们用键盘操作此图形界面：\n\n- [*]代表被选中，[ ]表示未被选中。\n\n- ↑ ↓ 方向键可以快速在配置项中选择。\n\n\n- ← → 方向键可以在select、exit等菜单项之间选择。\t\n\n\n- Y 选择此项，并包含进内核中。\n\n\n- N 取消选择此项，不包含内核中。\n\n\n- M 编译成模块。\n\n\n- Enter 进入或确认选项。\n\n\n- **H 配置说明**。\n\n​\t*在任何一个选项下按H，可以看到详细的配置说明，自己不确定的项可以用此方法来辅助判断，如下图，如果有`If unsure say Y`、`you'll need to say Y here`、`If in doubt, say \"Y\"`则建议必选，如果有`If unsure say N here`，则可以根据情况不选。*\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image5.png\" alt=\"配置小技巧\" style=\"zoom: 67%;\" />\n\n- **/ 搜索**。\n\n​\t*在任意界面输入`/`，则会进入搜索，可以根据需求搜索配置项。*\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image6.png\" alt=\"搜索界面\" style=\"zoom: 67%;\" />\n\n返回搜索结果后，再输入搜索结果对应的数字，则会跳转至对应的配置项，可以大大提高效率。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image7.png\" alt=\"搜索结果\" style=\"zoom:67%;\" />\n\nKernel配置介绍、裁剪经验，可以参考以下文档\n\n​\t[1]. [Linux内核（4.17.10）配置项详解（x86）](https://blog.csdn.net/liao20081228/article/details/81389813)\n\n​\t[2]. [kernel裁剪](https://blog.csdn.net/weixin_43892506/article/details/117885040)\n\n​\t[3]. [linux内核裁剪的具体过程和方法](https://blog.csdn.net/u011124985/article/details/80453772)\n\n## 内核裁剪\n\n通过内核裁剪，我们可以\n\n- 学习内核裁剪的方法和流程。\n\n- 在资源内有限的时候，裁剪内核可以使系统变得简洁和轻量化。\n\n- 不必要的驱动，不仅使得内核占用空间，运行速度慢，还会引起不必要的问题。\n\n内核裁剪在`menuconfig`界面进行，我们使用的`x86_64_defconfig`已经做了大量裁剪，编译后内核大小仅有9.5M，精细裁剪需要花费大量时间，这里仅演示几项，大家可以多多尝试。\n\n（1）给内核版本号添加自定义后缀：\n\n- 在`General setup`选项下，选择`Local version - append to kernel release`，我们可以给内核版本号添加自定义后缀，如`-mini-linux-2021`。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image8.png\" alt=\"内核版本号添加自定义后缀\" style=\"zoom: 67%;\" />\n\n（2）我们需要内核支持RAM disk：\n\n- 在`General setup`选项下，选择`Initial RAM filesystem and RAM disk (initramfs/initrd) support`。\n- 在`Device Drivers`选项下，勾选`Block devices`，并进入`Block devices`，勾选`RAM block device support`，并将其第二项`Default RAM disk size (kbytes) (NEW)`设置为`65536`。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image9.png\" alt=\"RAM disk support\" style=\"zoom: 67%;\" />\n\n（3）取消多核心调度增强：\n\n- 在`Processor type and features`选项下，取消勾选多核心调度增强`Multi-core scheduler support`。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image10.png\" alt=\"取消多核心调度增强\" style=\"zoom: 67%;\" />\n\n（4）取消调试内核：\n\n- 在`General architecture-dependent options`选项下，取消勾选调试内核`Kprobes`选项。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image11.png\" alt=\"取消调试内核\" style=\"zoom: 67%;\" />\n\n（5）取消允许强制卸载正在使用中的模块：\n\n- 在`Enable loadable module support`选项下，取消勾选允许强制卸载正在使用中的模块`Forced module unloading`。\n\n（6）取消勾选磁盘配额：\n\n- 在`File systems`选项下，取消勾选磁盘配额`Quota support`。\n\n在所有需要的选项配置完毕之后，按Exit退出，选择Yes保存。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image12.png\" alt=\"保存并退出内核配置\" style=\"zoom: 67%;\" />\n\n## 编译内核\n\n（1）下面就可以开始编译内核了：\n\n```bash\nmake -j8\n```\n\nmake命令后面跟着线程数，8表示使用8线程去执行，不要超过虚拟机系统配置的核心数。\n\n我的机子16G内存，8线程编译，大概10分钟，编译就完成了，编译成功后的内核位于：`arch/x86_64/boot/bzImage`。\n\n（2）把编译好的内核文件拷贝到mini-linux目录下\n\n```bash\ncp arch/x86_64/boot/bzImage ../\ncd ..\nls -alh\n```\n\n用`ls`命令，可以看到它的大小只有9.2M。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image13.png\" alt=\"查看编译好的内核\" style=\"zoom: 67%;\" />\n\nLinux 内核裁剪及编译教程就到这里，下一部分是用busybox制作一个最小的根文件系统，敬请关注！\n\n","source":"_posts/04 Linux内核裁剪及编译.md","raw":"---\ntitle: Linux 内核裁剪及编译\ntag:\n  - linux\ncategories:\n  - linux\narticle_type: 0\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\nmathjax: false\nabbrlink: 8283904e\ndate: 2021-12-13 20:47:44\ntop:\n---\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image-20211213231234705.png\" alt=\"Linux Kernel\" style=\"zoom:100%;\" />\n\n好久没更新了，上周，我利用空闲时间设计了linux内核实验的指导书，现在我把实验过程分享给大家。\n\n本次实验的目标是自己动手裁剪并编译linux内核、制作最小根文件系统、并成功把制作的mini-linu启动起来，具体分为以下几步：\n\n- 下载Linux内核，裁剪并编译内核源码。\n- 下载并编译BusyBox，在此基础上制作一个最小的根文件系统。\n- 用编译好的内核和根文件系统制作可启动的mini-Linux系统。\n- 用QEMU启动制作好的mini-Linux系统。 \n\n<!-- more -->\n\n本次实验基于以下软件和环境完成：\n\n- VMware® Workstation 16 Pro \n- Ubuntu 20.04 LTS\n- Linux内核 5.10.83 （建议版本一致）\n- BusyBox 1.33.2 （建议版本一致）\n- grub-install (GRUB) 2.04\n- QEMU 4.2.1\n\n本篇文章，将完成实验的第一步——Linux内核裁剪及编译。\n\n\n\n> Linux的内核是单内核设计风格的，不过Linux的单内核设计采用了微内核设计风格的模块化设计思想，所以使得内核的核心可以很小，而内核所需要提供的其他功能都被设计成了各种内核模块，需要的时候只需将各种内核模块加载进内核的核心即可，我们可以通过编辑Linux源码目录下的”.config”配置文件来裁剪定制linux内核，在此次实验中，我们主要通过“make menuconfig”命令打开图形化界面来配置“.config”文件。\n\n## 下载内核源码\n\n（1）Linux内核官网：[https://www.kernel.org/](https://www.kernel.org/)。\n\n本次实验我们使用的内核版本为长期支持版本`5.10.83`，下载链接如下：[https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz](https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz)。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image-20211214002141124.png\" alt=\"kernel.org\"  />\n\n（2）本次实验采用的是`VMware® Workstation 16 Pro`虚拟机，虚拟机系统为`Ubuntu 20.04 LTS`。打开虚拟机的Ubuntu20.04系统，实验过程将全程在此系统上完成。\n\n（3）打开终端，切换至root用户（以下操作都在root下完成），切换至根目录，创建实验项目文件夹，并将内核源码下载并解压到该目录下。\n\n\n```bash\nsu \ncd /\nmkdir mini-linux\ncd mini-linux\nwget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz\n```\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image2.png\" alt=\"创建mini-linux目录\" style=\"zoom:67%;\" />\n\n（4）解压下载好的内核源码，并进入到linux-5.10.83目录。\n\n```bash\ntar -vxf linux-5.10.83.tar.xz\ncd linux-5.10.83\n```\n\n如果不是第一次编译，请运行以下命令清理：\n\n- makeclean: 删除编译中间文件，但是保留配置。\n- make mrproper：删除包括配置文件的所有构建文件。\n- make distclean：执行mrproper所做的一切，并删除备份文件。\n\n## 配置内核\n\n（1）指定硬件体系架构为`x86`。\n\n```bash\n export ARCH=x86  \n```\n\n（2）生成config文件。\n\nLinux自带很多内核的配置文件，如：\n\n- make defconfig：生成默认的内核配置。\n\n- make allmodconfig：所有的可选的选项构建成模块。\n\n- make allyesconfig：生成全部选择是的内核配置。\n\n- make noconfig：生成全部选择否的内核配置。\n\n（3）本次实验我们根据虚拟机系统，选择 x86_64_defconfig 。\n\n```bash\nmake x86_64_defconfig\n```\n\n此操作会将`./arch/x86/configs/x86_64_defconfig`文件复制为`./.config`，作为我们编译内核的初始配置文件。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image3.png\" alt=\"生成config文件\" style=\"zoom:67%;\" />\n\n（4）使用图形化界面配置内核。\n\n```bash\nmake meunconfig\n```\n\n此时会进入Kernel Configuration图形化配置界面\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image4.png\" alt=\"Kernel Configuration图形化配置界面\" style=\"zoom:67%;\" />\n\n（5）我们用键盘操作此图形界面：\n\n- [*]代表被选中，[ ]表示未被选中。\n\n- ↑ ↓ 方向键可以快速在配置项中选择。\n\n\n- ← → 方向键可以在select、exit等菜单项之间选择。\t\n\n\n- Y 选择此项，并包含进内核中。\n\n\n- N 取消选择此项，不包含内核中。\n\n\n- M 编译成模块。\n\n\n- Enter 进入或确认选项。\n\n\n- **H 配置说明**。\n\n​\t*在任何一个选项下按H，可以看到详细的配置说明，自己不确定的项可以用此方法来辅助判断，如下图，如果有`If unsure say Y`、`you'll need to say Y here`、`If in doubt, say \"Y\"`则建议必选，如果有`If unsure say N here`，则可以根据情况不选。*\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image5.png\" alt=\"配置小技巧\" style=\"zoom: 67%;\" />\n\n- **/ 搜索**。\n\n​\t*在任意界面输入`/`，则会进入搜索，可以根据需求搜索配置项。*\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image6.png\" alt=\"搜索界面\" style=\"zoom: 67%;\" />\n\n返回搜索结果后，再输入搜索结果对应的数字，则会跳转至对应的配置项，可以大大提高效率。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image7.png\" alt=\"搜索结果\" style=\"zoom:67%;\" />\n\nKernel配置介绍、裁剪经验，可以参考以下文档\n\n​\t[1]. [Linux内核（4.17.10）配置项详解（x86）](https://blog.csdn.net/liao20081228/article/details/81389813)\n\n​\t[2]. [kernel裁剪](https://blog.csdn.net/weixin_43892506/article/details/117885040)\n\n​\t[3]. [linux内核裁剪的具体过程和方法](https://blog.csdn.net/u011124985/article/details/80453772)\n\n## 内核裁剪\n\n通过内核裁剪，我们可以\n\n- 学习内核裁剪的方法和流程。\n\n- 在资源内有限的时候，裁剪内核可以使系统变得简洁和轻量化。\n\n- 不必要的驱动，不仅使得内核占用空间，运行速度慢，还会引起不必要的问题。\n\n内核裁剪在`menuconfig`界面进行，我们使用的`x86_64_defconfig`已经做了大量裁剪，编译后内核大小仅有9.5M，精细裁剪需要花费大量时间，这里仅演示几项，大家可以多多尝试。\n\n（1）给内核版本号添加自定义后缀：\n\n- 在`General setup`选项下，选择`Local version - append to kernel release`，我们可以给内核版本号添加自定义后缀，如`-mini-linux-2021`。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image8.png\" alt=\"内核版本号添加自定义后缀\" style=\"zoom: 67%;\" />\n\n（2）我们需要内核支持RAM disk：\n\n- 在`General setup`选项下，选择`Initial RAM filesystem and RAM disk (initramfs/initrd) support`。\n- 在`Device Drivers`选项下，勾选`Block devices`，并进入`Block devices`，勾选`RAM block device support`，并将其第二项`Default RAM disk size (kbytes) (NEW)`设置为`65536`。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image9.png\" alt=\"RAM disk support\" style=\"zoom: 67%;\" />\n\n（3）取消多核心调度增强：\n\n- 在`Processor type and features`选项下，取消勾选多核心调度增强`Multi-core scheduler support`。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image10.png\" alt=\"取消多核心调度增强\" style=\"zoom: 67%;\" />\n\n（4）取消调试内核：\n\n- 在`General architecture-dependent options`选项下，取消勾选调试内核`Kprobes`选项。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image11.png\" alt=\"取消调试内核\" style=\"zoom: 67%;\" />\n\n（5）取消允许强制卸载正在使用中的模块：\n\n- 在`Enable loadable module support`选项下，取消勾选允许强制卸载正在使用中的模块`Forced module unloading`。\n\n（6）取消勾选磁盘配额：\n\n- 在`File systems`选项下，取消勾选磁盘配额`Quota support`。\n\n在所有需要的选项配置完毕之后，按Exit退出，选择Yes保存。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image12.png\" alt=\"保存并退出内核配置\" style=\"zoom: 67%;\" />\n\n## 编译内核\n\n（1）下面就可以开始编译内核了：\n\n```bash\nmake -j8\n```\n\nmake命令后面跟着线程数，8表示使用8线程去执行，不要超过虚拟机系统配置的核心数。\n\n我的机子16G内存，8线程编译，大概10分钟，编译就完成了，编译成功后的内核位于：`arch/x86_64/boot/bzImage`。\n\n（2）把编译好的内核文件拷贝到mini-linux目录下\n\n```bash\ncp arch/x86_64/boot/bzImage ../\ncd ..\nls -alh\n```\n\n用`ls`命令，可以看到它的大小只有9.2M。\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image13.png\" alt=\"查看编译好的内核\" style=\"zoom: 67%;\" />\n\nLinux 内核裁剪及编译教程就到这里，下一部分是用busybox制作一个最小的根文件系统，敬请关注！\n\n","slug":"04 Linux内核裁剪及编译","published":1,"updated":"2022-11-22T03:17:31.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4m000l64rgcu8e6tib","content":"<img src=\"https://qiniu.findn.cn//blog/photos/article/image-20211213231234705.png\" alt=\"Linux Kernel\" style=\"zoom:100%;\" />\n\n<p>好久没更新了，上周，我利用空闲时间设计了linux内核实验的指导书，现在我把实验过程分享给大家。</p>\n<p>本次实验的目标是自己动手裁剪并编译linux内核、制作最小根文件系统、并成功把制作的mini-linu启动起来，具体分为以下几步：</p>\n<ul>\n<li>下载Linux内核，裁剪并编译内核源码。</li>\n<li>下载并编译BusyBox，在此基础上制作一个最小的根文件系统。</li>\n<li>用编译好的内核和根文件系统制作可启动的mini-Linux系统。</li>\n<li>用QEMU启动制作好的mini-Linux系统。 </li>\n</ul>\n<span id=\"more\"></span>\n\n<p>本次实验基于以下软件和环境完成：</p>\n<ul>\n<li>VMware® Workstation 16 Pro </li>\n<li>Ubuntu 20.04 LTS</li>\n<li>Linux内核 5.10.83 （建议版本一致）</li>\n<li>BusyBox 1.33.2 （建议版本一致）</li>\n<li>grub-install (GRUB) 2.04</li>\n<li>QEMU 4.2.1</li>\n</ul>\n<p>本篇文章，将完成实验的第一步——Linux内核裁剪及编译。</p>\n<blockquote>\n<p>Linux的内核是单内核设计风格的，不过Linux的单内核设计采用了微内核设计风格的模块化设计思想，所以使得内核的核心可以很小，而内核所需要提供的其他功能都被设计成了各种内核模块，需要的时候只需将各种内核模块加载进内核的核心即可，我们可以通过编辑Linux源码目录下的”.config”配置文件来裁剪定制linux内核，在此次实验中，我们主要通过“make menuconfig”命令打开图形化界面来配置“.config”文件。</p>\n</blockquote>\n<h2 id=\"下载内核源码\"><a href=\"#下载内核源码\" class=\"headerlink\" title=\"下载内核源码\"></a>下载内核源码</h2><p>（1）Linux内核官网：<a href=\"https://www.kernel.org/\">https://www.kernel.org/</a>。</p>\n<p>本次实验我们使用的内核版本为长期支持版本<code>5.10.83</code>，下载链接如下：<a href=\"https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz\">https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz</a>。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image-20211214002141124.png\" alt=\"kernel.org\"  />\n\n<p>（2）本次实验采用的是<code>VMware® Workstation 16 Pro</code>虚拟机，虚拟机系统为<code>Ubuntu 20.04 LTS</code>。打开虚拟机的Ubuntu20.04系统，实验过程将全程在此系统上完成。</p>\n<p>（3）打开终端，切换至root用户（以下操作都在root下完成），切换至根目录，创建实验项目文件夹，并将内核源码下载并解压到该目录下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su </span><br><span class=\"line\"><span class=\"built_in\">cd</span> /</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> mini-linux</span><br><span class=\"line\"><span class=\"built_in\">cd</span> mini-linux</span><br><span class=\"line\">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image2.png\" alt=\"创建mini-linux目录\" style=\"zoom:67%;\" />\n\n<p>（4）解压下载好的内核源码，并进入到linux-5.10.83目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -vxf linux-5.10.83.tar.xz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> linux-5.10.83</span><br></pre></td></tr></table></figure>\n\n<p>如果不是第一次编译，请运行以下命令清理：</p>\n<ul>\n<li>makeclean: 删除编译中间文件，但是保留配置。</li>\n<li>make mrproper：删除包括配置文件的所有构建文件。</li>\n<li>make distclean：执行mrproper所做的一切，并删除备份文件。</li>\n</ul>\n<h2 id=\"配置内核\"><a href=\"#配置内核\" class=\"headerlink\" title=\"配置内核\"></a>配置内核</h2><p>（1）指定硬件体系架构为<code>x86</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> ARCH=x86  </span><br></pre></td></tr></table></figure>\n\n<p>（2）生成config文件。</p>\n<p>Linux自带很多内核的配置文件，如：</p>\n<ul>\n<li><p>make defconfig：生成默认的内核配置。</p>\n</li>\n<li><p>make allmodconfig：所有的可选的选项构建成模块。</p>\n</li>\n<li><p>make allyesconfig：生成全部选择是的内核配置。</p>\n</li>\n<li><p>make noconfig：生成全部选择否的内核配置。</p>\n</li>\n</ul>\n<p>（3）本次实验我们根据虚拟机系统，选择 x86_64_defconfig 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make x86_64_defconfig</span><br></pre></td></tr></table></figure>\n\n<p>此操作会将<code>./arch/x86/configs/x86_64_defconfig</code>文件复制为<code>./.config</code>，作为我们编译内核的初始配置文件。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image3.png\" alt=\"生成config文件\" style=\"zoom:67%;\" />\n\n<p>（4）使用图形化界面配置内核。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make meunconfig</span><br></pre></td></tr></table></figure>\n\n<p>此时会进入Kernel Configuration图形化配置界面</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image4.png\" alt=\"Kernel Configuration图形化配置界面\" style=\"zoom:67%;\" />\n\n<p>（5）我们用键盘操作此图形界面：</p>\n<ul>\n<li><p>[*]代表被选中，[ ]表示未被选中。</p>\n</li>\n<li><p>↑ ↓ 方向键可以快速在配置项中选择。</p>\n</li>\n</ul>\n<ul>\n<li>← → 方向键可以在select、exit等菜单项之间选择。    </li>\n</ul>\n<ul>\n<li>Y 选择此项，并包含进内核中。</li>\n</ul>\n<ul>\n<li>N 取消选择此项，不包含内核中。</li>\n</ul>\n<ul>\n<li>M 编译成模块。</li>\n</ul>\n<ul>\n<li>Enter 进入或确认选项。</li>\n</ul>\n<ul>\n<li><strong>H 配置说明</strong>。</li>\n</ul>\n<p>​    <em>在任何一个选项下按H，可以看到详细的配置说明，自己不确定的项可以用此方法来辅助判断，如下图，如果有<code>If unsure say Y</code>、<code>you&#39;ll need to say Y here</code>、<code>If in doubt, say &quot;Y&quot;</code>则建议必选，如果有<code>If unsure say N here</code>，则可以根据情况不选。</em></p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image5.png\" alt=\"配置小技巧\" style=\"zoom: 67%;\" />\n\n<ul>\n<li><strong>/ 搜索</strong>。</li>\n</ul>\n<p>​    <em>在任意界面输入<code>/</code>，则会进入搜索，可以根据需求搜索配置项。</em></p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image6.png\" alt=\"搜索界面\" style=\"zoom: 67%;\" />\n\n<p>返回搜索结果后，再输入搜索结果对应的数字，则会跳转至对应的配置项，可以大大提高效率。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image7.png\" alt=\"搜索结果\" style=\"zoom:67%;\" />\n\n<p>Kernel配置介绍、裁剪经验，可以参考以下文档</p>\n<p>​    [1]. <a href=\"https://blog.csdn.net/liao20081228/article/details/81389813\">Linux内核（4.17.10）配置项详解（x86）</a></p>\n<p>​    [2]. <a href=\"https://blog.csdn.net/weixin_43892506/article/details/117885040\">kernel裁剪</a></p>\n<p>​    [3]. <a href=\"https://blog.csdn.net/u011124985/article/details/80453772\">linux内核裁剪的具体过程和方法</a></p>\n<h2 id=\"内核裁剪\"><a href=\"#内核裁剪\" class=\"headerlink\" title=\"内核裁剪\"></a>内核裁剪</h2><p>通过内核裁剪，我们可以</p>\n<ul>\n<li><p>学习内核裁剪的方法和流程。</p>\n</li>\n<li><p>在资源内有限的时候，裁剪内核可以使系统变得简洁和轻量化。</p>\n</li>\n<li><p>不必要的驱动，不仅使得内核占用空间，运行速度慢，还会引起不必要的问题。</p>\n</li>\n</ul>\n<p>内核裁剪在<code>menuconfig</code>界面进行，我们使用的<code>x86_64_defconfig</code>已经做了大量裁剪，编译后内核大小仅有9.5M，精细裁剪需要花费大量时间，这里仅演示几项，大家可以多多尝试。</p>\n<p>（1）给内核版本号添加自定义后缀：</p>\n<ul>\n<li>在<code>General setup</code>选项下，选择<code>Local version - append to kernel release</code>，我们可以给内核版本号添加自定义后缀，如<code>-mini-linux-2021</code>。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image8.png\" alt=\"内核版本号添加自定义后缀\" style=\"zoom: 67%;\" />\n\n<p>（2）我们需要内核支持RAM disk：</p>\n<ul>\n<li>在<code>General setup</code>选项下，选择<code>Initial RAM filesystem and RAM disk (initramfs/initrd) support</code>。</li>\n<li>在<code>Device Drivers</code>选项下，勾选<code>Block devices</code>，并进入<code>Block devices</code>，勾选<code>RAM block device support</code>，并将其第二项<code>Default RAM disk size (kbytes) (NEW)</code>设置为<code>65536</code>。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image9.png\" alt=\"RAM disk support\" style=\"zoom: 67%;\" />\n\n<p>（3）取消多核心调度增强：</p>\n<ul>\n<li>在<code>Processor type and features</code>选项下，取消勾选多核心调度增强<code>Multi-core scheduler support</code>。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image10.png\" alt=\"取消多核心调度增强\" style=\"zoom: 67%;\" />\n\n<p>（4）取消调试内核：</p>\n<ul>\n<li>在<code>General architecture-dependent options</code>选项下，取消勾选调试内核<code>Kprobes</code>选项。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image11.png\" alt=\"取消调试内核\" style=\"zoom: 67%;\" />\n\n<p>（5）取消允许强制卸载正在使用中的模块：</p>\n<ul>\n<li>在<code>Enable loadable module support</code>选项下，取消勾选允许强制卸载正在使用中的模块<code>Forced module unloading</code>。</li>\n</ul>\n<p>（6）取消勾选磁盘配额：</p>\n<ul>\n<li>在<code>File systems</code>选项下，取消勾选磁盘配额<code>Quota support</code>。</li>\n</ul>\n<p>在所有需要的选项配置完毕之后，按Exit退出，选择Yes保存。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image12.png\" alt=\"保存并退出内核配置\" style=\"zoom: 67%;\" />\n\n<h2 id=\"编译内核\"><a href=\"#编译内核\" class=\"headerlink\" title=\"编译内核\"></a>编译内核</h2><p>（1）下面就可以开始编译内核了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -j8</span><br></pre></td></tr></table></figure>\n\n<p>make命令后面跟着线程数，8表示使用8线程去执行，不要超过虚拟机系统配置的核心数。</p>\n<p>我的机子16G内存，8线程编译，大概10分钟，编译就完成了，编译成功后的内核位于：<code>arch/x86_64/boot/bzImage</code>。</p>\n<p>（2）把编译好的内核文件拷贝到mini-linux目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> <span class=\"built_in\">arch</span>/x86_64/boot/bzImage ../</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -alh</span><br></pre></td></tr></table></figure>\n\n<p>用<code>ls</code>命令，可以看到它的大小只有9.2M。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image13.png\" alt=\"查看编译好的内核\" style=\"zoom: 67%;\" />\n\n<p>Linux 内核裁剪及编译教程就到这里，下一部分是用busybox制作一个最小的根文件系统，敬请关注！</p>\n","site":{"data":{}},"excerpt":"<img src=\"https://qiniu.findn.cn//blog/photos/article/image-20211213231234705.png\" alt=\"Linux Kernel\" style=\"zoom:100%;\" />\n\n<p>好久没更新了，上周，我利用空闲时间设计了linux内核实验的指导书，现在我把实验过程分享给大家。</p>\n<p>本次实验的目标是自己动手裁剪并编译linux内核、制作最小根文件系统、并成功把制作的mini-linu启动起来，具体分为以下几步：</p>\n<ul>\n<li>下载Linux内核，裁剪并编译内核源码。</li>\n<li>下载并编译BusyBox，在此基础上制作一个最小的根文件系统。</li>\n<li>用编译好的内核和根文件系统制作可启动的mini-Linux系统。</li>\n<li>用QEMU启动制作好的mini-Linux系统。 </li>\n</ul>","more":"<p>本次实验基于以下软件和环境完成：</p>\n<ul>\n<li>VMware® Workstation 16 Pro </li>\n<li>Ubuntu 20.04 LTS</li>\n<li>Linux内核 5.10.83 （建议版本一致）</li>\n<li>BusyBox 1.33.2 （建议版本一致）</li>\n<li>grub-install (GRUB) 2.04</li>\n<li>QEMU 4.2.1</li>\n</ul>\n<p>本篇文章，将完成实验的第一步——Linux内核裁剪及编译。</p>\n<blockquote>\n<p>Linux的内核是单内核设计风格的，不过Linux的单内核设计采用了微内核设计风格的模块化设计思想，所以使得内核的核心可以很小，而内核所需要提供的其他功能都被设计成了各种内核模块，需要的时候只需将各种内核模块加载进内核的核心即可，我们可以通过编辑Linux源码目录下的”.config”配置文件来裁剪定制linux内核，在此次实验中，我们主要通过“make menuconfig”命令打开图形化界面来配置“.config”文件。</p>\n</blockquote>\n<h2 id=\"下载内核源码\"><a href=\"#下载内核源码\" class=\"headerlink\" title=\"下载内核源码\"></a>下载内核源码</h2><p>（1）Linux内核官网：<a href=\"https://www.kernel.org/\">https://www.kernel.org/</a>。</p>\n<p>本次实验我们使用的内核版本为长期支持版本<code>5.10.83</code>，下载链接如下：<a href=\"https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz\">https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz</a>。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image-20211214002141124.png\" alt=\"kernel.org\"  />\n\n<p>（2）本次实验采用的是<code>VMware® Workstation 16 Pro</code>虚拟机，虚拟机系统为<code>Ubuntu 20.04 LTS</code>。打开虚拟机的Ubuntu20.04系统，实验过程将全程在此系统上完成。</p>\n<p>（3）打开终端，切换至root用户（以下操作都在root下完成），切换至根目录，创建实验项目文件夹，并将内核源码下载并解压到该目录下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su </span><br><span class=\"line\"><span class=\"built_in\">cd</span> /</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> mini-linux</span><br><span class=\"line\"><span class=\"built_in\">cd</span> mini-linux</span><br><span class=\"line\">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.83.tar.xz</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image2.png\" alt=\"创建mini-linux目录\" style=\"zoom:67%;\" />\n\n<p>（4）解压下载好的内核源码，并进入到linux-5.10.83目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -vxf linux-5.10.83.tar.xz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> linux-5.10.83</span><br></pre></td></tr></table></figure>\n\n<p>如果不是第一次编译，请运行以下命令清理：</p>\n<ul>\n<li>makeclean: 删除编译中间文件，但是保留配置。</li>\n<li>make mrproper：删除包括配置文件的所有构建文件。</li>\n<li>make distclean：执行mrproper所做的一切，并删除备份文件。</li>\n</ul>\n<h2 id=\"配置内核\"><a href=\"#配置内核\" class=\"headerlink\" title=\"配置内核\"></a>配置内核</h2><p>（1）指定硬件体系架构为<code>x86</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> ARCH=x86  </span><br></pre></td></tr></table></figure>\n\n<p>（2）生成config文件。</p>\n<p>Linux自带很多内核的配置文件，如：</p>\n<ul>\n<li><p>make defconfig：生成默认的内核配置。</p>\n</li>\n<li><p>make allmodconfig：所有的可选的选项构建成模块。</p>\n</li>\n<li><p>make allyesconfig：生成全部选择是的内核配置。</p>\n</li>\n<li><p>make noconfig：生成全部选择否的内核配置。</p>\n</li>\n</ul>\n<p>（3）本次实验我们根据虚拟机系统，选择 x86_64_defconfig 。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make x86_64_defconfig</span><br></pre></td></tr></table></figure>\n\n<p>此操作会将<code>./arch/x86/configs/x86_64_defconfig</code>文件复制为<code>./.config</code>，作为我们编译内核的初始配置文件。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image3.png\" alt=\"生成config文件\" style=\"zoom:67%;\" />\n\n<p>（4）使用图形化界面配置内核。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make meunconfig</span><br></pre></td></tr></table></figure>\n\n<p>此时会进入Kernel Configuration图形化配置界面</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image4.png\" alt=\"Kernel Configuration图形化配置界面\" style=\"zoom:67%;\" />\n\n<p>（5）我们用键盘操作此图形界面：</p>\n<ul>\n<li><p>[*]代表被选中，[ ]表示未被选中。</p>\n</li>\n<li><p>↑ ↓ 方向键可以快速在配置项中选择。</p>\n</li>\n</ul>\n<ul>\n<li>← → 方向键可以在select、exit等菜单项之间选择。    </li>\n</ul>\n<ul>\n<li>Y 选择此项，并包含进内核中。</li>\n</ul>\n<ul>\n<li>N 取消选择此项，不包含内核中。</li>\n</ul>\n<ul>\n<li>M 编译成模块。</li>\n</ul>\n<ul>\n<li>Enter 进入或确认选项。</li>\n</ul>\n<ul>\n<li><strong>H 配置说明</strong>。</li>\n</ul>\n<p>​    <em>在任何一个选项下按H，可以看到详细的配置说明，自己不确定的项可以用此方法来辅助判断，如下图，如果有<code>If unsure say Y</code>、<code>you&#39;ll need to say Y here</code>、<code>If in doubt, say &quot;Y&quot;</code>则建议必选，如果有<code>If unsure say N here</code>，则可以根据情况不选。</em></p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image5.png\" alt=\"配置小技巧\" style=\"zoom: 67%;\" />\n\n<ul>\n<li><strong>/ 搜索</strong>。</li>\n</ul>\n<p>​    <em>在任意界面输入<code>/</code>，则会进入搜索，可以根据需求搜索配置项。</em></p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image6.png\" alt=\"搜索界面\" style=\"zoom: 67%;\" />\n\n<p>返回搜索结果后，再输入搜索结果对应的数字，则会跳转至对应的配置项，可以大大提高效率。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image7.png\" alt=\"搜索结果\" style=\"zoom:67%;\" />\n\n<p>Kernel配置介绍、裁剪经验，可以参考以下文档</p>\n<p>​    [1]. <a href=\"https://blog.csdn.net/liao20081228/article/details/81389813\">Linux内核（4.17.10）配置项详解（x86）</a></p>\n<p>​    [2]. <a href=\"https://blog.csdn.net/weixin_43892506/article/details/117885040\">kernel裁剪</a></p>\n<p>​    [3]. <a href=\"https://blog.csdn.net/u011124985/article/details/80453772\">linux内核裁剪的具体过程和方法</a></p>\n<h2 id=\"内核裁剪\"><a href=\"#内核裁剪\" class=\"headerlink\" title=\"内核裁剪\"></a>内核裁剪</h2><p>通过内核裁剪，我们可以</p>\n<ul>\n<li><p>学习内核裁剪的方法和流程。</p>\n</li>\n<li><p>在资源内有限的时候，裁剪内核可以使系统变得简洁和轻量化。</p>\n</li>\n<li><p>不必要的驱动，不仅使得内核占用空间，运行速度慢，还会引起不必要的问题。</p>\n</li>\n</ul>\n<p>内核裁剪在<code>menuconfig</code>界面进行，我们使用的<code>x86_64_defconfig</code>已经做了大量裁剪，编译后内核大小仅有9.5M，精细裁剪需要花费大量时间，这里仅演示几项，大家可以多多尝试。</p>\n<p>（1）给内核版本号添加自定义后缀：</p>\n<ul>\n<li>在<code>General setup</code>选项下，选择<code>Local version - append to kernel release</code>，我们可以给内核版本号添加自定义后缀，如<code>-mini-linux-2021</code>。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image8.png\" alt=\"内核版本号添加自定义后缀\" style=\"zoom: 67%;\" />\n\n<p>（2）我们需要内核支持RAM disk：</p>\n<ul>\n<li>在<code>General setup</code>选项下，选择<code>Initial RAM filesystem and RAM disk (initramfs/initrd) support</code>。</li>\n<li>在<code>Device Drivers</code>选项下，勾选<code>Block devices</code>，并进入<code>Block devices</code>，勾选<code>RAM block device support</code>，并将其第二项<code>Default RAM disk size (kbytes) (NEW)</code>设置为<code>65536</code>。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image9.png\" alt=\"RAM disk support\" style=\"zoom: 67%;\" />\n\n<p>（3）取消多核心调度增强：</p>\n<ul>\n<li>在<code>Processor type and features</code>选项下，取消勾选多核心调度增强<code>Multi-core scheduler support</code>。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image10.png\" alt=\"取消多核心调度增强\" style=\"zoom: 67%;\" />\n\n<p>（4）取消调试内核：</p>\n<ul>\n<li>在<code>General architecture-dependent options</code>选项下，取消勾选调试内核<code>Kprobes</code>选项。</li>\n</ul>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image11.png\" alt=\"取消调试内核\" style=\"zoom: 67%;\" />\n\n<p>（5）取消允许强制卸载正在使用中的模块：</p>\n<ul>\n<li>在<code>Enable loadable module support</code>选项下，取消勾选允许强制卸载正在使用中的模块<code>Forced module unloading</code>。</li>\n</ul>\n<p>（6）取消勾选磁盘配额：</p>\n<ul>\n<li>在<code>File systems</code>选项下，取消勾选磁盘配额<code>Quota support</code>。</li>\n</ul>\n<p>在所有需要的选项配置完毕之后，按Exit退出，选择Yes保存。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image12.png\" alt=\"保存并退出内核配置\" style=\"zoom: 67%;\" />\n\n<h2 id=\"编译内核\"><a href=\"#编译内核\" class=\"headerlink\" title=\"编译内核\"></a>编译内核</h2><p>（1）下面就可以开始编译内核了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -j8</span><br></pre></td></tr></table></figure>\n\n<p>make命令后面跟着线程数，8表示使用8线程去执行，不要超过虚拟机系统配置的核心数。</p>\n<p>我的机子16G内存，8线程编译，大概10分钟，编译就完成了，编译成功后的内核位于：<code>arch/x86_64/boot/bzImage</code>。</p>\n<p>（2）把编译好的内核文件拷贝到mini-linux目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> <span class=\"built_in\">arch</span>/x86_64/boot/bzImage ../</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -alh</span><br></pre></td></tr></table></figure>\n\n<p>用<code>ls</code>命令，可以看到它的大小只有9.2M。</p>\n<img src=\"https://qiniu.findn.cn//blog/photos/article/image13.png\" alt=\"查看编译好的内核\" style=\"zoom: 67%;\" />\n\n<p>Linux 内核裁剪及编译教程就到这里，下一部分是用busybox制作一个最小的根文件系统，敬请关注！</p>"},{"title":"图像和视频篡改检测Manipulation Detection综述","article_type":1,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":true,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"mathjax":false,"abbrlink":"6473c150","date":"2021-10-27T16:00:00.000Z","top":null,"_content":"- 数字图像篡改操作取证(Tamper )\n\t- Copy-move操作取证技术\n\t- Inpainting操作取证技术\n\t- Splicing操作取证技术\n- 数字图像处理操作取证(Manipulation)\n\t- JPEG重压缩取证技术\n\t- 增强操作取证技术\n\t- 几何操作取证技术\n\t- 操作链取证技术\n- 视频编辑篡改检测\n\t- 数字视频再编辑篡改技术\n\t- 数字视频被动取证检测技术\n\n<!-- more -->\n\n## 数字图像篡改操作取证(**Tamper** )\n\n### Copy-move操作取证技术\n\n图像复制粘贴篡改（copy-move）是数字图像篡改中比较常用的一种手段。它把单个图像中的部分区域复制并粘贴到同一图像中不交叠的其它区域，从而增加或覆盖掉某些物体。为了使篡改后的图像能够以假乱真，在复制过程中，复制区域可能会经历旋转、缩放等几何变换，并且合成图像可能经历加噪、模糊、压缩等后期处理，这进一步加大了篡改检测的难度。现有的图像复制篡改检测方法可以粗略的分为**基于图像块的方法**、**基于关键点的方法**和**基于深度学习的方法**。\n\n#### 基于图像块的方法\n\nFridrich等人[1]首次定义了复制粘贴篡改，并提出了**基于块匹配**的检测方法，将图像分割成固定大小且相互重叠的子块，并使用DCT量化系数作为图像块的特征描述。该算法对图像块的所有DCT系数都进行统计计算，所以算法的复杂度很高。\n\n后来，多位学者分别**提出了DWT变换、FWT变换等用于描述图像块的特征**。Bashar等人[2]提出了两个鲁棒的特征，分别基于DWT变换和KPCA，并将这些特征向量构成一个矩阵。Cozzolino等人[3]提出了CHT作为图像的特征。该方法将图像中的每一个像素点都进行处理，提取到每一个像素点的特征。为了减少计算量，使用了快速的近似最近邻搜索算法对密集区域处进行高效的计算。\n\n除了频率域的特征提取，**基于空间域**的特征提取也有很多经典的算法，其中将矩阵特征作为图像的特征进行处理就是经常使用的方法。Mahdian和Saic[4]较早提出了一种**基于模糊矩阵**的方法，并使用了主成分分析减少特征的维数，最后利用k-d树对多维的数据块进行相似性分析，从而对篡改区域进行定位。Ryu等人[5]则将**Zernike矩阵**作为图像块的特征，并在**图像块匹配时使用了局部敏感哈希算法**加速匹配过程，最终根据匹配块寻找篡改区域。\n\n除了使用矩阵特征以外，也有研究者利用图像本身的一些**纹理亮度信息作为图像的特征**。Davarzani等人[6]采用多分辨率局部二值模式（MLBP）作为图像块的特征信息。为了获得精确的匹配信息，还使用了**RANSAC算法**去除掉错误的匹配。\n\n基于图像块的检测算法虽然能达到一定的效果，但是随着图像复制粘贴篡改的多样化，以及实际图像复制篡改过程中经历更多几何变换如旋转、缩放等，基于图像块的检测方法的鲁棒性会降低。此外，基于图像块的方法需要大量的计算，难以在实际中进行应用。为了提高检测效率，增强对抗几何变换的鲁棒性，基于关键点匹配的检测方法成了新的研究热点。\n\n#### 基于关键点的方法\n\n基于关键点的检测方法计算效率高且有较强的鲁棒性，适用于实际情况下的多类型图像复制粘贴篡改检测，因此研究者也致力于用基于关键点的检测方法来解决各种图像复制粘贴篡改检测的问题。\n\n**该类方法首先从整幅图像中提取关键点，然后对其进行特征描述提取和匹配过程，最后通过得到关键点匹配进行后续处理从而定位复制粘贴篡改区域。**\n\nHuang等人[7]**采用SIFT作为图像关键点检测与特征描述**的方法，并使用**Best Bin First算法**来寻找相似的特征向量，进而确定匹配关键点的位置。此后很多学者也提出了基于SIFT特征的检测方法，Pan和Lyu[8]使用了**RANSAC算法**来计算复制粘贴区域之间的仿射变换关系。Amerini等人[9]基于2NN准则提出了**新的匹配方法G2NN**以应对多重复制粘贴的情形。除了SIFT以外，研究者还提出了其它一系列的优秀算法。Xu等人[10]**使用SURF作为提取图像关键点特征的方法**。相比SIFT，SURF运算比较简单，计算效率更高。此外，Yang等人[11]**采用了SIFT和KAZE的融合**作为提取关键点特征的方法。\n\n针对复杂的复制粘贴篡改检测以及定位的精确度的问题，有研究者提出了更为系统的检测框架。Ardizzone等人[12]利用**提取的SIFT特征点来构建Delaunay 划分，然后利用每个三角形块的颜色信息和角度信息作为三角形区域的特征向量进行匹配**。Li等人[13]首先使用 **SLIC算法对图像进行分割成一系列的超像素块**，根据分割块内关键点匹配对的数量处理匹配块，提升了处理的效率。Zandi等人[14]通过自适应迭代的方法，根据每个迭代周期的结果迭代地调整关键点的分布还有匹配过程以及仿射变换矩阵计算。Li等人[15]通过降低关键点提取时的阈值，使得小区域、平滑区域可以提取足量的关键点，并且提出了一种**新的层次匹配策略来解决大量关键点匹配问题**。和基于块匹配的检测方法相比，基于关键点匹配的方法避免了全局搜索，大大提高了检测效率，且对几何变换具有更好的鲁棒性。\n\n#### 基于深度学习的方法\n\n随着深度学习尤其是卷积神经网络的发展，研究者开始尝试使用深度学习的方法进行图像复制粘贴篡改的检测。Wu等人[16]设计了**端到端的BusterNet**，采取双分支结构，对图像操作和图像相似性进行检测，具有一定的效果，可以同时识别源区域和目标区域。Chen等人[17]提出一种**串行分支网络模型**，包含**相似性检测网络CMSDNet和源与目标鉴别网络STRDNet**。STRDNet研究CMSDNet获得的相似块的分类问题，相对于BusterNet的分支更加简单且准确率更高。\n\nBarni等人[18]提出了多分支网络DisTool对图像复制篡改进行检测并识别源区域和目标区域，分别为两个Siamese组成的4-Twins Net分支和一个Siamese分支。该网络在真实的测试场景中也表现良好。Zhong等人[19]提出了**基于Dense-InceptionNet**的检测方案，充分使用了多尺度的信息和稠密特征链接，设计了**金字塔特征提取器，特征相关匹配和层次后处理模块**。**该算法对几何变换操作和JPEG压缩都有一定的鲁棒性**。\n\n### Inpainting操作取证技术\n\n图像修复(inpainting)技术是数字图像篡改中比较常用的一种手段，它的核心思想是根据图像受损区域周围的已知像素信息通过插值相邻像素对未知区域进行修复[20]。目前，传统的图像inpainting算法可以分成两类：**基于块的方法和基于扩散的方法。**\n\n- 基于块的方法主要是通过搜索图像已知区域的图像块，寻找合适的候选块对受损区域进行填补以达到修复的目的；\n\n- 基于扩散的方法通常是通过求解偏微分方程或者依据扩散系统将图像信息从边界传播扩散到未知区域进行修复。\n\n\n当恶意篡改者使用图像inpainting技术进行篡改并将这类图像应用于司法、科学等领域时，将会造成不可预料的严重影响。现有的针对图像inpainting的**检测方法**大致可以分为两类：**基于传统手工特征的方法和基于深度学习的方法。**\n\n#### 基于传统手工特征的方法\n\n最初，Wu等人[21]在2008年提出了一种**基于零连通特征和模糊隶属度**的检测方法。首先对图像中的块进行零连通标记，筛选可疑区域，然后通过计算模糊隶属度识别可疑区域内的修复块，并通过割集实现最终的修复篡改区域的定位。\n\n2013年，Bacchuwar等人[22]提出了一种可以同时检测图像修复和图像复制-粘贴两种篡改的方法。该方法**利用图像的亮度分量，对可疑区域中的块进行中值匹配**，引入“跳跃块”，从而有序检测篡改区域。它相较于文献[21]加速了修复区域的定位，但仍需要人工选择区域。\n\n为减少最佳匹配块的搜索时间，Chang等人[23]通过检测关键值进行相似度检测，提出了一种**基于权值变换的搜索算法**，包括可疑区域检测和篡改区域识别两个阶段。Liang等人[24]首先**采用中心像素映射搜索**可疑块对，在装载因子和搜索范围方面加速了对可疑块的搜索，使用最大零连通性区域标记和片段拼接检测技术实现篡改区域的定位。\n\n申林川等人[25]对已有的图像修复检测方法进行改进，**利用一种hash映射函数将图片三维的颜色信息转换成一维的hash值映射至哈希表**，再结合相似向量滤波和基于质心的篡改区域定位技术，实现篡改区域最终的准确定位。\n\n另外，JPEG是目前网络中使用最广泛的图像格式。Zhao等人[26]针对JPEG图像展开研究，**通过计算和分割不同质量因子下的修复图像和再保存JPEG图像的绝对差值之和检测出被篡改的区域**，不需要任何手动操作。\n\nLiu等人[27]也聚焦于JPEG图像，**提出了一种大规模特征挖掘的经验方法，包含边缘密度和联合密度特征**，采用集成学习，有效地检测了包括图像修复在内的复合攻击下的图像篡改，特别是在重压缩质量低于原始JPEG图像质量的情况下，显著提高了检测精度。\n\nLi等人[28]针对**基于扩散的修复方法进行区域检测，发现修复区域和未修复区域图像沿垂直于梯度方向的拉普拉斯变换是不同的**。基于此，根据通道内和通道间的局部变化方差构造了一个特征集。最后，设计了两个有效的后处理操作来进一步细化定位结果。但该方法鲁棒性较差，特别是对经过JPEG压缩后处理的图像取证性能显著下降。\n\n刘婷婷等人[29]**提出了一种梯度域导向滤波增强的图像扩散修复检测算法**。该算法对输入图像的各个颜色通道分别进行梯度域导向滤波增强，从多角度捕捉图像修复带来的影响，以实现图像扩散修复区域的定位。\n\n基于传统手工特征的图像inpainting检测算法在一些方面存在一定的局限性，比如**需要手动选择区域、只针对特定的图像inpainting技术、鲁棒性较差**等。近年来为提高检测效率，增强算法对抗几何变换的鲁棒性，基于深度学习的图像inpainting检测算法也在不断发展。\n\n#### 基于深度学习的方法\n\n随着深度学习的发展，研究人员开始尝试使用深度学习方法实现图像修复检测。\n\n2018年，Zhu等人[30]提出了一种基于深度神经网络的图像inpainting篡改检测技术，通过神经网络自动提取篡改痕迹，实现图像像素级的预测并对修复区域进行定位。**该框架在编码器-解码器的全卷积网络结构基础上还引入了特征金字塔网络对特征图进行信息补充**，填充图像的语义信息，且具有一定的泛化性。进一步地，Zhu等人[31]提出了新的网络框架，并构建了类标签矩阵，设计了加权交叉熵解决图像像素不平衡的问题。该方法考虑了JPEG压缩和缩放等后处理操作，具有一定的鲁棒性。\n\nWang等人[32]在2019年提出了一种**基于Faster R-CNN网络的图像inpainting篡改检测方法**，并**自制**了在两种深度学习图像修复算法下的**数据集**，实现了修复区域的边界框定位。但该方法只能得到标记有置信度分数的边界框，无法得到修复篡改区域的真实区域，定位精度有待进一步提高。\n\nLu等人[33]提出了一种**基于LSTM-CNN的图像目标去除方法**，利用CNN搜索异常相似块，提高了搜索的速度和准确性，利用LSTM网络消除虚警补丁对检测结果的影响，降低虚警率。\n\nLi等人[34]探究发现在像素域中修复图像块和未修复图像块的转移概率值相似，而在残差域中表现出明显的差异，修复图像块包含较少的高频分量。因此，作者**设计了HP-FCN网络，利用高通滤波模块对输入图像进行预处理，将其残差图输送到基于CNN的特征提取模块中，再通过上采样模块采样到输入图像大小，最终得到像素预测的定位图。**该算法对深度学习下的修复数据集进行定位检测，且进一步考虑了随机修复和现实情况下的真实数据集，在准确率上都取得了较好的效果，具有一定的鲁棒性。\n\n为了提高已有算法对不可见图像修复方法的检测性能，Wu等人[35]提出了一种新型的**端到端图像修复检测网络IID-Net，其中NAS算法用于设计适当的网络架构，并结合新提出的注意模块来进一步优化潜在特征。**该算法在特定深度修复方法上训练的取证模型对其他修复方法具有良好的通用性检测能力。作者还基于10种不同的修复方法构建了一个**包含10K张图片的不同修复测试数据集**，每种修复方法提供1000张图片，作为一个公共可访问的数据集，用于修复检测方法的标准化比较。\n\n### Splicing操作取证技术\n\n**图像拼接(splicing)**伪造不同于复制-粘贴伪造，它是将一个或多个源图像的区域复制粘贴到目标图像上得到篡改图像。图像拼接伪造检测与定位可以看作是一个全局二值分类问题，通过比较不同图像区域之间的特征来检测定位篡改区域。现有的图像拼接伪造检测方法大致可以归纳为四类：**基于模糊类型不一致性的方法**，**基于噪声水平不一致性的方法**，**基于光照不一致性的方法**和**基于深度学习的方法**。\n\n#### 基于模糊类型不一致性的方法\n\n2011年，Kakar等人[36]提出了一种**利用运动模糊差异性检测图像拼接**的新方法。通过对图像梯度的运动模糊水平的估计，检测拼接区域和原始区域之间的不一致性。作者还开发了一种新的方法，可以较好地对包含运动模糊的图像进行不一致性区域分割。\n\n为了适应不同范围的模糊程度，Bahrami等人[37] 提出了一种基于**图像模糊度和深度信息不一致性的图像拼接检测框架**。首先估计图像块的模糊核，再利用分步模糊技术测量局部模糊核的相对模糊度。基于此，对不同模糊程度的图像块进行分类。\n\nRao等人[38]考虑手持摄像机中运动模糊现象这一特定场景，提出了一种**以模糊为线索的被动图像拼接检测方法**。离焦模糊也是图像拼接检测中的一种常用特征，然而纹理、光场、噪声等都会在一定范围内影响自然边缘的离焦模糊信息，导致边缘离焦模糊估计不一致。\n\nSong等人[39]分析了图像拼接边缘和自然边缘的离焦模糊特征的差异性，提出了**一种新的基于离焦模糊差的自然图像拼接检测方法**。当伪造者使用一些后处理操作来掩盖拼接痕迹时，图像拼接问题是一个具有挑战性的问题。\n\n为进一步解决这个问题，Bahrami等人[40]在2015年提出了一种**基于局部模糊类型不一致性的模糊图像拼接定位框架**。作者首先对图像进行分块，根据局部模糊核提取局部模糊类型检测特征用于离焦模糊和运动模糊的划分，从而生成模糊类型不变区域。最后，采用精细拼接定位方法提高区域边界的精度。\n\n#### 基于噪声水平不一致性的方法\n\n大多数图像在采集或后续处理过程中都会引入一定的噪声，而自然图像和具有不同来源的拼接图像中的噪声会存在不同程度的差异性。研究人员根据噪声的不一致性提出了相应的图像拼接检测算法。\n\nMahdian等人[41]将待测图像分割成不同噪声水平的分区，**利用基于中值的方法计算每个图像块的噪声标准差**，通过一个阈值确定图像拼接篡改区域。\n\nLyu等人[42]利用了自然图像在带通域内峰度的特殊规律以及噪声特征与峰度之间的关系。**将噪声统计量的估计表述为一个具有封闭解的优化问题**，并进一步推广到一种有效的局部噪声统计量估计方法。通过揭示局部噪声水平的不一致性来检测拼接区域。\n\n研究人员发现可以通过主成分分析(PCA)来估计图像的噪声水平。其中，2015年，Zhan等人[43]在主成分分析的基础上，根据不同的局部噪声方差，**对待测图进行均匀噪声的区域分割**，实现篡改区域的定位。Zeng等人[44]发现当拼接区域与原始区域噪声差较小时，一些基于噪声的图像拼接定位算法性能不佳。作者采用基于主成分分析的算法对图像进行分块噪声水平估计，**通过k-means聚类从原始区域分割出篡改区域**。Yao等人[45]通过探讨噪声水平函数(NLF)与相机相应函数(CRF)之间的关系，拟合了CRF约束下的NLF曲线，**建立了一个贝叶斯最大后验(MAP)框架来优化NLF估计**，并开发了一种基于不同来源图像块噪声水平不一致性的图像拼接检测方法。Liu等人[46]针对多目标拼接伪造场景，**利用噪声水平函数(NLF)估计图像噪声与像素强度之间的关系，从而检测可疑篡改区域**。2018年，Nan等人[47]提出一种新的噪声水平函数的图像拼接检测方法。作者首先将图像分成不重叠的块，将每个块的噪声方差拟合到锐利度下，**通过计算图像块到拟合曲线的最小距离区分篡改区域**。\n\n#### 基于光照不一致性的方法\n\n一般来说，使用不同设备拍摄的图像会存在光照不一致性。基于此特性，Liu等人[48]在2011年提出了一种基于阴影亮度不一致性的图像拼接篡改检测框架。**该框架首先提取图像中的阴影边界和半阴影区域**，估计阴影的遮罩值来衡量其颜色特征。但当合成阴影和实际目标阴影一致时，该算法失效。Ke等人[49]对此提出改进，提出了基于阴影一致性的篡改图像检测方法。通过提取阴影区域和非阴影区域的纹理特征，**利用相关函数来度量两种纹理特征的相似性。通过比较相似度，实现图像拼接篡改的检测。**\n\n#### 基于深度学习的方法\n\n- Xiao等人[50]提出了一种由粗到精的两阶段检测网络(**C2RNet**)和稀释自适应聚类两部分组成的拼接伪造检测方法，从不同尺度的图像块中学习图像属性的差异。\n- Bappy等人[51]提出了一种**利用空间域的编码器-解码器结构网络和频域的长短期记忆(LSTM)网络的双域检测方法**。该网络利用更大的接受域和频域相关性，通过结合编码器和LSTM网络来分析篡改区域和非篡改区域之间的区别特征。最后使用解码器实现像素级预测图像篡改定位。\n- 进一步地，Wu等人[52]将伪造定位问题定义为局部异常检测问题，**设计了Z-score特征来捕获局部异常，并提出了一种新的检测网络结构(Mantra-net)来评估局部异常**。\n- Bi等人[53]采用图像分割的思想，设计了一种用于图像拼接伪造检测的环形残差U-Net (RRU-Net)，**利用残差传播和残差反馈使得未篡改区域和篡改区域**之间的图像属性差异更加明显。\n- Zhou等人[54]针对目前常见的几类局部篡改操作，**结合传统特征提出了一个双流Faster R-CNN网络**。不仅实现了篡改操作类型识别，更进一步地能够定位到篡改区域，在图像拼接伪造检测方面也具有比较好的性能。\n\n目前，图像拼接伪造检测和定位问题出现了一种新的定义：给定一幅探针图像Q和一幅潜在的供体图像P。检测供体图像的区域是否已拼接到探针图像中，如果已拼接到探针图像，则提供两个掩码，指示拼接到探针中的供体图像区域和从供体图像中拼接的图像区域。这一新问题将图像拼接检测约束为一对图像，相关研究人员将其称为约束图像拼接检测问题。针对这一问题，Wu等人[55]提出了一种开拓性的CISDL方法，设计了一种新的深度卷积神经网络结构—**深度匹配与验证网络(DMVN)**。Ye等人[56]在继承DMVN深度密集匹配层的基础上，提出了**特征金字塔深度匹配与定位方法网络(FPLN)**。Liu等人[57]提出了**一种面向CISDL新的对抗性学习框架的深度匹配网络(DMAC)**，用于生成两个高质量候选掩模，基于检测网络纠正候选掩模之间的不一致，并**基于判别网络生成与真实篡改区域接近的掩模，检测网络与判别网络以对抗学习方式协同监督DMAC**训练。\n\n### **小结与思考**\n\n目前，除了上述图像篡改操作的取证，removal、seam carving等篡改操作的取证研究也吸引了国内外学者的广泛关注，并取得了一些阶段性成果。尤其是近年来，以卷积神经网络为代表的深度学习技术在图像篡改操作取证领域取得了突出的性能，但仍存在一些问题有待进一步研究。\n\n（1）篡改者在使用copy-move，inpainting或者splicing操作对图像语义进行恶意篡改后，通常会使用一些后处理操作或者反取证技术掩盖操作的篡改痕迹，如何设计对不同后处理操作和反取证技术鲁棒的篡改操作取证模型是值得进一步探索的方向。\n\n（2）针对inpainting操作检测问题，大多数取证方法都基于修复区域与未修复区域的块匹配原理，检测效率较低。如何在保证定位准确率的前提下，加快区域匹配速率是一个待解决的问题。\n\n### 参考文献\n\n[1]J. Fridrich, D. Soukal, and J. Lukas. Detection of copy-move forgery in digital images. Proceedings of Digital Forensic Research Workshop (DFRWS), Cleveland, OH, USA, 2003.\n\n[2]M. Bashar, K. Noda, N. Ohnishi, and K. Mori. Exploring duplicated regions in natural images. IEEE Transactions on Image Processing, DOI: 10.1109/TIP.2010.2046599, 2010.\n\n[3]D. Cozzolino, G. Poggi, and L. Verdoliva. Efficient dense¬field copy–move forgery detection. IEEE Transactions on Information Forensics and Security, vol. 10, no. 11, pp. 2284-2297, 2015.\n\n[4]B. Mahdian, and S. Saic. Detection of copy–move forgery using a method based on blur moment in-variants,.Forensic Science International, vol. 171, no. 2, pp. 180-189, 2017.\n\n[5]S. -J. Ryu, M. Kirchner, M. -J. Lee, and H. K. Lee. Rotation invariant localization of duplicated image regions based on zernike moments. IEEE Transactions on Information Forensics and Security, vol. 8, no. 8, pp. 1355-1370, 2013.\n\n[6]R. Davarzani, K. Yaghmaie, S. Mozaffari, and M.Tapak. Copy¬-move forgery detection using multiresolution local binary patterns. Forensic Science International, vol. 231, no. 1, pp. 61-72, 2013.\n\n[7]H. Huang, W. Guo, and Y. Zhang. Detection of copy-move forgery in digital images using sift algorithm. IEEE Pacific-Asia Workshop on Computational Intelligence and Industrial Application (PACIIA), Wuhan, China, pp. 272–276, 2008.\n\n[8]X. Pan, and S. Lyu. Region duplication detection using image feature matching. IEEE Transactions on Information Forensics and Security, vol. 5, no. 4, pp. 857-867, 2010.\n\n[9]I. Amerini, L. Ballan, R. Caldelli, A.D. Bimbo, and G. Serra. A sift-based forensic method for copy-move attack detection and transformation recovery. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1099-1110, 2011.\n\n[10]B. Xu, J. Wang, G. Liu, H. Li, and Y. Dai. Image copy-move forgery detection based on surf. International Conference on Multimedia Information Networking and Security (MINES), Nanjing, China, pp. 889-892, 2010.\n\n[11]F. Yang, J. Li, W. Lu, and J. Weng. Copy¬-move forgery detection based on hybrid features. Engineering Applications of Artificial Intelligence, vol. 59, pp. 73-83, 2017.\n\n[12]E. Ardizzone, A. Bruno, and G. Mazzola. Copy move forgery detection by matching triangles of keypoints. IEEE Transactions on Information Forensics and Security, vol. 10, no. 10, pp. 2084-2094, 2015.\n\n[13]J. Li, X. Li, B. Yang, and X. Sun. Segmentation¬ based image copy¬-move forgery detection scheme. IEEE Transactions on Information Forensics and Security, vol. 10, no. 3, pp. 507-518, 2015.\n\n[14]M. Zandi, A. M.-Aznaveh and A. Talebpour. Iterative copy-¬move forgery detection based on a new interest point detector. IEEE Transactions on Information Forensics and Security, vol. 11, no. 11, pp. 2499-2512, 2016.\n\n[15]Y. Li, and J. Zhou. Fast and effective image copy¬-move forgery detection via hierarchical feature point matching. IEEE Transactions on Information Forensics and Security, vol. 14, no. 5, pp. 1307-1322, 2019.\n\n[16]Y. Wu, W. A.-Almageed, and P. Natarajan. BusterNet: Detecting copy-move image forgery with source/target localization. Proceedings of the European Conference on Computer Vision (ECCV), Munich, Germany, pp.170-186, 2018.\n\n[17]B. Chen, W. Tan, G. Coatrieux, Y. Zheng, and Y. Q. Shi. A serial image copy-move forgery localization scheme with source/target distinguishment. IEEE Transactions on Multimedia, DOI: 10.1109/TMM.2020.3026868, 2020.\n\n[18]M. Barni, Q. -T. Phan, and B. Tondi. Copy move source-target disambiguation through multi-branch CNNs. IEEE Transactions on Information Forensics and Security, vol. 16, pp. 1825-1840, 2021.\n\n[19]J. Zhong, and C. Pun. An end-to-end Dense-InceptionNet for image copy-move forgery detection. IEEE Transactions on Information Forensics and Security, vol. 15, pp. 2134-2146, 2020.\n\n[20]A. Criminisi, P. Perez, and K. Toyama. Region filling and object removal by exemplar-based image inpainting. IEEE Transactions on Image Processing, vol. 13, no. 9, pp. 1200-1212, 2004.\n\n[21]Q. Wu, S. Sun, W. Zhu, G. Li, and D. Tu. Detection of digital doctoring in exemplar-based inpainted images. International Conference on Machine Learning and Cybernetics (ICMLC), Kunming, China, pp. 1222–1226, 2008.\n\n[22]K. S. Bacchuwar, Aakashdeep, and K. R. Ramakrishnan. A jump patch-block match algorithm for multiple forgery detection. International Mutli-Conference on Automation, Computing, Communication, Control and Compressed Sensing (iMac4s), Kottayam, India, pp. 723-728, 2013.\n\n[23]I. Chang, J. Yu, and C. Chang. A forgery detection algorithm for exemplar-based inpainting images using multi-region relation. Image and vision computing, vol. 31, no. 1, pp. 57-71, 2013.\n\n[24]Z. Liang, G. Yang, X. Ding, and L. Li. An efficient forgery detection algorithm for object removal by exemplar-based image inpainting. Journal of Visual Communication and Image Representation, vol. 30, pp. 75-85, 2015.\n\n[25]L. Shen, G. Yang, L. Li, X. Sun. Robust detection for object removal by exemplar-based image inpainting with post-processing. International Conference on Natural Computation, Fuzzy Systems and Knowledge Discovery (FSKD), Guilin, China, pp. 2730-2736, 2017.\n\n[26]Y. Zhao, M. Liao, F. Y. Shih, and Y. Q. Shic. Tampered region detection of inpainting JPEG images. Optik, vol. 124, no. 16, pp. 2487-2492, 2013.\n\n[27]Q. Liu, A. H. Sung, B. Zhou, and M. Qiao. Exposing inpainting forgery in JPEG images under recompression attacks. IEEE International Conference on Machine Learning and Applications (ICMLA), Anaheim, CA, USA, pp. 164-169, 2016.\n\n[28]H. Li, W. Luo, and J. Huang. Localization of diffusion-based inpainting in digital images. IEEE transactions on information forensics and security, vol. 12, no. 12, pp. 3050-3064, 2017.\n\n[29]刘婷婷, 张玉金, 吴飞等. 基于梯度域导向滤波增强的图像扩散修复取证[J]. 激光与光电子学进展, 2020, vol. 57, no. 8, pp. 35-42.\n\n[30]朱新山, 钱永军, 孙彪等. 基于深度神经网络的图像修复取证算法[J]. 光学学报, 2018, vol. 38, no. 11, pp. 97-105.\n\n[31]X. Zhu, Y. Qian, X. Zhao, B. Sun, and Y. Sun. A deep learning approach to patch-based image inpainting forensics. Signal Processing: Image Communication, vol. 67, pp. 90–99, 2018.\n\n[32]X. Wang, H. Wang, and S. Niu. An image forensic method for AI inpainting using faster R-CNN. International Conference on Artificial Intelligence and Security (ICAIS), New York, USA, pp. 476-487, 2019.\n\n[33]M. Lu, and S. Niu. A detection approach using LSTM-CNN for object removal caused by exemplar-based image inpainting. Electronics, vol. 9, pp. 858, 2020.\n\n[34]H. Li, and J. Huang. Localization of deep inpainting using high-pass fully convolutional network. IEEE International Conference on Computer Vision (ICCV), Seoul, South Korea, pp. 8301-8310, 2019.\n\n[35]H. Wu, and J. Zhou. IID-Net: image inpainting detection network via neural architecture search and attention. IEEE Transactions on Circuits and Systems for Video Technology, DOI: 10.1109/TCSVT.2021.3075039, 2021.\n\n[36]P. Kakar, N. Sudha, and W. Ser. Exposing digital image forgeries by detecting discrepancies in motion blur. IEEE Transactions on Multimedia, vol. 13, no. 3, pp. 443-452, 2011.\n\n[37]K. Bahrami, A. C. Kot, and J. Fan. Splicing detection in out-of-focus blurred images. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 144-149, 2013.\n\n[38]M. P. Rao, A. N. Rajagopalan, and G. Seetharaman. Harnessing motion blur to unveil splicing. IEEE Transactions on Information Forensics and Security, vol. 9, no. 4, pp. 583-595, 2014.\n\n[39]C. Song, and X. Lin. Natural image splicing detection based on defocus blur at edges. IEEE/CIC International Conference on Communications in China (ICCC), Shanghai, China, pp. 225-230, 2014.\n\n[40]K. Bahrami, A. C. Kot, L. Li, and H. Li. Blurred image splicing localization by exposing blur type inconsistency. IEEE Transactions on Information Forensics and Security, vol. 10, no. 5, pp. 999-1009, 2015.\n\n[41]B. Mahdian, and S. Saic. Using noise inconsistencies for blind image forensics. Image and Vision Computing, vol. 27, no. 10, pp. 1497-1503, 2009.\n\n[42]S. Lyu, X. Pan, and X. Zhang. Exposing region splicing forgeries with blind local noise estimation. International Journal of Computer Vision, vol. 110, no. 2, pp. 202–221, 2014.\n\n[43]L. Zhan, and Y. Zhu. Passive forensics for image splicing based on PCA noise estimation. International Conference for Internet Technology and Secured Transactions (ICITST), London, UK, pp. 78-83, 2015.\n\n[44]H. Zeng, Y. Zhan, X. Kang, and X. Lin. Image splicing localization using PCA-based noise level estimation. Multimedia Tools and Applications, vol. 76, no. 4, pp. 4783–4799, 2017.\n\n[45]H. Yao, S. Wang, X. Zhang, C. Qin, and J. Wang. Detecting image splicing based on noise level inconsistency. Multimedia Tools and Applications, vol. 76, no. 10, pp. 12457–12479, 2017.\n\n[46]B. Liu, and C. Pun. Multi-object splicing forgery detection using noise level difference. IEEE Conference on Dependable and Secure Computing (DSC), Taipei, Taiwan, pp. 533-534, 2017.\n\n[47]Z. Nan, and L. Zhao. Blind image splicing detection via noise level function. Signal Processing: Image Communication, vol. 69, pp. 181-192, 2018.\n\n[48]Q. Liu, X. Cao, C. Deng, and X. Guo. Identifying image composites through shadow matte consistency. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1111-1122, 2011.\n\n[49]Y. Ke, F. Qin, W. Min, and G. Zhang. Exposing image forgery by detecting consistency of shadow. The scientific world journal, vol. 2014, no. 3, pp. 1-9, 2014.\n\n[50]B. Xiao, Y. Wei, X. Bi, W. Li, and J. Ma. Image splicing forgery detection combining coarse to refined convolutional neural network and adaptive clustering. Information Sciences, vol. 511, pp. 172–191, 2020.\n\n[51]J. H. Bappy, C. Simons, L. Nataraj, B. S. Manjunath, and A. K. Roy-Chowdhury. Hybrid LSTM and encoder-decoder architecture for detection of image forgeries. IEEE Transactions on Image Processing, vol. 28, no. 7, pp. 3286-3300, 2019.\n\n[52]Y. Wu, W. AbdAlmageed, and P. Natarajan. ManTra-Net: manipulation tracing network for detection and localization of image forgeries with anomalous features. IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), Long Beach, CA, USA, pp. 9535-9544, 2019.\n\n[53]X. Bi, Y. Wei, B. Xiao, and W. Li. RRU-Net: the ringed residual U-Net for image splicing forgery detection. IEEE/CVF Conference on Computer Vision and Pattern Recognition Workshops (CVPRW), Long Beach, CA, USA, pp. 30-39, 2019.\n\n[54]P. Zhou, X. Han, V. I. Morariu, and L. S. Davis. Learning rich features for image manipulation detection. IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), Salt Lake, USA pp. 1053-1061, 2018.\n\n[55]Y. Wu, W. Abd-Almageed, and P. Natarajan. Deep matching and validation network: An end-to-end solution to constrained image splicing localization and detection. ACM international conference on Multimedia (MM), Mountain View, CA, USA, pp. 1480–1502, 2017.\n\n[56]K. Ye, J. Dong, W. Wang, B. Peng, and T. Tan. Feature pyramid deep matching and localization network for image forensics. Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC), Honolulu, Hawaii, USA, pp. 1796–1802, 2018.\n\n[57]Y. Liu, X. Zhu, X. Zhao, and Y. Cao. Adversarial learning for constrained image splicing detection and localization based on atrous convolution. IEEE Transactions on Information Forensics and Security, vol. 14, no. 10, pp. 2551-2566, 2019.\n\n## 数字图像处理操作取证(Manipulation)\n\n### JPEG重压缩取证技术\n\n篡改图像必然会经过重压缩这一步骤，因此数字图像重压缩检测能够为数字图像取证提供强有力的辅助依据。目前，使用最广泛的图像压缩标准是JPEG，若原始的图像是JPEG格式，篡改后的图像为达到不易于检测的效果，同样会保存为JPEG格式，则图像会进行两次JPEG压缩。现如今JPEG重压缩取证包含两个主要研究课题，一是**JPEG重压缩检测**，二是**对JPEG重压缩区域进行定位**。\n\n#### JPEG重压缩检测\n\nJPEG压缩属于有损压缩，每次压缩都会丢失一部分信息，由于JPEG重压缩对图像数据进行了两次量化操作，引入了一些单次JPEG压缩所没有的特征，因此通过一定的统计检测可以发现图像是否经历过JPEG重压缩。\n\n现今的重压缩检测算法大多遵循一个检测模式，第一步是从图像中**找到能最大化单次压缩和双重压缩类间差异的特征**；第二步则是在得到特征后，基于数据驱动训练分类器，**用于识别和分类双重压缩和单次压缩**。\n\n- 比如，Shang等人[1]**以DCT系数**矩阵水平、垂直、对角、反对角方向差分的高阶马尔科夫转移概率作为特征，用SVM和EC分类器分类实现JPEG重压缩图像检测。\n- Zeng等人[2]提出了一种改进的密集连接的**卷积网络（DenseNet）**来完成双压缩图像中主JPEG压缩的检测任务。他们在网络的前端加入了一个特殊的滤波层，该层通常包含选定的滤波和，可以帮助后续网络更容易地识别图像。\n- Wang等人[3]提出了**一种基于四元数离散余弦变换（QDCT）域的改进马尔可夫压缩检测算法**。首先，对给定JPEG图像的颜色信息提取图像构造四元数；然后，构造图像块QDCT系数矩阵，包括振幅和三个角；接着，在相应的细化过程中，由转移概率矩阵生成细化的马尔可夫特征；最后，使用支持向量机（SVM）方法进行NA-DJPEG压缩检测。然而这些统计模型大多关注变换域系数本身，忽略了JPEG压缩给变换域系数引入的相关性，使得当后压缩质量因子远小于前压缩质量因子时，难以判定双重压缩的存在性。\n\n此外，**为了更进一步获取重压缩痕迹，首次压缩时的量化步长估计**是非常关键的问题。\n\n- Galvan等人[4]首先使用直方图滤波除去二次量化以外操作引入的直方图噪声，然后使用一个新的估计方程来估计第一次量化使用的量化步长。该方法在实际应用中可以更准确估计量化步长。然而当后压缩质量因子较小时，大量图像数据会被破坏乃至丢弃，使得这类方法检测效果不佳。\n- 此外，Thai等人[5]**将量化效应和DCT系数统计相结合**，对先前压缩并存储为无损的图像进行量化步长的估计。\n\n#### JPEG重压缩定位\n\n一些研究将JPEG重压缩检测和篡改区域定位相结合。\n\n- Yang等人[6]先提取相同频率的量化DCT系数，建立新的数据矩阵，然后考虑方向对DCT域相邻位置相关性的影响，执行12种不同方向的高通滤波模板，计算每个滤波数据的平移概率矩阵。然后利用PCA和SVM分别对特征维数进行降维和分类器训练，以此确定图像是否被篡改。\n- Wang等人[7]利用Laplacian分布来描述在拼接区域和原图像的DCT系数分布，通过估计DCT块的后验概率来确定被篡改区域。\n- Amerini等人[8]使用卷积神经网络（CNN）实现了JPEG重压缩的篡改定位。\n- Zhou等人[9]使用一种双通道的快速R-CNN网络，并对其进行端到端的训练，对图像进行篡改检测。双通道之一是**RGB流**，其目的是从RGB图像输入中提取特征，以发现篡改特征，如强烈的对比度差、非自然的篡改边界等。**另一种是利用隐写分析丰富模型滤波层提取的噪声特征**，发现真实区域和篡改区域之间的噪声不一致。然后，通过双线性池化层融合来自两种流的特征，进一步合并这两种模式的检测结果。\n\n除JPEG压缩外，已经有一些学者研究更为一般的情况，估计图像可能经受过的各种变换和压缩。\n\n- Tagliasacchi等人[10]给出了一个**一般估计使用的图像变换技术和量化步长的方法**。\n- Bianchi等人[11]**给出了一个判定信号是否经历过格量化的最优检测子**，进而将该检测方法应用于实际的场景，并判断图像是否经历过双重JPEG压缩。**但该方法要求两次压缩使用的块划分必须相同**。\n\n### 增强操作取证技术\n\n在现实生活中，经常会遇到数码设备由于光线、环境以及设备自身性能的问题而得到不清晰的图像，导致无法辨识原始图像中的关键目标，需要对图像进行增强处理。图像增强指通过某些图像处理操作，如对比度增强、中值滤波、锐化、模糊等，对原始图像附加一些信息或变换数据，有目的地突出图像中某些“有用”信息或者抑制掩盖图像中某些“无用”信息，扩大图像中不同物体特征之间的差别，以改善图像的视觉效果，丰富信息量。**然而，图像增强操作可以淡化隐藏其他篡改操作的痕迹，达到降低篡改检测性能的目的。**目前，**图像增强操作取证**研究已经吸引了国内外学者的广泛关注，并取得了一些阶段性成果。\n\n####  对比度增强取证\n\n对比度增强是一种被广泛使用的图像增强处理技术，是对图像中每个像素点的值进行非线性映射，通过累积函数对灰度值进行调整，改变图像中像素强度的整体分布，最终达到对比度的增强效果。\n\n- Stamm等人[12]利用像素值映射在图像直方图上的统计特征，通过观察对比度增强操作向图像直方图的高频成分添加的能量信息，**检测对比度增强操作**。\n- Cao等人[13]提出了零波谷特征，即当图像经过对比度增强操作处理后，图像直方图能呈现出明显的波峰波谷，并且生成的波谷都是值为0的零波谷。利用零波谷特征，基于阈值化二类分类检测对比度增强操作。\n- Zhang等人[14]提出一种深度多路径网络，基于灰度直方图，通过共享多个卷积层捕获图像底层特征，并利用由多条路径组成的特定操作层学习不同对比度增强操作的特征，最后通过聚合层对原始图像和对比度增强操作处理的图像进行分类。\n- 王金伟等人[15]提出一种基于线性模型的图像对比度增强检测算法，提取图像噪声残差，采取分块策略计算每块残差的线性模型，并计算相应的功率谱密度，以整幅图像的均值功率谱密度作为分类特征，利用支持向量机进行分类。\n\n#### 模糊取证\n\n为了消除图像篡改在拼接边缘产生的视觉或统计上的畸变，通常会在图像篡改后使用模糊操作消除简单拼接留下的伪造痕迹。模糊操作的基本原理是对图像的局部邻近像素值进行邻域灰度平均。\n\n- 周琳娜等人[16]提出一种基于图像形态学滤波边缘特征的模糊操作取证方法，用同态滤波和形态学滤波增强模糊操作的图像边缘，利用离焦模糊和人工模糊的边缘特性，**检测伪造图像的模糊操作痕迹**。\n- Su等人[17]提出一种三维模糊识别方法，将图像划分为非模糊区、离焦模糊区和运动模糊区，利用梯度信息预测不同类型的模糊区域，并采用超像素分割技术对模糊区域进行细化识别。\n- Xu等人[18]提出几种新的局部模糊度量方法，使用不同类型的图像信息，包括颜色、梯度和光谱信息，基于支持向量机，构造最优模糊检测分类器。\n\n#### 中值滤波取证\n\n中值滤波操作是一种高度非线性操作，由于其良好的平滑滤波性质，通常被用于反取证技术中[19-20]，使得中值滤波取证越来越受到关注。\n\n- Kirchner等人[21]利用图像差分转移概率矩阵构造特征，检测图像是否经过中值滤波操作处理。\n- Kang等人[22]利用中值滤波残差特征，将特征相邻元素之间的关系建模为自回归模型，利用自回归系数检测中值滤波。\n- 彭安杰等人[23]提出一种基于中值滤波残差及其差分的鲁棒中值滤波取证技术，根据方向性和对称性将多方向差分特征分组，分别建立自回归模型，并提取其模型参数和直方图特征，组合成中值滤波检测特征。\n\n#### 锐化取证\n\n锐化滤波常用于增强图像的局部对比度，使边缘和文理等细节变得更加清晰锐利。同样，作为常用的图像润饰操作，锐化经常被用于削弱掩盖图像篡改时遗留的痕迹。\n\n- Cao等人[24]提出了一种有效的过冲效应测度方法，进而提取有效的指纹特征，通过阈值化分类来鉴别图像是否经历过USM锐化操作。\n- Ding等人[25]提出一种基于局部二值模式LBP的锐化检测方法，采用Canny算子进行边缘检测，将LBP应用于图像检测到的边缘像素并提取特征，基于支持向量机进行锐化分类。\n- F. Ding等人[26]利用图像USM锐化引起的纹理变化，提出一种边缘垂直二值编码的USM锐化检测方法。\n\n### **几何操作取证技术**\n\n当一幅图像被篡改时，例如拷贝一副图像的某一区域覆盖到被篡改图像中，篡改者通常需要**采取缩放、旋转等几何变换来掩盖篡改痕迹**。而这一过程需要对图像重新采样和重构，因此图像重采样检测是数字图像取证中十分重要的研究课题。重采样取证主要包含两个主要的研究目标，第一是**判断图像是否经过重采样的重采样检测**，第二是**估计重采样操作过程中施加于图像上的相关参数，如重采样因子、旋转角度**等。\n\n#### 缩放取证\n\n缩放操作是最常见的几何操作，常见于篡改图像后，调整篡改区域的大小以适配图像内容。然而在实际情况中，受限于网络传输速度与机器存储容量，篡改图像在缩放前后很可能会经历JPEG压缩。\n\n因此，涉及缩放操作的重采样取证有两大类研究方向，第一是针对无JPEG压缩的单一重采样取证场景；第二是和JPEG压缩操作相结合的复合取证场景，根据JPEG压缩出现的顺序，该场景可细分为三种复合取证场景，即Pre-JPEG重采样**（JPEG格式缩放后保存为无损格式）**、Post-JPEG重采样**（无损格式缩放后保存为JPEG格式）**和Double-JPEG重采样**（JPEG格式缩放后保存为JPEG格式）**三种情况。\n\n针对无JPEG压缩的单一重采样取证场景，重采样图像中每一个像素都由原始像素与插值函数卷积而成，且像素之间隐藏着重采样痕迹。由于插值的影响，这种重采样痕迹反映在空域上体现为像素之间存在相关性[27]，且相邻插值像素的间隔存在一种周期性；反映在频域上体现为存在频谱峰值，且峰值位置与放缩因子有关[28]。鉴于重采样操作的这些特点，近年来专家学者们提出了许多重采样检测算法，虽然这些算法的思路各异，但是大体都遵循一个流程。首先，从待检测图像中通过某种方式提取出残差信号，这种残差信号放大了重采样痕迹，剔除噪音与视觉信息，显性的揭露出重采样操作遗留下的周期性。根据所采用的数学模型不同，这种残差信号可以通过计算图像的二阶差分获得[29]，也可以通过快速滤波计算出插值像素得到相应的概率图[30]。在得到蕴含周期性的残差信号后，第二步就是根据这种信号判别重采样操作的存在，最常用的手段是频谱方法，通过对残差信号进行傅里叶变换，由于周期函数傅里叶变换的特殊性，重采样图像的频谱图上会出现与放缩因子有关的频谱峰值[28]，这些峰值可以作为重采样操作存在的证据，更进一步，根据峰值与放缩因子的关系估计出相应的放缩因子。除此之外，可以将第一步得到的残差信号视为手工设计的特征，作为输入训练一个强有力的分类器，通过数据驱动学习一个重采样判别模型[31]。更进一步，可以借鉴深度学习在图像检测领域的发展，提出用于重采样检测和因子估计的深度网络[32-35]。\n\n然而上述方法无法直接运用于与JPEG压缩操作相结合的复合取证场景，这是因为JPEG压缩通过分块将图像保存并复原，使得JPEG图像像素之间先天就带有周期性，当与放缩操作结合时，会混淆放缩操作带来的周期性，最终形成复合的周期，使得现有的重采样图像检测算法失效。\n\n- 针对Pre-JPEG重采样的情况，Liu等人[36]基于自相关函数构建了重采样图像的数学模型，他们通过该模型推导出了重采样系数、插值函数和重采样谱峰位置的关系，他们提出了基于图像差分极值点距离直方图的方法，通过挖掘图像差分的规律来取证重采样操作和进行因子估计。而后，他们还提出了针对Post-JPEG重采样图像的取证方案[37]，他们基于循环平稳信号分析发现Post-JPEG重采样图像上会出现一系列的对称谐波峰，并提出一种基于相位抵消的图像重采样检测和因子估计方法。\n- 除此之外，Lu等人[38]还提出了基于反缩放策略的双域联合估计算法，从频谱域和DCT域综合估计重采样因子，他们首先通过搜索匹配从Double-JPEG图像频谱中提取数个可能的候选因子，然后根据DCT域系数的独立同分布模型，使用反缩放策略得到最优估计。\n\n#### 旋转取证\n\n旋转操作也是常见的几何操作之一，同样涉及到图像像素重采样，在空域和频域上的操作痕迹与缩放操作有许多共通之处。\n\n- Wei等人将旋转操作视为一种特殊的缩放操作[39]，将旋转角度与特定的缩放因子结合在一起，通过频谱峰值与缩放因子的关系推导出图像经历的旋转角度，不仅如此，他们发现不同的频谱提取操作顺序可以更加明显的突出重采样峰值特征，有利于进一步区分旋转操作和缩放操作，并在此基础上提出了只包含旋转和缩放的二次几何变换操作链恢复算法。\n- 此后，Chen等人[40]提出对图像连续几何变换的取证方法，他们基于平方信号分析图像重采样特征，将Gallagher的理论推广到连续二次几何变换领域，揭示了二次几何变换的频谱特征，并提出了更细粒度的只包含旋转和缩放的二次几何变换操作链恢复算法。随后，他们根据二维自相关函数，提出了针对旋转缩放等仿射变换的参数估计方案[41]。\n\n###  操作链取证技术\n\n实际的图像处理过程可能包含多个操作，它们按照一定的顺序共同构成图像操作链。当图像经历多种操作处理时，不同操作遗留在图像中的痕迹可能相互叠加和覆盖，从而导致某个操作的遗留痕迹被掩盖或者破坏。同时，痕迹间的相互影响与操作的执行顺序有关，当操作顺序发生变化时，最终的遗留痕迹也会有所不同。因此，由于多个操作之间的相互影响，针对单个篡改操作的取证方法难以满足图像操作链取证的实际需求。**为了完整地揭示数字图像可能经历的处理过程，需要明确图像操作链包含的操作类型，多个操作的拓扑顺序，以及处理操作的关键参数。目前，图像操作链取证研究可以粗略的分为基于传统手工特征的方法和基于深度学习的方法。**\n\n#### 基于传统手工特征的方法\n\n- 西班牙维戈大学P. Comesaña于2012年最先提出操作链取证[42]。他从理论上分析了利用已有的单操作篡改取证算法检测图像操作链的可能性,并以量化和加性高斯白噪声组成的操作链为例进行了实验验证。随后, 他还进一步实验分析了包含更多操作的操作链拓扑结构[43]。\n- Stamm [44]等人针对对比度增强与缩放组成的二元操作链取证，提出采用直方图缺值特征和图像预测误差评价，分别进行对比度增强和图像缩放的检测，并引入了条件指纹的概念，用以单独识别对比度增强先于缩放操作的操作顺序。\n- Li [45]等人针对内容感知缩放和对比度增强组成的二元操作链取证，提出了通过计算马尔科夫一步转移概率矩阵以及提取DCT域的高维特征进行检测的方法。\n- Chu [46]等人从信息论的角度分析了操作顺序检测的可能性以及最优检测阈值的选取问题。\n- Gao等人[47]将操作可检测性问题转换为复杂假设检验问题，提出一种基于信息理论框架的图像操作链中特定操作的检测方案。\n- Chen等人[48]提出了一种基于决策融合的图像操作链中操作类型识别方法，挖掘不同图像特征，获取不同的取证证据。基于可信度计算策略，重新分配各证据权重，并通过决策融合识别操作链中包含的操作类型。\n- Liao等人[49]从操作相关性程度分析入手，开展操作链的参数估计研究。通过探究操作顺序和参数变化对生成图像及已有参数估计特征所带来的影响，将操作链中各操作间相关性分为耦合与非耦合，并设计了不同的参数估计策略。\n\n#### 基于深度学习的方法\n\n- Boroumand等人[50]针对特定二元操作链，通过**在卷积神经网络结构中添加全局平均池化层**, 实现对任意尺寸篡改图像的操作种类鉴别。\n- Stamm等人[51]基于设计的CNN约束分类器, **通过联合提取与操作序列相关的条件指纹特征**, 实现了对特定二元操作序列的种类识别和顺序鉴定。\n- Chen等人[52]设计了一个自动化的神经网络，通**过强化学习生成高性能的神经网络，用于多目标取证和处理历史检测。**同时，利用基于模块的搜索空间，通过密集连接，提升网络设计效率。\n- Liao等人[53]提出了**基于双流卷积神经网络的图像操作链取证框架**，并设计了多个针对特定操作组合的预处理。该网络包括空域卷积流和变换特征提取流，利用空域卷积流提取可视篡改特征，而变换特征提取流则通过结合针对性设计的预处理从图像的变换域提取残差特征。\n\n### **小结与思考**\n\n图像处理操作取证是多媒体安全领域中的热点问题，除了上述处理操作的取证，小波去噪、直方图均衡化、仿射变换等图像处理操作的取证也都受到了政治、经济、社会文化等多个领域的广泛关注。尽管图像处理取证技术已经在特定篡改操作的取证等方面取得了阶段性进展，但在研究的深度和广度上仍未成熟，还有一些亟待解决的问题，主要表现在：\n\n1. 在已知图像处理操作的情况下，可以通过模拟操作来训练模型，但对未知操作，如何设计对不同强度、不同操作组合均有效的取证模型是值得进一步探索的方向。\n2. 当图像经历多种处理操作编辑润饰时，**不同操作的痕迹相互掩盖混淆**，图像处理操作取证变得困难。大多**数图像处理操作取证方法是对单个特定操作或者特定二元操作链检测有效**，**缺乏适用于各种图像处理操作链取证**的通用理论基础。\n\n### 参考文献\n\n[1]S. Shang, Y. Zhao, and R. Ni. Double JPEG detection using high order statistic features. IEEE International Conference on Digital Signal Processing (DSP), Beijing, China, pp. 550-554, 2016.\n\n[2]X. Zeng, G. Feng, and X. Zhang. Detection of double JPEG compression using modified DenseNet model. Multimedia Tools and Applications, vol. 78, no. 7, pp. 8183-8196, 2019.\n\n[3]J. Wang, W. Huang, X. Luo, Y.-Q. Shi, and S. Kr. Jha. Non-aligned double JPEG compression detection based on refined Markov features in QDCT domain. Journal of Real-time Image Processing, vol. 17, no. 1, pp.7-16, 2019.\n\n[4]F. Galvan, G. Puglisi, A. R. Bruna, and S. Battiato. First quantization matrix estimation from double compressed JPEG images. IEEE Transactions on Information Forensics and Security, vol. 9, no. 8, pp. 1299-1310, 2014.\n\n[5]T. Hai Thai, R. Cogranne, F. Retraint, and T. Doan. JPEG quantization step estimation and its applications to digital image forensics. IEEE Transactions on Information Forensics and Security, vol. 12, no. 1, pp. 123-133, 2017.\n\n[6]P. Yang, R. Ni, and Y. Zhao. Double JPEG compression detection by exploring the correlations in DCT domain. Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC), Honolulu, HI, USA, pp. 728-732, 2018.\n\n[7]W. Wang, J. Dong, and T. Tan. Exploring DCT coefficient quantization effects for local tampering detection. IEEE Transactions on Information Forensics and Security, vol. 9, no. 10, pp. 1653-1666, 2014.\n\n[8]I. Amerini, T. Uricchio, L. Ballan, and R. Caldelli. Localization of JPEG double compression through multi-domain convolutional neural networks. IEEE Conference on Computer Vision and Pattern Recognition Workshops (CVPRW), Honolulu, HI, USA, pp. 1865-1871, 2017.\n\n[9]P. Zhou, X. Han, V. I. Morariu, and L. S. Davis. Learning Rich Features for Image Manipulation Detection. IEEE Conference on Computer Vision and Pattern Recognition (CVPR), Salt Lake City, UT, USA, pp. 1053-1061, 2018.\n\n[10]M. Tagliasacchi, M. V.-Scarzanella, P. L. Dragotti, and S. Tubaro. Transform coder identification. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Vancouver, BC, Canada pp. 5785-5789, 2013.\n\n[11]T. Bianchi, A. Piva, and F. Pérez-González. Near optimal detection of quantized signals and application to JPEG forensics. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 168-173, 2013.\n\n[12]M. C. Stamm, and K. J. Ray Liu. Forensic detection of image manipulation using statistical intrinsic fingerprints. IEEE Transactions on Information Forensics and Security, vol. 5, no. 3, pp. 492-506, 2010.\n\n[13]G. Cao, Y. Zhao, R. Ni, and X. Li. Contrast enhancement-based forensics in digital images. IEEE Transactions on Information Forensics and Security, vol. 9, no. 3, pp. 515-525, 2014.\n\n[14]C. Zhang, D. Du, L. Ke, H. Qi, and S. Lyu. Global contrast enhancement detection via deep multi-path network. International Conference on Pattern Recognition (ICPR), Beijing, China, pp. 2815-2820, 2018.\n\n[15]王金伟, 吴国静. 基于线性模型的图像对比度增强取证[J]. 网络空间安全, 2019, vol. 10, no. 8, pp. 47-54.\n\n[16]周琳娜, 王东明, 郭云彪, 杨义先. 基于数字图像边缘特性的形态学滤波取证技术[J]. 电子学报, 2008, vol. 36, no. 6, pp. 1047-1051.\n\n[17]B. Su, S. Lu, and C. L. Tan. Blurred image region detection and classification. ACM International Conference on Multimedia (ACM MM), New York, NY, USA, pp. 1397-1400, 2011.\n\n[18]W. Xu, J. Mulligan, D. Xu, and X. Chen. Detecting and classifying blurred image regions. IEEE International Conference on Multimedia and Expo (ICME), San Jose, CA, USA, 2013.\n\n[19]M. Kirchner, and R. Bohme. Hiding traces of resampling in digital images. IEEE Transactions on Information Forensics and Security, vol. 3, no. 4, pp. 582-592, 2008.\n\n[20]M. C. Stamm, and K. J. Ray Liu. Anti-forensic of digital image compression. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1050-1065, 2011.\n\n[21]M. Kirchner, and J. Fridrich. On detection of median filtering in digital images. The SPIE-Media Forensics and Security, San Jose, USA, pp. 754110-1-75411012, 2010.\n\n[22]X. Kang, M. C. Stamm, A. Peng, and K. J. Ray Liu. Robust median filtering forensics using an autoregressive model. IEEE Transactions on Information Forensics and Security, vol. 8, no. 9, pp. 1456-1468, 2013.\n\n[23]彭安杰, 康显桂. 基于滤波残差多方向差分的中值滤波取证技术[J]. 计算机学报, 2016. vol. 39, no. 3, pp. 503-515.\n\n[24]G. Cao, Y. Zhao, R. Ni, and A. C. Kot. Unsharp masking sharpening detection via overshoot artifacts analysis. IEEE Signal Processing Letters, vol. 18, no. 10, pp. 603-606, 2011.\n\n[25]F. Ding, G. Zhu, and Y. Q. Shi. A novel method for detecting image sharpening based on local binary pattern. International Conference on Digital Forensics and Watermarking (IWDW), Berlin, Germany, pp. 180-191, 2013.\n\n[26]F. Ding, G. Zhu, J. Yang, J. Xie, and Y. Q. Shi. Edge perpendicular binary coding for USM sharpening detection. IEEE Signal Processing Letters, vol. 22, no. 3, pp. 327-331, 2015.\n\n[27]A. C. Popescu, and H. Farid. Exposing digital forgeries by detecting traces of resampling. IEEE Transactions on Signal Processing, vol. 53, no. 2, pp. 758-767, 2005.\n\n[28]A. C. Gallagher. Detection of linear and cubic interpolation in JPEG compressed images. Canadian Conference on Computer and Robot Vision (CRV), Victoria, BC, Canada, pp. 65-72, 2005.\n\n[29]B. Mahdian, and S. Saic. Blind authentication using periodic properties of interpolation. IEEE Transactions on Information Forensics and Security, vol. 3, no. 3, pp. 529-538, 2008.\n\n[30]M. Kirchner. Fast and reliable resampling detection by spectral analysis of fixed linear predictor residue. ACM Workshop on Multimedia and Security (MM & Sec), Oxford, UK, pp. 11-20, 2008.\n\n[31]X. Feng, I. J. Cox, and D. Gwenaël. Normalized energy density-based forensic detection of resampled images. IEEE Transactions on Multimedia, vol. 14, no. 3, pp. 536-545, 2012.\n\n[32]B. Bayar, and M. C. Stamm. On the robustness of constrained convolutional neural networks to JPEG post-compression for image resampling detection. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), New Orleans, LA, USA, pp. 2152-2156, 2017.\n\n[33]B. Bayar, and M. C. Stamm. Constrained convolutional neural networks: A new approach towards general purpose image manipulation detection. IEEE Transactions on Information Forensics and Security, vol. 13, no. 11, pp. 2691–2706, 2018.\n\n[34]C. Liu, and M. Kirchner. CNN-based rescaling factor estimation. ACM Workshop, pp. 119–124, 2019.\n\n[35]S. Luo, J. Luo, W. Lu, Y. Fang, J. Zeng, S. Shi, and Y. Zhang. Resampling factor estimation via dual-stream convolutional neural network. Computers, Materials & Continua, vol. 66, no. 1, pp. 647–657, 2021.\n\n[36]X. Liu, W. Lu, Q. Zhang, J. Huang, and Y. Shi. Downscaling factor estimation on pre-JPEG compressed images. IEEE Transactions on Circuits and Systems for Video Technology, vol. 30, no. 3, pp. 618-631, 2019.\n\n[37]Q. Zhang, W. Lu, T. Huang, S. Luo, Z. Xu, and Y. Mao. On the robustness of JPEG post-compression to resampling factor estimation. Signal Processing, vol. 168, pp. 107371, 2020.\n\n[38]W. Lu, Q. Zhang, S. Luo, Y. Zhou, J. Huang, and Y. Q. Shi. Robust estimation of upscaling factor on double JPEG compressed images. IEEE Transactions on Cybernetics, pp. 1-13, 2021.\n\n[39]W. Wei, S. Wang, X. Zhang, and Z. Tang. Estimation of image rotation angle using interpolation-related spectral signatures with application to blind detection of image forgery. IEEE Transaction on Information Forensics and Security, vol. 5, no. 3, pp. 507-517, 2010.\n\n[40]C. Chen, J. Ni, Z. Shen, and Y.Q. Shi. Blind forensics of successive geometric transformations in digital images using spectral method: theory and applications. IEEE Transactions on Image Processing, vol. 26, no. 6, pp. 2811-2824, 2017.\n\n[41]J. Ou, and J. Ni. Blind estimation of affine transformation using 2D cyclostationarity of resampled images. Mippr: Multispectral Image Acquisition, Processing, & Analysis International Society for Optics and Photonics, 2015.\n\n[42]P. Comesaña. Detection information theoretic measures for quantifying the distinguishability between multimedia operator chains. IEEE International Workshop on Information Forensics and Security (WIFS), Tenerife, Spain, pp. 211-216, 2012.\n\n[43]P. Comesaña, and F. P. González. Multimedia operator chain topology and ordering estimation based on detection and information theoretic tools. International Conference on Digital Forensics and Watermarking (IWDW), Berlin, Germany, pp. 213-227, 2013.\n\n[44]M. C. Stamm, X. Chu, and K. J. Ray Liu. Forensically determining the order of signal processing operations. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 162-167, 2013.\n\n[45]J. Li, Y. Zhao, and R. Ni. Detection of seam carving and contrast enhancement operation chain. International Conference on Intelligent Information Hiding and Multimedia Signal Processing (IIH-MMSP), Adelaide, SA, Australia, pp. 235-238, 2015.\n\n[46]X. Chu, Y. Chen, and K. J. Ray Liu. Detectability of the order of operations: An information theoretic approach. IEEE Transactions on Information Forensics and Security, vol. 11, no. 4, pp. 823-836, 2016.\n\n[47]S. Gao, X. Liao, and X. Liu. Real-time detecting one specific tampering operation in multiple operator chains. Journal of Real-Time Image Processing, vol. 16, pp. 741-750, 2019.\n\n[48]J. Chen, X. Liao, and Z. Qing. Identifying tampering operations in image operator chains based on decision fusion. Signal Processing: Image Communication, vol. 95, pp. 116287-1-116287-10, 2021.\n\n[49]X. Liao, and Z. Huang. A framework for parameters estimation of image operator chain. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Barcelona, Spain, pp. 2787-2791, 2020.\n\n[50]M. Boroumand, and J. Fridrich. Deep learning for detecting processing history of images. Electronic Imaging, pp. 213-1-213-9, 2018.\n\n[51]B. Bayar, and M. C. Stamm. Towards order of processing operations detection in JPEG-compressed images with convolutional neural networks. Electronic Imaging, pp. 211-1-211-9, 2018.\n\n[52]Y. Chen, Z. Wang, Z. J. Wang, and X. Kang. Automated design of neural network architectures with reinforcement learning for detection of global manipulations. IEEE Journal of Selected Topics in Signal Processing, vol. 14, no. 5, pp. 997-1011, 2020.\n\n[53]X. Liao, K. Li, X. Zhu, and K. J. Ray Liu. Robust detection of image operator chain with two-stream convolutional neural network. IEEE Journal of Selected Topics in Signal Processing, vol. 14, no. 5, pp. 955-968, 2020.\n\n## 视频编辑篡改检测Video manipulation Detetion综述\n\n从公开发表论文数量来看，目前绝大多数的篡改被动检测算法都是专用篡改检测算法，且效果十分显著，但需要已知篡改方法和类型的先验知识.通用篡改检测算法针对多种或未知篡改检测准确率良好但也具有一定局限性，实用性和泛化能力有待提高，且对篡改类型的辨识能力不足，只能判断是否经历了篡改操作；**针对多类型+多次篡改的溯源篡改操作链识别能力有限，这也是未来可能的研究方向之一。**\n\n**通用篡改检测算法**的最大优势就是快速筛选可疑视频和辨识经历一次及以上篡改的数字视频，然后再用专用算法探测或穷举识别其可能的篡改操作类型或者溯源篡改操作链。总而言之，两者技术是互补关系。\n\n###  数字视频再编辑篡改技术\n\n数字视频编辑篡改技术的一般定义：为了视频画面提质、传输、存储，或改变内容内在关系的后编辑操作的技术集合。这一后编辑操作可能是常规的需求，也可能是恶意的目的。目前，本文中将常见的数字视频编辑篡改技术分为**四大类**：\n\n1. 数字视频**文件再编辑**的篡改方法：本文是指针对数字视频的码流、或者编码参数、容器等的编辑，达到对原始视频文件的再编辑目的，一般不改变视频内容。例**如，码率重采样、视频格式转码、容器转换、各种滤波器操作等后处理操作**；\n2. 数字视频**内容再编辑**的篡改方法：本文是指针对数字视频的部分解码或完全解码后内容进行内容级编辑操作，达到对原始视频内容的再编辑目的。例如，**视频帧间插入/删除攻击、帧内复制粘贴攻击操作**等；\n3. 数字视频**内容生成**的篡改方法：本文是指**针对数字视频内容的部分生成替换**或全部生成虚拟目标全局替换，进行视频内容级编辑操作，达到对原始视频内容的再编辑目的。例如，使用StyleGAN网络生成虚拟人物或目标的视频内容等操作；\n4. 数字视频的**重拍摄篡改**方法：本文是指针对数字视频内容的重新数字采集再编辑操作，达到对原始视频内容的再编辑目的。例如，**利用数字设备对屏幕画面进行重新拍摄和再编辑操作**。\n\n#### 视频文件再编辑篡改\n\n视频文件再编辑篡改是指在不改变视频内容的前提下对视频文件的编辑操作，比如转码操作、分辨率提升/降低、平滑操作、锐化操作、去噪操作、信息隐藏操作等。\n\n例如，数据隐藏技术可以在不影响视觉效果的前提下，向视频内嵌入信息，实现对视频文件的编辑。例如，北京交通大学的李赵红[4]等人研究了P帧种各尺寸PU划分类型在隐写前后的数目变化，构建了25维和3维特征用来检测HEVC视频的块划分模式隐写算法。帧率变化是通过提升或下降视频的帧率方法来达到编辑视频文件的目的。Khoubani[5]等人基于模糊平滑的快速四元数小波运动补偿进行帧率上转换。这篇论文使用图像序列的相位来考虑QWT运动估计，实现了更准确的运动估计、更少的后处理流程和更低的复杂度。码率变换是另外一种视频文件编辑的方法，Kevin[6]等人提出一种通过求解优化问题来选择比特率的方法即Bola算法。Yin等人[7]提出了MPC算法。Kim[8]等人结合残差学习方式提出了IFCNN网络，用以取代视频编码中的环路滤波算法，即把未经环路滤波的重建图像直接输入网络进行增强处理。\n\n#### 数字视频内容编辑篡改方法\n\n视频内容篡改是指部分解码或全解码后，针对音频、图象、视频中特定对象的操作过程，其结果是改变内容的原始属性，导致内容的不可信。从视频帧目标被攻击角度来看，数字视频内容编辑篡改分为**帧间编辑篡改和帧内编辑篡改**。\n\n视频的帧间编辑篡改方式主要有：帧删除篡改，即删除原始视频的至少一帧或连续多帧的操作；帧插入篡改，即非同源视频的帧片段插入到原视频帧序列中的操作；帧复制粘贴篡改，即同源视频的帧片段在相同视频中不同时间轴上复制插入到原视频中的操作。\n\n- 针对这类视频内容的帧间编辑篡改问题，2012年孙锬锋等人[9]提出了视频帧间篡改中主要篡改类型的定义，即包括视频帧复制粘贴、帧插入、帧删除等，其中对于帧的复制粘贴，可以划分为同源和异源两类，同源的帧复制表示复制的对象来自于当前视频片段，而异源帧复制粘贴是将其他视频的片段复制到当前视频片段中。\n- 2014年王婉等人[10]根据场景的差异性将视频内容编辑篡改划分为静止背景下的内容编辑篡改以及包含运动背景的篡改场景，并提出了一种可以同时检测帧删除，帧插入及帧复制的算法。\n- 同年柏正尧等人[11]针对帧间篡改对帧间相关性进行研究，并将非负张量分解（Nonnegative tensor factorization, NTF）算法应用到了视频帧间篡改检测中。\n- 冯春晖等人[13]通过分析残差强度在不同宏块间分布是否具有波动性来检测视频是否被帧删除，并定位删除点的位置。该作者在[13]的基础上进一步分析了具有丰富运动信息下的视频帧间篡改场景，考虑到运动视频容易导致帧间数据特征的变化，作者从帧间差异的角度，提出了一种删帧检测算法[14]，对复杂篡改环境下的序列中不同干扰帧进行分析，并利用运动残差特征区分不同干扰帧和删帧位置处的帧，进而提出一种去帧内编码处理算法，使算法能够应对运动信息带来的影响。\n- 不同于视频内容帧间篡改，视频内容帧内篡改并非以帧为单位进行篡改，而是以目标为单位进行编辑篡改操作，2021年Yang Quanxin等人[12] 指出视频帧内篡改主要有空域复制粘贴，帧内目标移除等，作者发现帧内篡改将引起视频在时空域上的高频信息的波动。\n\n#### 数字视频内容生成篡改方法\n\n视频内容生成方法是指在GAN网络及其衍生网络根据对抗原理，即生成器和判别器构成网络，从一幅噪声图像不断逼近真实图象的方法，其生成局部或全部图象和视频并不是真实的物理拍摄获得，从而达到以假乱真的目的。\n\n- 例如，Elor[15]等人的方案可以生成含有人物的视频，并且可以通过扭曲来轻微改变人物的头部姿势。因为这种方法是基于单个目标图像的，它从源视频中的嘴唇内部复制到目标视频，因此仅能部分保留目标视频中的人物身份。\n- Kim[16]等人的做法相对于以前的方法而言，可以生成更为逼真的视频。\n- Zhouhang[17]等人使用音频来生成视频。他们将一个无声的视频分解为两部分，一部分是人物身份信息，另一部分是语音信息，这里的语音信息是指通过人物嘴部动作传递出来的广义语音信息，而非听到的声音。\n- Fried[18]等人基于文本来编辑视频。给定任意文本，该方法就能改变一段视频中人物所说的话，同时保持无缝的试听流。要对一段视频中人物讲话内容进行改变，只需要编辑一下想要表达的文本内容，这种方法十分地简单易行。\n- Suwajanakorn[19]等人对人脸中的口型进行替换，生成最终的伪造视频。\n\n#### 数字视频重拍摄的篡改方法\n\n数字视频重拍摄的篡改方法是指物理上用物理设备对数字视频内容播放进行重拍摄而造成内容时空含义混乱，达到篡改内容的目的，也就是“二次拍摄篡改编辑”。\n\n现有的重拍摄的编辑篡改方法主要根据拍摄设备、拍摄场景以及拍摄对象的差异进行分类[20]。Lee[20]等人提出目前重拍摄视频大部分产生于视频投放到液晶屏幕（LCD）上时被重拍摄，因此该作者重点研究LCD显示的视频重拍摄编辑篡改，提出一种梳状纹理的特征识别其重拍摄操作。P. Bestagini[21]等人提出了同步性不一致的重拍摄编辑篡改，作者利用这种不一致性产生的块重影现象对重拍摄视频进行检测。另外，Xavier [22]等人根据电影被投影时引起屏幕空间上的亮度重分配效应、垂直投影在屏幕上的图像的稳定性效应、高频闪烁的显示屏与摄像机快门之间的相互作用这三种效应设计不同的重拍摄编辑篡改场景。Mahdian[23]等人分析了不同品牌LCD显示屏的重拍摄视频在频谱波纹上的差别。除了针对LCD屏幕的重拍摄，重拍摄编辑篡改还包括以手持摄像机拍摄的视频。此类视频中的运动分为帧内运动和手持引起的全局运动，其中全局运动为手持重拍摄独有的效应。Marco [24]等人提出了具有的全局运动特征的手持拍摄视频编辑篡改。另外，图像重拍摄编辑篡改方面的几个经典场景同样也可以在视频重拍摄上适用。比如Thongkamwitoon[25]针对图像的类别差异构建重拍摄图像集合，通过挖掘彩色图像和黑白图像在色度上的差异引起的重拍摄图像在像素上的失真特性对图像进行重拍摄检验。Anjum等人[26]通过挖掘图像中高层次边缘细节特征，进而根据在原始图像和重拍摄图像中不同组别的边缘像素数量具有一定差异这一特性，构建具有不同边缘特性的重拍摄场景并进行分类。\n\n### 数字视频被动取证检测技术\n\n上述数字视频编辑技术表明了：\n\n1. 数字视频无论是编码复杂性，还是数据量的规模庞大，都给篡改编辑带来了更多的可利用空间和隐藏空间；\n2. 篡改攻击的角度多样性，导致了针对篡改类型的通用识别算法实现具有较大难度。\n\n针对上述篡改编辑类型，对目前已经取得的被动检测成果进行介绍和分析。我们把数字视频篡改被动取证技术**分为三类**：\n\n1. **时空域**特征检测技术。即无论是音频、图象、视频完全解码后，就会是一种结构化或半结构化的媒体原始文件，在原始文件上，可以构建各种物理、几何、光学等的传统数学特征模型，而这些数学模型通常是某种目标特征属性的固定模式、或者连续变化的某种特征数据表征。篡改编辑的过程中会破坏这种上述固定内在模式，引起连续性质的某些突变、或者出现某些特殊非典型痕迹残留分布等情况，而这些情况就可以通过针对时空特征建模方法来加以检测和识别。**代表性算法有光流特征、运动场特征、亮度变化率特征、块效应强度特征等。**\n2. **编码域**特征检测技术。即在数字媒体不完全解码的情况下，码流域、编码域的编码参数、编码域的预测模式、编码域分块模式等环境下，同样具有潜在的首次编码后的系数分布规律和特殊内在统计模式。而这种潜在的分布规律和模式，需要构建高维特征模型，如高阶概率统计模型、多模态融合特征模型等才能洞悉其规律。而且这种高维特征模型对人眼和人耳不可感知的细微编辑痕迹更为敏感。而且编码技术本身也会对数字媒体产生失真效果，因此，对完全解码后媒体数据可能带来意想不到的影响。但是在编码域对篡改痕迹直接展开分析的同时，已经充分考虑了编码失真的影响，在检测过程中可以更加精细化感知各种篡改编辑残留的痕迹。**代表性算法有PU数量统计特征、预测残差分布特征、宏块类型变化特征、DCT系数分布特征**。\n3. **深度**特征检测技术。即无论数字媒体是什么容器格式或者什么编码，首先需要生成大量的篡改样本，把篡改样本进行初步的预处理之后，直接送到深度网络模型中加以学习叠代，直到获得预期稳定的输出，此时深度网络特征模型已经完成了参数训练，此后只需要给定输入就可给出分类结果。当然目前为止，这样简单粗暴的方法效果并不明显。学者们纷纷提出了多样化的**深度网络模型、预处理方法、增加Attention机制、修剪网络无意义的层、增加强化学习的机制**等等。通过深度网络自主学习的能力，学习到人类目前无法感知的特征，增强对篡改数据规律知识的学习，最终能否优于人类设计特征的效果。但是目前为止，大部分的深度网络模型对全局学习的效果不佳。**代表性算法有卷积神经网络、双通道残差网络、遗传卷积网络、混合深度学习网络**。\n\n#### 时空域特征检测技术\n\n在数字视频的拍摄过程中，**相邻帧或像素之间往往存在一定的关联**，而对于视频的篡改往往会破坏这种关联性，因此视频篡改操作往往会在时空与留下痕迹。在现有工作中，时空域的检测算法能够直接对篡改痕迹像素或帧之间的异常特性进行建模，但算法复杂度往往较高。\n\n- 文献[27]中，巢娟等人提出了一种基于光流一致性的帧间篡改检测方法，针对帧插入和帧删除的细微差别，提出了两种不同的检测方案。实验表明，该方案在识别帧插入和帧删除模型方面取得了较好的效果。\n- 在文献[28]中，吴俞醒等人提出了一种基于速度场一致性的视频帧间伪造（连续帧删除和连续帧复制）检测算法。在文献[3]中，许强等人结合GOP结构非对齐的HEVC重编码引起的质量下降特性，通过分析HEVC编码标准中帧间编码对重建像素值的影响，提出基于帧间质量下降机制分析的检测算法，该算法对GOP结构非对齐的重编码检测问题能取得0.98以上的AUC值。\n- 而对于视频转码检测，在[29]中，许强构建了去块滤波模式决策特征以及SAO补偿特征来进行重编码的检测，算法分别在公开数据集上进行了验证，算法能取得97.21%的平均准确率。\n- 在文献[30]、[31]中，何沛松等人将待测视频解码为一连串连续的视频帧后，根据块效应强度变化规律的不同能够对视频双编码视频进行检测。\n- 在文献[32]中，杨高波等人提出了一种基于边缘强度的被动取证方法来检测候选视频中可能的视频帧速率上转换（FRUC）操作。平均检测准确率达94.5%。\n- 在文献[33]中，边山等人在在大量实验的基础上，发现目前大多数视频编辑软件中采用的帧速率上转换算法不可避免地会在生成的视频帧序列的帧间相似性中引入一些周期性的伪影。\n\n综上所述，时空域特征检测技术可以较全面的解决帧间和帧内篡改编辑的被动检测问题，**但仍存在一下问题**：\n\n1. 视频包含快速运动的信息，或者包含场景切换，算法的性能将下降。这个问题是目前被动检测算法中普遍存在的鲁棒性问题，有待改善。\n2. 在重编码比特率较低时检测性能会出现明显下降。这是因为视频重编码时比特率（画面质量）较低，会造成严重的信息失真，与篡改编辑痕迹耦合在一起，造成检测困难。这一问题应该系统研究比特率变化与篡改编辑痕迹变化之间的关系。\n3. 时空特征检测技术基本上都是针对专用篡改编辑而设计的，因此通用性和泛化能力都十分有限。有的算法对复合篡改编辑的方式显得无能为力。这也是未来要解决的重要问题之一。\n\n####  编码域特征检测技术\n\n视频重编码操作是在首次编码的基础上再一次执行编码操作，基于编码域特征统计分析的视频重编码痕迹检测算法实际上就是根据重编码操作对视频编码后的参数扰动关系构建检测依据，依赖手工设计的特征来进行检测的算法。\n\n- 在文献[34]中，DAVID等人提出了基于The Variation of Prediction Footprint（VPF）的二次编码篡改检测算法。\n- 文献[35]中，该团队在MPEG-2标准上提出了一种基于广义VPF（G-VPF）的双编码检测算法，在首次编码使用QP（QP1）大于重编码使用QP（QP2）的情况下达到了98%以上的准确率。\n- 在文献[38]中，赵耀等人通过对预测模式特征（PMF）的分析，提出了一种用于假高清视频场景的重编码检测方案，该方法首先从四个方向的帧内预测模式中提取一个四维特征。其次，从三个预测模式中提取了6维特征。最后，将这两种特征集结合到PMF中，检测出伪造高清视频，并进一步估计其原始QPs和比特率。\n- 在文献[39]中，蒋兴浩等人提出了一种基于帧内预测模式的新方法。文献分析了帧内编码的质量退化机理，并充分考虑了帧内编码的误差来源，建立了等效误差模型，随后提出了基于帧内预测模式统计特征的双HEVC编码检测特征模型。最后，用720p和1080p的HEVC视频代替低分辨率（CIF或QCIF）视频进行了实验。实验结果表明，与现有方法相比，该方法具有更好的效率。此外，该方法对不同的编码配置具有较强的鲁棒性。\n\n综上所述，该类检测算法能有效的检测普通场景下的重编码操作，**但存在一些不足**：\n\n1. 算法过度依赖解码器对参数的提取，并且容易受到反取证手段的攻击。\n2. 当视频包含强运动成分信息或场景切换时，算法性能将下降。\n3. 智能编码技术的兴起，给重编码检测带来了新的危机。\n\n#### 深度特征检测技术\n\n近年来，卷积神经网络（CNN）已经在多媒体取证领域取得成功应用。CNN 能够从训练样本中自动有效地学习层次化的特征表达。受此启发，一系列算法利用卷积神经网络来解决视频重编码痕迹检测问题。\n\n- 在文献[40]中，何沛松等人首先建立视频帧集合，以 3 帧为单位进行分块，若 3 帧中第二帧为重定位I帧，则该片段定义为正样本，否则为负样本。通过这种预处理操作，构建一个卷积神经网络，利用平均池化，作者能很好地检测出重定位I帧。\n- 类似的在[41]中许强等人通过构建 Genetic CNN，来进行AVC视频中重定位 I 帧的检测。不同于一般的卷积神经网络，**Genetic CNN 能够结合遗传算法，实现自动设计网络架构的目的**，通过算法对比，该算法的有效性得到验证。\n- 在[42]中，何沛松等人通过**构建一个混合深度神经网络来揭露伪高清的HEVC重编码视频**。通过提取基于块的残差信号，并构建一个双支路的网络进行检测，不同分支的输出向量将拼接后再联合优化得到逐块的检测结果。最后采用多数投票(local-to-global)策略得到最终的检测结果。\n- 除此之外，何沛松等人在[2]中**提出了一种混合神经网络**，通过从编码域中的编码信息中学习鲁棒时空表示，来揭示具有双重编码的HEVC视频中异常帧。\n- 在[43]中，Gan等人提出了一种**基于VGG-11卷积神经网络的视频帧内伪造取证算法**，该算法能自动检测视频伪造帧。该算法首先将视频解编码为一系列帧，计算出每帧的运动剩余映射，提取隐写特征。然后，以四个不同的隐写特征样本集作为训练集，并将测试集作为训练和测试模型。通过对比实验，选择了最佳性能特征。最后，通过伪造视频对伪造的帧进行了成功的标记。\n\n综上所述，深度神经网络的运用在一定程度上解决了传统算法的缺陷，虽然这些算法都能够取得较高的准确率，**但其仍然存在一系列局限性**：\n\n1. 大多数基于深度神经网络的算法对样本数量要求较高，并且需要耗费大量的时间训练网络模型。\n2. 这些算法都是以重定位I帧或者块为单位作为输入，如何设计高效的网络**实现视频级别的重编码痕迹检测**是今后研究的重要方向。\n3. 深度神经网络在提升了人工检测效率和准确率，但其深度网络的可解释性和学习到特征的可解释性仍然是不透明的，很多时候“过学习”的现象或者“欠学习”的问题普遍存在。这一问题有待进一步改善。\n\n### 总结与展望\n\n1. 篡改编辑（攻击）残留痕迹与数字媒体编码技术的依赖关系尚存在空白领域有待探索。数字媒体**各类编码标准的不同特性内在机制和信息失真模型理论、特征模型建模的方法论、算法检测框架的性能等问题**，还需要不断完善，逐步建立起完整的被动检测理论体系；\n2. 人工智能理论、深度网络学习方法与对抗篡改攻击技术互为对抗和相互融合是未来的发展趋势。目前新型的**VVC编码已经采用了众多的神经网络模块替代传统编码框架中画面提质模块、滤波模块、运动预测模块**等，未来的人工智能技术与编码深度结合之下，如何检测篡改攻击痕迹是更加复杂和困难的挑战；\n3. 该领域的专用算法尽管已经取得了丰硕的成果，但还存在着诸多边界条件的限制，离实际应用存在较大差距；**新型篡改攻击方法不断涌现；新的深度学习模型削弱了篡改痕迹等问题；新的编码算法使得篡改痕迹被隐藏；概率性取证检测转化为确定性检测**的方法等一系列问题。\n4. 目前尽管已经出现了若干的公开视频篡改数据库，但是覆盖篡改类型还比较有限，数据库建设的标准也不统一，数据库的原始样本也存在容器、编码标准混乱的情况，对支撑整个领域研究还是远远不够的；\n5. 在该领域的客观评价指标大多数**仅限于传统的检测准确率、算法效率、定位准确率等指标，但这些指标无法满足对篡改检测算法性能进行全方位的评价**，对未来算法应用落地是一个不容回避的问题，亟待更多的学者参与其中。\n\n### 参考文献\n\n[1] Mi Z, Jiang X, Sun T, GAN-Generated Image Detection with Self-Attention Mechanism against GAN Generator Defect[J]. IEEE Journal of Selected Topics in Signal Processing, 2020, 14(5): 969-981.\n\n[2] Peisong He;Haoliang Li;Hongxia Wang;Shiqi Wang;Xinghao Jiang;Ruimei Zhang, Frame-wise Detection of Double HEVC Compression by Learning Deep Spatio-temporal Representations in Compression Domain[J]. IEEE Transactions on Multimedia, 2020, DOI: 10.1109/ TMM.2020.3021234.\n\n[3] Xu Q, Jiang X, Sun T, Detection of HEVC double compression with non-aligned GOP structures via inter-frame quality degradation analysis, Neurocomputing,2021, 452: 99-113.\n\n[4] Zhong hao Li, Meng, Laijin; Xu, Shutong; Li, Zhaohong; Shi, Yunqing; Liang, Yuanchang, A HEVC Video Steganalysis Algorithm Based on PU Partition Modes[J]. Computers, Materials & Continua, 2019, 59(2):563-574.\n\n[5] Khoubani Sahar and Moradi Mohammad Hassan. A fast quaternion wavelet-based motion compensated frame rate up-conversion with fuzzy smoothing: application to echocardiography temporal enhancement[J]. Multimedia Tools and Applications, 2020, 80(6):8999-9025.\n\n[6] Kevin Spiteri and Rahul Urgaonkar and Ramesh K. Sitaraman. BOLA: Near-Optimal Bitrate Adaptation for Online Videos[J]. IEEE/ACM Transactions on Networking, 2020, PP(99):1-14.\n\n[7] Yin, Xiaoqi, Jindal, Abhishek, Sekar, Vyas,Sinopoli, Bruno, A Control-Theoretic Approach for Dynamic Adaptive Video Streaming over HTTP[J]. Computer communication review, 2015, 45(4):325-338.\n\n[8] Park W S, Kim M., CNN-based in-loop filtering for coding efficiency improvement[C]// 2016 IEEE 12th Image, Video, and Multidimensional Signal Processing Workshop (IVMSP). IEEE, 2016, DOI: 10.1109 /IVMSPW.2016.7528223.\n\n[9] Sun T, Jiang X, Chao J, A Novel Video Inter-frame Forgery Model Detection Scheme Based on Optical Flow Consistency[J]. International Workshop on Digital Watermarking, 2012. [10] Wang W, Jiang X, Wang S, et al. Identifying Video Forgery Process Using Optical Flow[M]//Digital-Forensics and Watermarking. Springer Berlin Heidelberg, 2014: 244-257.\n\n[11] Yin L, Bai Z, Yang R. Video forgery detection based on nonnegative tensor factorization[C]//Information Science and Technology (ICIST), 2014 4th IEEE International Conference on. IEEE, 2014: 148-151.\n\n[12] Quanxin Yang, Dongjin Yu, Zhuxi Zhang, Ye Yao, Linqiang Chen, Spatiotemporal Trident Networks: Detection and Localization of Object Removal Tampering in Video Passive Forensics[J]. IEEE Transactions on Circuits and Systems for Video Technology. 2020/12, DOI: 10.1109/TCSVT.2020.3046240.\n\n[13] Feng C, Xu Z, Zhang W, et al. Automatic location of frame deletion point for digital video forensics[C]//Proceedings of the 2nd ACM workshop on Information hiding and multimedia security. ACM, 2014: 171-179.\n\n[14] Feng C, Xu Z, Jia S, Zhang W, Xu Y, Motion-adaptive frame deletion detection for digital video forensics[J], IEEE Transactions on Circuits and Systems for Video Technology, 2016, 27(12):2543–2554.\n\n[15] Averbuch-Elor, Hadar, Cohen-Or, Daniel, Kopf, Johannes. Bringing portraits to life[J]. ACM Transactions on Graphics, 2017, 36(6) :1-13.\n\n[16] Kim Hyeongwoo, Theobalt Christian, Carrido Pablo. Deep video portraits[J]. ACM Transactions on Graphics, 2018, 37(4):1-14.\n\n[17] Zhou H, Liu Y, Liu Z, et al. Talking Face Generation by Adversarially Disentangled Audio-Visual Representation[J]. Proceedings of the AAAI Conference on Artificial Intelligence, 2019, 33:9299-9306.\n\n[18] Fried, O., Tewari, A., Zollh, Zollhöfer M et al. Text-Based Editing of Talking-Head Video[J]. ACM Trans. Graph. 38(4), 2019: 1-14.\n\n[19] Supasorn Suwajanakorn, Steven M. Seitz. Synthesizing Obama: learning lip sync from audio[M]. ACM, 2017.\n\n[20]Lee J W, Lee M J, Lee H Y, et al. Screenshot identification by analysis of directional inequality of interlaced video[J]. Eurasip Journal on Image & Video Processing, 2012, (1):1-15.\n\n[21] Bestagini P, Visentini-Scarzanella M, Tagliasacchi M, et al. Video recapture detection based on ghosting artifact analysis[C]//Image Processing (ICIP), 2013 20th IEEE International Conference on. IEEE, 2013: 4457-4461.\n\n[22] Rolland-Neviere, X., Chupeau, B., Doerr, G., et al. (2012) Forensic Characterization of Camcorded Movies: Digital Cinema vs. Celluloid Film Prints[C]//Proceedings of SPIE—The International Society for Optical Engineering, Burlin-game, 9 February 2012, 83030R-83030R-11.\n\n[23] Mahdian B, Novozamsky A, Saic S. Identification of aliasing-based patterns in re-captured LCD screens[C]//Image Processing (ICIP), 2015 IEEE International Conference on. IEEE, 2015: 616-620.\n\n[24] Visentini-Scarzanella M, Dragotti P L. Video jitter analysis for automatic bootleg detection[C]//Multimedia Signal Processing (MMSP), 2012 IEEE 14th International Workshop on. IEEE, 2012: 101-106.\n\n[25] Thongkamwitoon T, Muammar H, Dragotti P L. An image recapture detection algorithm based on learning dictionaries of edge profiles[J]. Information Forensics and Security, IEEE Transactions on, 2015, 10(5): 953-968.\n\n[26] Anjum, A., Islam, S. Recapture detection technique based on edge-types by analysing high-frequency components in digital images acquired through LCD screens[J]. Multimed Tools Appl, 2020,79: 6965–6985.\n\n[27] Chao J, Jiang X, Sun T. A novel video inter-frame forgery model detection scheme based on optical flow consistency[C]//International Workshop on Digital Watermarking. Springer, Berlin, Heidelberg, 2012: 267-281.\n\n[28] Wu Y, Jiang X, Sun T, et al. Exposing video inter-frame forgery based on velocity field consistency[C]//2014 IEEE international conference on acoustics, speech and signal processing (ICASSP). IEEE, 2014: 2674-2678.\n\n[29] Qiang XU, Xinghao Jiang, Tanfeng Sun*, Alex C. Kot, Detection of transcoded HEVC videos based on in-loop filtering and PU partitioning analyses[J], Signal Processing: Image Communication, 2021, 92:116109.\n\n[30] He P, Sun T, Jiang X, et al. Double compression detection in MPEG-4 videos based on block artifact measurement with variation of prediction footprint[C]// International Conference on Intelligent Computing. Springer. 2015: 787–793.\n\n[31] He P, Jiang X, Sun T, et al. Detection of double compression in MPEG-4 videos based on block artifact measurement[J]. Neurocomputing, 2017, 228: 84–96.\n\n[32] Yao Y, Yang G, Sun X, et al. Detecting video frame-rate up-conversion based on periodic properties of edge-intensity[J]. Journal of Information Security and Applications, 2016, 26: 39–50.\n\n[33] Bian S, Luo W, Huang J. Detecting video frame-rate up-conversion based on periodic properties of inter-frame similarity[J]. Multimedia tools and applications, 2014, 72(1): 437–451.\n\n[34] Vazquezpadin D, Fontani M, Bianchi T, et al. Detection of video double encoding with GOP size estimation[C]// IEEE International Workshop on Information Forensics and Security (WIFS), 2012:151-156.\n\n[35] Vazquez-Padin D, Fontani M, Shullani D, et al. Video Integrity Verification and GOP Size Estimation Via Generalized Variation of Prediction Footprint[J]. IEEE transactions on information forensics and security, 2020, (15):1815-1830.\n\n[36] Li, Q., Wang, R. and Xu, D., Detection of double compression in HEVC videos based on TU size and quantized DCT coefficients[J]. IET Inf. Secur., 2019, (13): 1-6.\n\n[37] Yao H., Ni R., Zhao Y., Double compression detection for H.264 videos with adaptive GOP structure. Multimedia Tools and Applications, 2020, (79):5789-5806.\n\n[38] Yu Y , Yao H , Ni R , et al. Detection of fake high definition for HEVC videos based on prediction mode feature[J]. Signal processing, 2020, 166(Jan.):107269.1-107269.11.\n\n[39] X.H, Jiang, Q. Xu, T.F. Sun, Bin Li, Peisong He, Detection of HEVC double compression with the same coding parameters based on analysis of intra coding quality degradation process[J]. IEEE Transactions on Information Forensics and Security, 2019, (15): 250-263.\n\n[40] He P, Jiang X, Sun T, et al. Frame-wise detection of relocated I-frames in double compressed H.264 videos based on convolutional neural network[J]. Journal of Visual Communication and Image Representation, 2017, (48): 149-158.\n\n[41 Xu Q, Jiang X, Sun T, et al. Relocated I-Frames Detection in H. 264 Double Compressed Videos Based on Genetic-CNN[C]. in: 2018 Asia-Pacifc Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC). 2018: 710-716.\n\n[42] He P, Li H, Li B, et al. Exposing Fake Bitrate Videos Using Hybrid Deep-learning Network from Recompression Error[J]. IEEE Transactions on Circuits and Systems for Video Technology, 2019, (99):1-13.\n\n[43] Gan Y, Yang J, Lai W. Video object forgery detection algorithm based on VGG-11 convolutional neural network[C]//2019 International Conference on Intelligent Computing, Automation and Systems (ICICAS). IEEE, 2019: 575-580.\n\n\n> 本文转自公众号【隐者联盟】[【极简综述17】数字图像处理操作取证](https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485053&idx=1&sn=b658496c5826472b5cea4183ede69759)、[【极简综述18】数字图像篡改操作取证](https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485053&idx=2&sn=afbec76ac6f61518c50b6a040eb33fac)、[【极简综述19】数字视频再编辑篡改及被动取证检测技术综述](https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485207&idx=1&sn=c2be18dc1badc7c8731a91c0f926d55b)\n\n","source":"_posts/03 图像和视频篡改检测Manipulation Detection综述.md","raw":"---\ntitle: 图像和视频篡改检测Manipulation Detection综述\ntag:\n  - 论文阅读\n  - 图像篡改\ncategories:\n  - [论文阅读, 图像篡改]\narticle_type: 1\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: true\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\nmathjax: false\nabbrlink: 6473c150\ndate: 2021-10-28\ntop:\n---\n- 数字图像篡改操作取证(Tamper )\n\t- Copy-move操作取证技术\n\t- Inpainting操作取证技术\n\t- Splicing操作取证技术\n- 数字图像处理操作取证(Manipulation)\n\t- JPEG重压缩取证技术\n\t- 增强操作取证技术\n\t- 几何操作取证技术\n\t- 操作链取证技术\n- 视频编辑篡改检测\n\t- 数字视频再编辑篡改技术\n\t- 数字视频被动取证检测技术\n\n<!-- more -->\n\n## 数字图像篡改操作取证(**Tamper** )\n\n### Copy-move操作取证技术\n\n图像复制粘贴篡改（copy-move）是数字图像篡改中比较常用的一种手段。它把单个图像中的部分区域复制并粘贴到同一图像中不交叠的其它区域，从而增加或覆盖掉某些物体。为了使篡改后的图像能够以假乱真，在复制过程中，复制区域可能会经历旋转、缩放等几何变换，并且合成图像可能经历加噪、模糊、压缩等后期处理，这进一步加大了篡改检测的难度。现有的图像复制篡改检测方法可以粗略的分为**基于图像块的方法**、**基于关键点的方法**和**基于深度学习的方法**。\n\n#### 基于图像块的方法\n\nFridrich等人[1]首次定义了复制粘贴篡改，并提出了**基于块匹配**的检测方法，将图像分割成固定大小且相互重叠的子块，并使用DCT量化系数作为图像块的特征描述。该算法对图像块的所有DCT系数都进行统计计算，所以算法的复杂度很高。\n\n后来，多位学者分别**提出了DWT变换、FWT变换等用于描述图像块的特征**。Bashar等人[2]提出了两个鲁棒的特征，分别基于DWT变换和KPCA，并将这些特征向量构成一个矩阵。Cozzolino等人[3]提出了CHT作为图像的特征。该方法将图像中的每一个像素点都进行处理，提取到每一个像素点的特征。为了减少计算量，使用了快速的近似最近邻搜索算法对密集区域处进行高效的计算。\n\n除了频率域的特征提取，**基于空间域**的特征提取也有很多经典的算法，其中将矩阵特征作为图像的特征进行处理就是经常使用的方法。Mahdian和Saic[4]较早提出了一种**基于模糊矩阵**的方法，并使用了主成分分析减少特征的维数，最后利用k-d树对多维的数据块进行相似性分析，从而对篡改区域进行定位。Ryu等人[5]则将**Zernike矩阵**作为图像块的特征，并在**图像块匹配时使用了局部敏感哈希算法**加速匹配过程，最终根据匹配块寻找篡改区域。\n\n除了使用矩阵特征以外，也有研究者利用图像本身的一些**纹理亮度信息作为图像的特征**。Davarzani等人[6]采用多分辨率局部二值模式（MLBP）作为图像块的特征信息。为了获得精确的匹配信息，还使用了**RANSAC算法**去除掉错误的匹配。\n\n基于图像块的检测算法虽然能达到一定的效果，但是随着图像复制粘贴篡改的多样化，以及实际图像复制篡改过程中经历更多几何变换如旋转、缩放等，基于图像块的检测方法的鲁棒性会降低。此外，基于图像块的方法需要大量的计算，难以在实际中进行应用。为了提高检测效率，增强对抗几何变换的鲁棒性，基于关键点匹配的检测方法成了新的研究热点。\n\n#### 基于关键点的方法\n\n基于关键点的检测方法计算效率高且有较强的鲁棒性，适用于实际情况下的多类型图像复制粘贴篡改检测，因此研究者也致力于用基于关键点的检测方法来解决各种图像复制粘贴篡改检测的问题。\n\n**该类方法首先从整幅图像中提取关键点，然后对其进行特征描述提取和匹配过程，最后通过得到关键点匹配进行后续处理从而定位复制粘贴篡改区域。**\n\nHuang等人[7]**采用SIFT作为图像关键点检测与特征描述**的方法，并使用**Best Bin First算法**来寻找相似的特征向量，进而确定匹配关键点的位置。此后很多学者也提出了基于SIFT特征的检测方法，Pan和Lyu[8]使用了**RANSAC算法**来计算复制粘贴区域之间的仿射变换关系。Amerini等人[9]基于2NN准则提出了**新的匹配方法G2NN**以应对多重复制粘贴的情形。除了SIFT以外，研究者还提出了其它一系列的优秀算法。Xu等人[10]**使用SURF作为提取图像关键点特征的方法**。相比SIFT，SURF运算比较简单，计算效率更高。此外，Yang等人[11]**采用了SIFT和KAZE的融合**作为提取关键点特征的方法。\n\n针对复杂的复制粘贴篡改检测以及定位的精确度的问题，有研究者提出了更为系统的检测框架。Ardizzone等人[12]利用**提取的SIFT特征点来构建Delaunay 划分，然后利用每个三角形块的颜色信息和角度信息作为三角形区域的特征向量进行匹配**。Li等人[13]首先使用 **SLIC算法对图像进行分割成一系列的超像素块**，根据分割块内关键点匹配对的数量处理匹配块，提升了处理的效率。Zandi等人[14]通过自适应迭代的方法，根据每个迭代周期的结果迭代地调整关键点的分布还有匹配过程以及仿射变换矩阵计算。Li等人[15]通过降低关键点提取时的阈值，使得小区域、平滑区域可以提取足量的关键点，并且提出了一种**新的层次匹配策略来解决大量关键点匹配问题**。和基于块匹配的检测方法相比，基于关键点匹配的方法避免了全局搜索，大大提高了检测效率，且对几何变换具有更好的鲁棒性。\n\n#### 基于深度学习的方法\n\n随着深度学习尤其是卷积神经网络的发展，研究者开始尝试使用深度学习的方法进行图像复制粘贴篡改的检测。Wu等人[16]设计了**端到端的BusterNet**，采取双分支结构，对图像操作和图像相似性进行检测，具有一定的效果，可以同时识别源区域和目标区域。Chen等人[17]提出一种**串行分支网络模型**，包含**相似性检测网络CMSDNet和源与目标鉴别网络STRDNet**。STRDNet研究CMSDNet获得的相似块的分类问题，相对于BusterNet的分支更加简单且准确率更高。\n\nBarni等人[18]提出了多分支网络DisTool对图像复制篡改进行检测并识别源区域和目标区域，分别为两个Siamese组成的4-Twins Net分支和一个Siamese分支。该网络在真实的测试场景中也表现良好。Zhong等人[19]提出了**基于Dense-InceptionNet**的检测方案，充分使用了多尺度的信息和稠密特征链接，设计了**金字塔特征提取器，特征相关匹配和层次后处理模块**。**该算法对几何变换操作和JPEG压缩都有一定的鲁棒性**。\n\n### Inpainting操作取证技术\n\n图像修复(inpainting)技术是数字图像篡改中比较常用的一种手段，它的核心思想是根据图像受损区域周围的已知像素信息通过插值相邻像素对未知区域进行修复[20]。目前，传统的图像inpainting算法可以分成两类：**基于块的方法和基于扩散的方法。**\n\n- 基于块的方法主要是通过搜索图像已知区域的图像块，寻找合适的候选块对受损区域进行填补以达到修复的目的；\n\n- 基于扩散的方法通常是通过求解偏微分方程或者依据扩散系统将图像信息从边界传播扩散到未知区域进行修复。\n\n\n当恶意篡改者使用图像inpainting技术进行篡改并将这类图像应用于司法、科学等领域时，将会造成不可预料的严重影响。现有的针对图像inpainting的**检测方法**大致可以分为两类：**基于传统手工特征的方法和基于深度学习的方法。**\n\n#### 基于传统手工特征的方法\n\n最初，Wu等人[21]在2008年提出了一种**基于零连通特征和模糊隶属度**的检测方法。首先对图像中的块进行零连通标记，筛选可疑区域，然后通过计算模糊隶属度识别可疑区域内的修复块，并通过割集实现最终的修复篡改区域的定位。\n\n2013年，Bacchuwar等人[22]提出了一种可以同时检测图像修复和图像复制-粘贴两种篡改的方法。该方法**利用图像的亮度分量，对可疑区域中的块进行中值匹配**，引入“跳跃块”，从而有序检测篡改区域。它相较于文献[21]加速了修复区域的定位，但仍需要人工选择区域。\n\n为减少最佳匹配块的搜索时间，Chang等人[23]通过检测关键值进行相似度检测，提出了一种**基于权值变换的搜索算法**，包括可疑区域检测和篡改区域识别两个阶段。Liang等人[24]首先**采用中心像素映射搜索**可疑块对，在装载因子和搜索范围方面加速了对可疑块的搜索，使用最大零连通性区域标记和片段拼接检测技术实现篡改区域的定位。\n\n申林川等人[25]对已有的图像修复检测方法进行改进，**利用一种hash映射函数将图片三维的颜色信息转换成一维的hash值映射至哈希表**，再结合相似向量滤波和基于质心的篡改区域定位技术，实现篡改区域最终的准确定位。\n\n另外，JPEG是目前网络中使用最广泛的图像格式。Zhao等人[26]针对JPEG图像展开研究，**通过计算和分割不同质量因子下的修复图像和再保存JPEG图像的绝对差值之和检测出被篡改的区域**，不需要任何手动操作。\n\nLiu等人[27]也聚焦于JPEG图像，**提出了一种大规模特征挖掘的经验方法，包含边缘密度和联合密度特征**，采用集成学习，有效地检测了包括图像修复在内的复合攻击下的图像篡改，特别是在重压缩质量低于原始JPEG图像质量的情况下，显著提高了检测精度。\n\nLi等人[28]针对**基于扩散的修复方法进行区域检测，发现修复区域和未修复区域图像沿垂直于梯度方向的拉普拉斯变换是不同的**。基于此，根据通道内和通道间的局部变化方差构造了一个特征集。最后，设计了两个有效的后处理操作来进一步细化定位结果。但该方法鲁棒性较差，特别是对经过JPEG压缩后处理的图像取证性能显著下降。\n\n刘婷婷等人[29]**提出了一种梯度域导向滤波增强的图像扩散修复检测算法**。该算法对输入图像的各个颜色通道分别进行梯度域导向滤波增强，从多角度捕捉图像修复带来的影响，以实现图像扩散修复区域的定位。\n\n基于传统手工特征的图像inpainting检测算法在一些方面存在一定的局限性，比如**需要手动选择区域、只针对特定的图像inpainting技术、鲁棒性较差**等。近年来为提高检测效率，增强算法对抗几何变换的鲁棒性，基于深度学习的图像inpainting检测算法也在不断发展。\n\n#### 基于深度学习的方法\n\n随着深度学习的发展，研究人员开始尝试使用深度学习方法实现图像修复检测。\n\n2018年，Zhu等人[30]提出了一种基于深度神经网络的图像inpainting篡改检测技术，通过神经网络自动提取篡改痕迹，实现图像像素级的预测并对修复区域进行定位。**该框架在编码器-解码器的全卷积网络结构基础上还引入了特征金字塔网络对特征图进行信息补充**，填充图像的语义信息，且具有一定的泛化性。进一步地，Zhu等人[31]提出了新的网络框架，并构建了类标签矩阵，设计了加权交叉熵解决图像像素不平衡的问题。该方法考虑了JPEG压缩和缩放等后处理操作，具有一定的鲁棒性。\n\nWang等人[32]在2019年提出了一种**基于Faster R-CNN网络的图像inpainting篡改检测方法**，并**自制**了在两种深度学习图像修复算法下的**数据集**，实现了修复区域的边界框定位。但该方法只能得到标记有置信度分数的边界框，无法得到修复篡改区域的真实区域，定位精度有待进一步提高。\n\nLu等人[33]提出了一种**基于LSTM-CNN的图像目标去除方法**，利用CNN搜索异常相似块，提高了搜索的速度和准确性，利用LSTM网络消除虚警补丁对检测结果的影响，降低虚警率。\n\nLi等人[34]探究发现在像素域中修复图像块和未修复图像块的转移概率值相似，而在残差域中表现出明显的差异，修复图像块包含较少的高频分量。因此，作者**设计了HP-FCN网络，利用高通滤波模块对输入图像进行预处理，将其残差图输送到基于CNN的特征提取模块中，再通过上采样模块采样到输入图像大小，最终得到像素预测的定位图。**该算法对深度学习下的修复数据集进行定位检测，且进一步考虑了随机修复和现实情况下的真实数据集，在准确率上都取得了较好的效果，具有一定的鲁棒性。\n\n为了提高已有算法对不可见图像修复方法的检测性能，Wu等人[35]提出了一种新型的**端到端图像修复检测网络IID-Net，其中NAS算法用于设计适当的网络架构，并结合新提出的注意模块来进一步优化潜在特征。**该算法在特定深度修复方法上训练的取证模型对其他修复方法具有良好的通用性检测能力。作者还基于10种不同的修复方法构建了一个**包含10K张图片的不同修复测试数据集**，每种修复方法提供1000张图片，作为一个公共可访问的数据集，用于修复检测方法的标准化比较。\n\n### Splicing操作取证技术\n\n**图像拼接(splicing)**伪造不同于复制-粘贴伪造，它是将一个或多个源图像的区域复制粘贴到目标图像上得到篡改图像。图像拼接伪造检测与定位可以看作是一个全局二值分类问题，通过比较不同图像区域之间的特征来检测定位篡改区域。现有的图像拼接伪造检测方法大致可以归纳为四类：**基于模糊类型不一致性的方法**，**基于噪声水平不一致性的方法**，**基于光照不一致性的方法**和**基于深度学习的方法**。\n\n#### 基于模糊类型不一致性的方法\n\n2011年，Kakar等人[36]提出了一种**利用运动模糊差异性检测图像拼接**的新方法。通过对图像梯度的运动模糊水平的估计，检测拼接区域和原始区域之间的不一致性。作者还开发了一种新的方法，可以较好地对包含运动模糊的图像进行不一致性区域分割。\n\n为了适应不同范围的模糊程度，Bahrami等人[37] 提出了一种基于**图像模糊度和深度信息不一致性的图像拼接检测框架**。首先估计图像块的模糊核，再利用分步模糊技术测量局部模糊核的相对模糊度。基于此，对不同模糊程度的图像块进行分类。\n\nRao等人[38]考虑手持摄像机中运动模糊现象这一特定场景，提出了一种**以模糊为线索的被动图像拼接检测方法**。离焦模糊也是图像拼接检测中的一种常用特征，然而纹理、光场、噪声等都会在一定范围内影响自然边缘的离焦模糊信息，导致边缘离焦模糊估计不一致。\n\nSong等人[39]分析了图像拼接边缘和自然边缘的离焦模糊特征的差异性，提出了**一种新的基于离焦模糊差的自然图像拼接检测方法**。当伪造者使用一些后处理操作来掩盖拼接痕迹时，图像拼接问题是一个具有挑战性的问题。\n\n为进一步解决这个问题，Bahrami等人[40]在2015年提出了一种**基于局部模糊类型不一致性的模糊图像拼接定位框架**。作者首先对图像进行分块，根据局部模糊核提取局部模糊类型检测特征用于离焦模糊和运动模糊的划分，从而生成模糊类型不变区域。最后，采用精细拼接定位方法提高区域边界的精度。\n\n#### 基于噪声水平不一致性的方法\n\n大多数图像在采集或后续处理过程中都会引入一定的噪声，而自然图像和具有不同来源的拼接图像中的噪声会存在不同程度的差异性。研究人员根据噪声的不一致性提出了相应的图像拼接检测算法。\n\nMahdian等人[41]将待测图像分割成不同噪声水平的分区，**利用基于中值的方法计算每个图像块的噪声标准差**，通过一个阈值确定图像拼接篡改区域。\n\nLyu等人[42]利用了自然图像在带通域内峰度的特殊规律以及噪声特征与峰度之间的关系。**将噪声统计量的估计表述为一个具有封闭解的优化问题**，并进一步推广到一种有效的局部噪声统计量估计方法。通过揭示局部噪声水平的不一致性来检测拼接区域。\n\n研究人员发现可以通过主成分分析(PCA)来估计图像的噪声水平。其中，2015年，Zhan等人[43]在主成分分析的基础上，根据不同的局部噪声方差，**对待测图进行均匀噪声的区域分割**，实现篡改区域的定位。Zeng等人[44]发现当拼接区域与原始区域噪声差较小时，一些基于噪声的图像拼接定位算法性能不佳。作者采用基于主成分分析的算法对图像进行分块噪声水平估计，**通过k-means聚类从原始区域分割出篡改区域**。Yao等人[45]通过探讨噪声水平函数(NLF)与相机相应函数(CRF)之间的关系，拟合了CRF约束下的NLF曲线，**建立了一个贝叶斯最大后验(MAP)框架来优化NLF估计**，并开发了一种基于不同来源图像块噪声水平不一致性的图像拼接检测方法。Liu等人[46]针对多目标拼接伪造场景，**利用噪声水平函数(NLF)估计图像噪声与像素强度之间的关系，从而检测可疑篡改区域**。2018年，Nan等人[47]提出一种新的噪声水平函数的图像拼接检测方法。作者首先将图像分成不重叠的块，将每个块的噪声方差拟合到锐利度下，**通过计算图像块到拟合曲线的最小距离区分篡改区域**。\n\n#### 基于光照不一致性的方法\n\n一般来说，使用不同设备拍摄的图像会存在光照不一致性。基于此特性，Liu等人[48]在2011年提出了一种基于阴影亮度不一致性的图像拼接篡改检测框架。**该框架首先提取图像中的阴影边界和半阴影区域**，估计阴影的遮罩值来衡量其颜色特征。但当合成阴影和实际目标阴影一致时，该算法失效。Ke等人[49]对此提出改进，提出了基于阴影一致性的篡改图像检测方法。通过提取阴影区域和非阴影区域的纹理特征，**利用相关函数来度量两种纹理特征的相似性。通过比较相似度，实现图像拼接篡改的检测。**\n\n#### 基于深度学习的方法\n\n- Xiao等人[50]提出了一种由粗到精的两阶段检测网络(**C2RNet**)和稀释自适应聚类两部分组成的拼接伪造检测方法，从不同尺度的图像块中学习图像属性的差异。\n- Bappy等人[51]提出了一种**利用空间域的编码器-解码器结构网络和频域的长短期记忆(LSTM)网络的双域检测方法**。该网络利用更大的接受域和频域相关性，通过结合编码器和LSTM网络来分析篡改区域和非篡改区域之间的区别特征。最后使用解码器实现像素级预测图像篡改定位。\n- 进一步地，Wu等人[52]将伪造定位问题定义为局部异常检测问题，**设计了Z-score特征来捕获局部异常，并提出了一种新的检测网络结构(Mantra-net)来评估局部异常**。\n- Bi等人[53]采用图像分割的思想，设计了一种用于图像拼接伪造检测的环形残差U-Net (RRU-Net)，**利用残差传播和残差反馈使得未篡改区域和篡改区域**之间的图像属性差异更加明显。\n- Zhou等人[54]针对目前常见的几类局部篡改操作，**结合传统特征提出了一个双流Faster R-CNN网络**。不仅实现了篡改操作类型识别，更进一步地能够定位到篡改区域，在图像拼接伪造检测方面也具有比较好的性能。\n\n目前，图像拼接伪造检测和定位问题出现了一种新的定义：给定一幅探针图像Q和一幅潜在的供体图像P。检测供体图像的区域是否已拼接到探针图像中，如果已拼接到探针图像，则提供两个掩码，指示拼接到探针中的供体图像区域和从供体图像中拼接的图像区域。这一新问题将图像拼接检测约束为一对图像，相关研究人员将其称为约束图像拼接检测问题。针对这一问题，Wu等人[55]提出了一种开拓性的CISDL方法，设计了一种新的深度卷积神经网络结构—**深度匹配与验证网络(DMVN)**。Ye等人[56]在继承DMVN深度密集匹配层的基础上，提出了**特征金字塔深度匹配与定位方法网络(FPLN)**。Liu等人[57]提出了**一种面向CISDL新的对抗性学习框架的深度匹配网络(DMAC)**，用于生成两个高质量候选掩模，基于检测网络纠正候选掩模之间的不一致，并**基于判别网络生成与真实篡改区域接近的掩模，检测网络与判别网络以对抗学习方式协同监督DMAC**训练。\n\n### **小结与思考**\n\n目前，除了上述图像篡改操作的取证，removal、seam carving等篡改操作的取证研究也吸引了国内外学者的广泛关注，并取得了一些阶段性成果。尤其是近年来，以卷积神经网络为代表的深度学习技术在图像篡改操作取证领域取得了突出的性能，但仍存在一些问题有待进一步研究。\n\n（1）篡改者在使用copy-move，inpainting或者splicing操作对图像语义进行恶意篡改后，通常会使用一些后处理操作或者反取证技术掩盖操作的篡改痕迹，如何设计对不同后处理操作和反取证技术鲁棒的篡改操作取证模型是值得进一步探索的方向。\n\n（2）针对inpainting操作检测问题，大多数取证方法都基于修复区域与未修复区域的块匹配原理，检测效率较低。如何在保证定位准确率的前提下，加快区域匹配速率是一个待解决的问题。\n\n### 参考文献\n\n[1]J. Fridrich, D. Soukal, and J. Lukas. Detection of copy-move forgery in digital images. Proceedings of Digital Forensic Research Workshop (DFRWS), Cleveland, OH, USA, 2003.\n\n[2]M. Bashar, K. Noda, N. Ohnishi, and K. Mori. Exploring duplicated regions in natural images. IEEE Transactions on Image Processing, DOI: 10.1109/TIP.2010.2046599, 2010.\n\n[3]D. Cozzolino, G. Poggi, and L. Verdoliva. Efficient dense¬field copy–move forgery detection. IEEE Transactions on Information Forensics and Security, vol. 10, no. 11, pp. 2284-2297, 2015.\n\n[4]B. Mahdian, and S. Saic. Detection of copy–move forgery using a method based on blur moment in-variants,.Forensic Science International, vol. 171, no. 2, pp. 180-189, 2017.\n\n[5]S. -J. Ryu, M. Kirchner, M. -J. Lee, and H. K. Lee. Rotation invariant localization of duplicated image regions based on zernike moments. IEEE Transactions on Information Forensics and Security, vol. 8, no. 8, pp. 1355-1370, 2013.\n\n[6]R. Davarzani, K. Yaghmaie, S. Mozaffari, and M.Tapak. Copy¬-move forgery detection using multiresolution local binary patterns. Forensic Science International, vol. 231, no. 1, pp. 61-72, 2013.\n\n[7]H. Huang, W. Guo, and Y. Zhang. Detection of copy-move forgery in digital images using sift algorithm. IEEE Pacific-Asia Workshop on Computational Intelligence and Industrial Application (PACIIA), Wuhan, China, pp. 272–276, 2008.\n\n[8]X. Pan, and S. Lyu. Region duplication detection using image feature matching. IEEE Transactions on Information Forensics and Security, vol. 5, no. 4, pp. 857-867, 2010.\n\n[9]I. Amerini, L. Ballan, R. Caldelli, A.D. Bimbo, and G. Serra. A sift-based forensic method for copy-move attack detection and transformation recovery. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1099-1110, 2011.\n\n[10]B. Xu, J. Wang, G. Liu, H. Li, and Y. Dai. Image copy-move forgery detection based on surf. International Conference on Multimedia Information Networking and Security (MINES), Nanjing, China, pp. 889-892, 2010.\n\n[11]F. Yang, J. Li, W. Lu, and J. Weng. Copy¬-move forgery detection based on hybrid features. Engineering Applications of Artificial Intelligence, vol. 59, pp. 73-83, 2017.\n\n[12]E. Ardizzone, A. Bruno, and G. Mazzola. Copy move forgery detection by matching triangles of keypoints. IEEE Transactions on Information Forensics and Security, vol. 10, no. 10, pp. 2084-2094, 2015.\n\n[13]J. Li, X. Li, B. Yang, and X. Sun. Segmentation¬ based image copy¬-move forgery detection scheme. IEEE Transactions on Information Forensics and Security, vol. 10, no. 3, pp. 507-518, 2015.\n\n[14]M. Zandi, A. M.-Aznaveh and A. Talebpour. Iterative copy-¬move forgery detection based on a new interest point detector. IEEE Transactions on Information Forensics and Security, vol. 11, no. 11, pp. 2499-2512, 2016.\n\n[15]Y. Li, and J. Zhou. Fast and effective image copy¬-move forgery detection via hierarchical feature point matching. IEEE Transactions on Information Forensics and Security, vol. 14, no. 5, pp. 1307-1322, 2019.\n\n[16]Y. Wu, W. A.-Almageed, and P. Natarajan. BusterNet: Detecting copy-move image forgery with source/target localization. Proceedings of the European Conference on Computer Vision (ECCV), Munich, Germany, pp.170-186, 2018.\n\n[17]B. Chen, W. Tan, G. Coatrieux, Y. Zheng, and Y. Q. Shi. A serial image copy-move forgery localization scheme with source/target distinguishment. IEEE Transactions on Multimedia, DOI: 10.1109/TMM.2020.3026868, 2020.\n\n[18]M. Barni, Q. -T. Phan, and B. Tondi. Copy move source-target disambiguation through multi-branch CNNs. IEEE Transactions on Information Forensics and Security, vol. 16, pp. 1825-1840, 2021.\n\n[19]J. Zhong, and C. Pun. An end-to-end Dense-InceptionNet for image copy-move forgery detection. IEEE Transactions on Information Forensics and Security, vol. 15, pp. 2134-2146, 2020.\n\n[20]A. Criminisi, P. Perez, and K. Toyama. Region filling and object removal by exemplar-based image inpainting. IEEE Transactions on Image Processing, vol. 13, no. 9, pp. 1200-1212, 2004.\n\n[21]Q. Wu, S. Sun, W. Zhu, G. Li, and D. Tu. Detection of digital doctoring in exemplar-based inpainted images. International Conference on Machine Learning and Cybernetics (ICMLC), Kunming, China, pp. 1222–1226, 2008.\n\n[22]K. S. Bacchuwar, Aakashdeep, and K. R. Ramakrishnan. A jump patch-block match algorithm for multiple forgery detection. International Mutli-Conference on Automation, Computing, Communication, Control and Compressed Sensing (iMac4s), Kottayam, India, pp. 723-728, 2013.\n\n[23]I. Chang, J. Yu, and C. Chang. A forgery detection algorithm for exemplar-based inpainting images using multi-region relation. Image and vision computing, vol. 31, no. 1, pp. 57-71, 2013.\n\n[24]Z. Liang, G. Yang, X. Ding, and L. Li. An efficient forgery detection algorithm for object removal by exemplar-based image inpainting. Journal of Visual Communication and Image Representation, vol. 30, pp. 75-85, 2015.\n\n[25]L. Shen, G. Yang, L. Li, X. Sun. Robust detection for object removal by exemplar-based image inpainting with post-processing. International Conference on Natural Computation, Fuzzy Systems and Knowledge Discovery (FSKD), Guilin, China, pp. 2730-2736, 2017.\n\n[26]Y. Zhao, M. Liao, F. Y. Shih, and Y. Q. Shic. Tampered region detection of inpainting JPEG images. Optik, vol. 124, no. 16, pp. 2487-2492, 2013.\n\n[27]Q. Liu, A. H. Sung, B. Zhou, and M. Qiao. Exposing inpainting forgery in JPEG images under recompression attacks. IEEE International Conference on Machine Learning and Applications (ICMLA), Anaheim, CA, USA, pp. 164-169, 2016.\n\n[28]H. Li, W. Luo, and J. Huang. Localization of diffusion-based inpainting in digital images. IEEE transactions on information forensics and security, vol. 12, no. 12, pp. 3050-3064, 2017.\n\n[29]刘婷婷, 张玉金, 吴飞等. 基于梯度域导向滤波增强的图像扩散修复取证[J]. 激光与光电子学进展, 2020, vol. 57, no. 8, pp. 35-42.\n\n[30]朱新山, 钱永军, 孙彪等. 基于深度神经网络的图像修复取证算法[J]. 光学学报, 2018, vol. 38, no. 11, pp. 97-105.\n\n[31]X. Zhu, Y. Qian, X. Zhao, B. Sun, and Y. Sun. A deep learning approach to patch-based image inpainting forensics. Signal Processing: Image Communication, vol. 67, pp. 90–99, 2018.\n\n[32]X. Wang, H. Wang, and S. Niu. An image forensic method for AI inpainting using faster R-CNN. International Conference on Artificial Intelligence and Security (ICAIS), New York, USA, pp. 476-487, 2019.\n\n[33]M. Lu, and S. Niu. A detection approach using LSTM-CNN for object removal caused by exemplar-based image inpainting. Electronics, vol. 9, pp. 858, 2020.\n\n[34]H. Li, and J. Huang. Localization of deep inpainting using high-pass fully convolutional network. IEEE International Conference on Computer Vision (ICCV), Seoul, South Korea, pp. 8301-8310, 2019.\n\n[35]H. Wu, and J. Zhou. IID-Net: image inpainting detection network via neural architecture search and attention. IEEE Transactions on Circuits and Systems for Video Technology, DOI: 10.1109/TCSVT.2021.3075039, 2021.\n\n[36]P. Kakar, N. Sudha, and W. Ser. Exposing digital image forgeries by detecting discrepancies in motion blur. IEEE Transactions on Multimedia, vol. 13, no. 3, pp. 443-452, 2011.\n\n[37]K. Bahrami, A. C. Kot, and J. Fan. Splicing detection in out-of-focus blurred images. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 144-149, 2013.\n\n[38]M. P. Rao, A. N. Rajagopalan, and G. Seetharaman. Harnessing motion blur to unveil splicing. IEEE Transactions on Information Forensics and Security, vol. 9, no. 4, pp. 583-595, 2014.\n\n[39]C. Song, and X. Lin. Natural image splicing detection based on defocus blur at edges. IEEE/CIC International Conference on Communications in China (ICCC), Shanghai, China, pp. 225-230, 2014.\n\n[40]K. Bahrami, A. C. Kot, L. Li, and H. Li. Blurred image splicing localization by exposing blur type inconsistency. IEEE Transactions on Information Forensics and Security, vol. 10, no. 5, pp. 999-1009, 2015.\n\n[41]B. Mahdian, and S. Saic. Using noise inconsistencies for blind image forensics. Image and Vision Computing, vol. 27, no. 10, pp. 1497-1503, 2009.\n\n[42]S. Lyu, X. Pan, and X. Zhang. Exposing region splicing forgeries with blind local noise estimation. International Journal of Computer Vision, vol. 110, no. 2, pp. 202–221, 2014.\n\n[43]L. Zhan, and Y. Zhu. Passive forensics for image splicing based on PCA noise estimation. International Conference for Internet Technology and Secured Transactions (ICITST), London, UK, pp. 78-83, 2015.\n\n[44]H. Zeng, Y. Zhan, X. Kang, and X. Lin. Image splicing localization using PCA-based noise level estimation. Multimedia Tools and Applications, vol. 76, no. 4, pp. 4783–4799, 2017.\n\n[45]H. Yao, S. Wang, X. Zhang, C. Qin, and J. Wang. Detecting image splicing based on noise level inconsistency. Multimedia Tools and Applications, vol. 76, no. 10, pp. 12457–12479, 2017.\n\n[46]B. Liu, and C. Pun. Multi-object splicing forgery detection using noise level difference. IEEE Conference on Dependable and Secure Computing (DSC), Taipei, Taiwan, pp. 533-534, 2017.\n\n[47]Z. Nan, and L. Zhao. Blind image splicing detection via noise level function. Signal Processing: Image Communication, vol. 69, pp. 181-192, 2018.\n\n[48]Q. Liu, X. Cao, C. Deng, and X. Guo. Identifying image composites through shadow matte consistency. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1111-1122, 2011.\n\n[49]Y. Ke, F. Qin, W. Min, and G. Zhang. Exposing image forgery by detecting consistency of shadow. The scientific world journal, vol. 2014, no. 3, pp. 1-9, 2014.\n\n[50]B. Xiao, Y. Wei, X. Bi, W. Li, and J. Ma. Image splicing forgery detection combining coarse to refined convolutional neural network and adaptive clustering. Information Sciences, vol. 511, pp. 172–191, 2020.\n\n[51]J. H. Bappy, C. Simons, L. Nataraj, B. S. Manjunath, and A. K. Roy-Chowdhury. Hybrid LSTM and encoder-decoder architecture for detection of image forgeries. IEEE Transactions on Image Processing, vol. 28, no. 7, pp. 3286-3300, 2019.\n\n[52]Y. Wu, W. AbdAlmageed, and P. Natarajan. ManTra-Net: manipulation tracing network for detection and localization of image forgeries with anomalous features. IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), Long Beach, CA, USA, pp. 9535-9544, 2019.\n\n[53]X. Bi, Y. Wei, B. Xiao, and W. Li. RRU-Net: the ringed residual U-Net for image splicing forgery detection. IEEE/CVF Conference on Computer Vision and Pattern Recognition Workshops (CVPRW), Long Beach, CA, USA, pp. 30-39, 2019.\n\n[54]P. Zhou, X. Han, V. I. Morariu, and L. S. Davis. Learning rich features for image manipulation detection. IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), Salt Lake, USA pp. 1053-1061, 2018.\n\n[55]Y. Wu, W. Abd-Almageed, and P. Natarajan. Deep matching and validation network: An end-to-end solution to constrained image splicing localization and detection. ACM international conference on Multimedia (MM), Mountain View, CA, USA, pp. 1480–1502, 2017.\n\n[56]K. Ye, J. Dong, W. Wang, B. Peng, and T. Tan. Feature pyramid deep matching and localization network for image forensics. Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC), Honolulu, Hawaii, USA, pp. 1796–1802, 2018.\n\n[57]Y. Liu, X. Zhu, X. Zhao, and Y. Cao. Adversarial learning for constrained image splicing detection and localization based on atrous convolution. IEEE Transactions on Information Forensics and Security, vol. 14, no. 10, pp. 2551-2566, 2019.\n\n## 数字图像处理操作取证(Manipulation)\n\n### JPEG重压缩取证技术\n\n篡改图像必然会经过重压缩这一步骤，因此数字图像重压缩检测能够为数字图像取证提供强有力的辅助依据。目前，使用最广泛的图像压缩标准是JPEG，若原始的图像是JPEG格式，篡改后的图像为达到不易于检测的效果，同样会保存为JPEG格式，则图像会进行两次JPEG压缩。现如今JPEG重压缩取证包含两个主要研究课题，一是**JPEG重压缩检测**，二是**对JPEG重压缩区域进行定位**。\n\n#### JPEG重压缩检测\n\nJPEG压缩属于有损压缩，每次压缩都会丢失一部分信息，由于JPEG重压缩对图像数据进行了两次量化操作，引入了一些单次JPEG压缩所没有的特征，因此通过一定的统计检测可以发现图像是否经历过JPEG重压缩。\n\n现今的重压缩检测算法大多遵循一个检测模式，第一步是从图像中**找到能最大化单次压缩和双重压缩类间差异的特征**；第二步则是在得到特征后，基于数据驱动训练分类器，**用于识别和分类双重压缩和单次压缩**。\n\n- 比如，Shang等人[1]**以DCT系数**矩阵水平、垂直、对角、反对角方向差分的高阶马尔科夫转移概率作为特征，用SVM和EC分类器分类实现JPEG重压缩图像检测。\n- Zeng等人[2]提出了一种改进的密集连接的**卷积网络（DenseNet）**来完成双压缩图像中主JPEG压缩的检测任务。他们在网络的前端加入了一个特殊的滤波层，该层通常包含选定的滤波和，可以帮助后续网络更容易地识别图像。\n- Wang等人[3]提出了**一种基于四元数离散余弦变换（QDCT）域的改进马尔可夫压缩检测算法**。首先，对给定JPEG图像的颜色信息提取图像构造四元数；然后，构造图像块QDCT系数矩阵，包括振幅和三个角；接着，在相应的细化过程中，由转移概率矩阵生成细化的马尔可夫特征；最后，使用支持向量机（SVM）方法进行NA-DJPEG压缩检测。然而这些统计模型大多关注变换域系数本身，忽略了JPEG压缩给变换域系数引入的相关性，使得当后压缩质量因子远小于前压缩质量因子时，难以判定双重压缩的存在性。\n\n此外，**为了更进一步获取重压缩痕迹，首次压缩时的量化步长估计**是非常关键的问题。\n\n- Galvan等人[4]首先使用直方图滤波除去二次量化以外操作引入的直方图噪声，然后使用一个新的估计方程来估计第一次量化使用的量化步长。该方法在实际应用中可以更准确估计量化步长。然而当后压缩质量因子较小时，大量图像数据会被破坏乃至丢弃，使得这类方法检测效果不佳。\n- 此外，Thai等人[5]**将量化效应和DCT系数统计相结合**，对先前压缩并存储为无损的图像进行量化步长的估计。\n\n#### JPEG重压缩定位\n\n一些研究将JPEG重压缩检测和篡改区域定位相结合。\n\n- Yang等人[6]先提取相同频率的量化DCT系数，建立新的数据矩阵，然后考虑方向对DCT域相邻位置相关性的影响，执行12种不同方向的高通滤波模板，计算每个滤波数据的平移概率矩阵。然后利用PCA和SVM分别对特征维数进行降维和分类器训练，以此确定图像是否被篡改。\n- Wang等人[7]利用Laplacian分布来描述在拼接区域和原图像的DCT系数分布，通过估计DCT块的后验概率来确定被篡改区域。\n- Amerini等人[8]使用卷积神经网络（CNN）实现了JPEG重压缩的篡改定位。\n- Zhou等人[9]使用一种双通道的快速R-CNN网络，并对其进行端到端的训练，对图像进行篡改检测。双通道之一是**RGB流**，其目的是从RGB图像输入中提取特征，以发现篡改特征，如强烈的对比度差、非自然的篡改边界等。**另一种是利用隐写分析丰富模型滤波层提取的噪声特征**，发现真实区域和篡改区域之间的噪声不一致。然后，通过双线性池化层融合来自两种流的特征，进一步合并这两种模式的检测结果。\n\n除JPEG压缩外，已经有一些学者研究更为一般的情况，估计图像可能经受过的各种变换和压缩。\n\n- Tagliasacchi等人[10]给出了一个**一般估计使用的图像变换技术和量化步长的方法**。\n- Bianchi等人[11]**给出了一个判定信号是否经历过格量化的最优检测子**，进而将该检测方法应用于实际的场景，并判断图像是否经历过双重JPEG压缩。**但该方法要求两次压缩使用的块划分必须相同**。\n\n### 增强操作取证技术\n\n在现实生活中，经常会遇到数码设备由于光线、环境以及设备自身性能的问题而得到不清晰的图像，导致无法辨识原始图像中的关键目标，需要对图像进行增强处理。图像增强指通过某些图像处理操作，如对比度增强、中值滤波、锐化、模糊等，对原始图像附加一些信息或变换数据，有目的地突出图像中某些“有用”信息或者抑制掩盖图像中某些“无用”信息，扩大图像中不同物体特征之间的差别，以改善图像的视觉效果，丰富信息量。**然而，图像增强操作可以淡化隐藏其他篡改操作的痕迹，达到降低篡改检测性能的目的。**目前，**图像增强操作取证**研究已经吸引了国内外学者的广泛关注，并取得了一些阶段性成果。\n\n####  对比度增强取证\n\n对比度增强是一种被广泛使用的图像增强处理技术，是对图像中每个像素点的值进行非线性映射，通过累积函数对灰度值进行调整，改变图像中像素强度的整体分布，最终达到对比度的增强效果。\n\n- Stamm等人[12]利用像素值映射在图像直方图上的统计特征，通过观察对比度增强操作向图像直方图的高频成分添加的能量信息，**检测对比度增强操作**。\n- Cao等人[13]提出了零波谷特征，即当图像经过对比度增强操作处理后，图像直方图能呈现出明显的波峰波谷，并且生成的波谷都是值为0的零波谷。利用零波谷特征，基于阈值化二类分类检测对比度增强操作。\n- Zhang等人[14]提出一种深度多路径网络，基于灰度直方图，通过共享多个卷积层捕获图像底层特征，并利用由多条路径组成的特定操作层学习不同对比度增强操作的特征，最后通过聚合层对原始图像和对比度增强操作处理的图像进行分类。\n- 王金伟等人[15]提出一种基于线性模型的图像对比度增强检测算法，提取图像噪声残差，采取分块策略计算每块残差的线性模型，并计算相应的功率谱密度，以整幅图像的均值功率谱密度作为分类特征，利用支持向量机进行分类。\n\n#### 模糊取证\n\n为了消除图像篡改在拼接边缘产生的视觉或统计上的畸变，通常会在图像篡改后使用模糊操作消除简单拼接留下的伪造痕迹。模糊操作的基本原理是对图像的局部邻近像素值进行邻域灰度平均。\n\n- 周琳娜等人[16]提出一种基于图像形态学滤波边缘特征的模糊操作取证方法，用同态滤波和形态学滤波增强模糊操作的图像边缘，利用离焦模糊和人工模糊的边缘特性，**检测伪造图像的模糊操作痕迹**。\n- Su等人[17]提出一种三维模糊识别方法，将图像划分为非模糊区、离焦模糊区和运动模糊区，利用梯度信息预测不同类型的模糊区域，并采用超像素分割技术对模糊区域进行细化识别。\n- Xu等人[18]提出几种新的局部模糊度量方法，使用不同类型的图像信息，包括颜色、梯度和光谱信息，基于支持向量机，构造最优模糊检测分类器。\n\n#### 中值滤波取证\n\n中值滤波操作是一种高度非线性操作，由于其良好的平滑滤波性质，通常被用于反取证技术中[19-20]，使得中值滤波取证越来越受到关注。\n\n- Kirchner等人[21]利用图像差分转移概率矩阵构造特征，检测图像是否经过中值滤波操作处理。\n- Kang等人[22]利用中值滤波残差特征，将特征相邻元素之间的关系建模为自回归模型，利用自回归系数检测中值滤波。\n- 彭安杰等人[23]提出一种基于中值滤波残差及其差分的鲁棒中值滤波取证技术，根据方向性和对称性将多方向差分特征分组，分别建立自回归模型，并提取其模型参数和直方图特征，组合成中值滤波检测特征。\n\n#### 锐化取证\n\n锐化滤波常用于增强图像的局部对比度，使边缘和文理等细节变得更加清晰锐利。同样，作为常用的图像润饰操作，锐化经常被用于削弱掩盖图像篡改时遗留的痕迹。\n\n- Cao等人[24]提出了一种有效的过冲效应测度方法，进而提取有效的指纹特征，通过阈值化分类来鉴别图像是否经历过USM锐化操作。\n- Ding等人[25]提出一种基于局部二值模式LBP的锐化检测方法，采用Canny算子进行边缘检测，将LBP应用于图像检测到的边缘像素并提取特征，基于支持向量机进行锐化分类。\n- F. Ding等人[26]利用图像USM锐化引起的纹理变化，提出一种边缘垂直二值编码的USM锐化检测方法。\n\n### **几何操作取证技术**\n\n当一幅图像被篡改时，例如拷贝一副图像的某一区域覆盖到被篡改图像中，篡改者通常需要**采取缩放、旋转等几何变换来掩盖篡改痕迹**。而这一过程需要对图像重新采样和重构，因此图像重采样检测是数字图像取证中十分重要的研究课题。重采样取证主要包含两个主要的研究目标，第一是**判断图像是否经过重采样的重采样检测**，第二是**估计重采样操作过程中施加于图像上的相关参数，如重采样因子、旋转角度**等。\n\n#### 缩放取证\n\n缩放操作是最常见的几何操作，常见于篡改图像后，调整篡改区域的大小以适配图像内容。然而在实际情况中，受限于网络传输速度与机器存储容量，篡改图像在缩放前后很可能会经历JPEG压缩。\n\n因此，涉及缩放操作的重采样取证有两大类研究方向，第一是针对无JPEG压缩的单一重采样取证场景；第二是和JPEG压缩操作相结合的复合取证场景，根据JPEG压缩出现的顺序，该场景可细分为三种复合取证场景，即Pre-JPEG重采样**（JPEG格式缩放后保存为无损格式）**、Post-JPEG重采样**（无损格式缩放后保存为JPEG格式）**和Double-JPEG重采样**（JPEG格式缩放后保存为JPEG格式）**三种情况。\n\n针对无JPEG压缩的单一重采样取证场景，重采样图像中每一个像素都由原始像素与插值函数卷积而成，且像素之间隐藏着重采样痕迹。由于插值的影响，这种重采样痕迹反映在空域上体现为像素之间存在相关性[27]，且相邻插值像素的间隔存在一种周期性；反映在频域上体现为存在频谱峰值，且峰值位置与放缩因子有关[28]。鉴于重采样操作的这些特点，近年来专家学者们提出了许多重采样检测算法，虽然这些算法的思路各异，但是大体都遵循一个流程。首先，从待检测图像中通过某种方式提取出残差信号，这种残差信号放大了重采样痕迹，剔除噪音与视觉信息，显性的揭露出重采样操作遗留下的周期性。根据所采用的数学模型不同，这种残差信号可以通过计算图像的二阶差分获得[29]，也可以通过快速滤波计算出插值像素得到相应的概率图[30]。在得到蕴含周期性的残差信号后，第二步就是根据这种信号判别重采样操作的存在，最常用的手段是频谱方法，通过对残差信号进行傅里叶变换，由于周期函数傅里叶变换的特殊性，重采样图像的频谱图上会出现与放缩因子有关的频谱峰值[28]，这些峰值可以作为重采样操作存在的证据，更进一步，根据峰值与放缩因子的关系估计出相应的放缩因子。除此之外，可以将第一步得到的残差信号视为手工设计的特征，作为输入训练一个强有力的分类器，通过数据驱动学习一个重采样判别模型[31]。更进一步，可以借鉴深度学习在图像检测领域的发展，提出用于重采样检测和因子估计的深度网络[32-35]。\n\n然而上述方法无法直接运用于与JPEG压缩操作相结合的复合取证场景，这是因为JPEG压缩通过分块将图像保存并复原，使得JPEG图像像素之间先天就带有周期性，当与放缩操作结合时，会混淆放缩操作带来的周期性，最终形成复合的周期，使得现有的重采样图像检测算法失效。\n\n- 针对Pre-JPEG重采样的情况，Liu等人[36]基于自相关函数构建了重采样图像的数学模型，他们通过该模型推导出了重采样系数、插值函数和重采样谱峰位置的关系，他们提出了基于图像差分极值点距离直方图的方法，通过挖掘图像差分的规律来取证重采样操作和进行因子估计。而后，他们还提出了针对Post-JPEG重采样图像的取证方案[37]，他们基于循环平稳信号分析发现Post-JPEG重采样图像上会出现一系列的对称谐波峰，并提出一种基于相位抵消的图像重采样检测和因子估计方法。\n- 除此之外，Lu等人[38]还提出了基于反缩放策略的双域联合估计算法，从频谱域和DCT域综合估计重采样因子，他们首先通过搜索匹配从Double-JPEG图像频谱中提取数个可能的候选因子，然后根据DCT域系数的独立同分布模型，使用反缩放策略得到最优估计。\n\n#### 旋转取证\n\n旋转操作也是常见的几何操作之一，同样涉及到图像像素重采样，在空域和频域上的操作痕迹与缩放操作有许多共通之处。\n\n- Wei等人将旋转操作视为一种特殊的缩放操作[39]，将旋转角度与特定的缩放因子结合在一起，通过频谱峰值与缩放因子的关系推导出图像经历的旋转角度，不仅如此，他们发现不同的频谱提取操作顺序可以更加明显的突出重采样峰值特征，有利于进一步区分旋转操作和缩放操作，并在此基础上提出了只包含旋转和缩放的二次几何变换操作链恢复算法。\n- 此后，Chen等人[40]提出对图像连续几何变换的取证方法，他们基于平方信号分析图像重采样特征，将Gallagher的理论推广到连续二次几何变换领域，揭示了二次几何变换的频谱特征，并提出了更细粒度的只包含旋转和缩放的二次几何变换操作链恢复算法。随后，他们根据二维自相关函数，提出了针对旋转缩放等仿射变换的参数估计方案[41]。\n\n###  操作链取证技术\n\n实际的图像处理过程可能包含多个操作，它们按照一定的顺序共同构成图像操作链。当图像经历多种操作处理时，不同操作遗留在图像中的痕迹可能相互叠加和覆盖，从而导致某个操作的遗留痕迹被掩盖或者破坏。同时，痕迹间的相互影响与操作的执行顺序有关，当操作顺序发生变化时，最终的遗留痕迹也会有所不同。因此，由于多个操作之间的相互影响，针对单个篡改操作的取证方法难以满足图像操作链取证的实际需求。**为了完整地揭示数字图像可能经历的处理过程，需要明确图像操作链包含的操作类型，多个操作的拓扑顺序，以及处理操作的关键参数。目前，图像操作链取证研究可以粗略的分为基于传统手工特征的方法和基于深度学习的方法。**\n\n#### 基于传统手工特征的方法\n\n- 西班牙维戈大学P. Comesaña于2012年最先提出操作链取证[42]。他从理论上分析了利用已有的单操作篡改取证算法检测图像操作链的可能性,并以量化和加性高斯白噪声组成的操作链为例进行了实验验证。随后, 他还进一步实验分析了包含更多操作的操作链拓扑结构[43]。\n- Stamm [44]等人针对对比度增强与缩放组成的二元操作链取证，提出采用直方图缺值特征和图像预测误差评价，分别进行对比度增强和图像缩放的检测，并引入了条件指纹的概念，用以单独识别对比度增强先于缩放操作的操作顺序。\n- Li [45]等人针对内容感知缩放和对比度增强组成的二元操作链取证，提出了通过计算马尔科夫一步转移概率矩阵以及提取DCT域的高维特征进行检测的方法。\n- Chu [46]等人从信息论的角度分析了操作顺序检测的可能性以及最优检测阈值的选取问题。\n- Gao等人[47]将操作可检测性问题转换为复杂假设检验问题，提出一种基于信息理论框架的图像操作链中特定操作的检测方案。\n- Chen等人[48]提出了一种基于决策融合的图像操作链中操作类型识别方法，挖掘不同图像特征，获取不同的取证证据。基于可信度计算策略，重新分配各证据权重，并通过决策融合识别操作链中包含的操作类型。\n- Liao等人[49]从操作相关性程度分析入手，开展操作链的参数估计研究。通过探究操作顺序和参数变化对生成图像及已有参数估计特征所带来的影响，将操作链中各操作间相关性分为耦合与非耦合，并设计了不同的参数估计策略。\n\n#### 基于深度学习的方法\n\n- Boroumand等人[50]针对特定二元操作链，通过**在卷积神经网络结构中添加全局平均池化层**, 实现对任意尺寸篡改图像的操作种类鉴别。\n- Stamm等人[51]基于设计的CNN约束分类器, **通过联合提取与操作序列相关的条件指纹特征**, 实现了对特定二元操作序列的种类识别和顺序鉴定。\n- Chen等人[52]设计了一个自动化的神经网络，通**过强化学习生成高性能的神经网络，用于多目标取证和处理历史检测。**同时，利用基于模块的搜索空间，通过密集连接，提升网络设计效率。\n- Liao等人[53]提出了**基于双流卷积神经网络的图像操作链取证框架**，并设计了多个针对特定操作组合的预处理。该网络包括空域卷积流和变换特征提取流，利用空域卷积流提取可视篡改特征，而变换特征提取流则通过结合针对性设计的预处理从图像的变换域提取残差特征。\n\n### **小结与思考**\n\n图像处理操作取证是多媒体安全领域中的热点问题，除了上述处理操作的取证，小波去噪、直方图均衡化、仿射变换等图像处理操作的取证也都受到了政治、经济、社会文化等多个领域的广泛关注。尽管图像处理取证技术已经在特定篡改操作的取证等方面取得了阶段性进展，但在研究的深度和广度上仍未成熟，还有一些亟待解决的问题，主要表现在：\n\n1. 在已知图像处理操作的情况下，可以通过模拟操作来训练模型，但对未知操作，如何设计对不同强度、不同操作组合均有效的取证模型是值得进一步探索的方向。\n2. 当图像经历多种处理操作编辑润饰时，**不同操作的痕迹相互掩盖混淆**，图像处理操作取证变得困难。大多**数图像处理操作取证方法是对单个特定操作或者特定二元操作链检测有效**，**缺乏适用于各种图像处理操作链取证**的通用理论基础。\n\n### 参考文献\n\n[1]S. Shang, Y. Zhao, and R. Ni. Double JPEG detection using high order statistic features. IEEE International Conference on Digital Signal Processing (DSP), Beijing, China, pp. 550-554, 2016.\n\n[2]X. Zeng, G. Feng, and X. Zhang. Detection of double JPEG compression using modified DenseNet model. Multimedia Tools and Applications, vol. 78, no. 7, pp. 8183-8196, 2019.\n\n[3]J. Wang, W. Huang, X. Luo, Y.-Q. Shi, and S. Kr. Jha. Non-aligned double JPEG compression detection based on refined Markov features in QDCT domain. Journal of Real-time Image Processing, vol. 17, no. 1, pp.7-16, 2019.\n\n[4]F. Galvan, G. Puglisi, A. R. Bruna, and S. Battiato. First quantization matrix estimation from double compressed JPEG images. IEEE Transactions on Information Forensics and Security, vol. 9, no. 8, pp. 1299-1310, 2014.\n\n[5]T. Hai Thai, R. Cogranne, F. Retraint, and T. Doan. JPEG quantization step estimation and its applications to digital image forensics. IEEE Transactions on Information Forensics and Security, vol. 12, no. 1, pp. 123-133, 2017.\n\n[6]P. Yang, R. Ni, and Y. Zhao. Double JPEG compression detection by exploring the correlations in DCT domain. Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC), Honolulu, HI, USA, pp. 728-732, 2018.\n\n[7]W. Wang, J. Dong, and T. Tan. Exploring DCT coefficient quantization effects for local tampering detection. IEEE Transactions on Information Forensics and Security, vol. 9, no. 10, pp. 1653-1666, 2014.\n\n[8]I. Amerini, T. Uricchio, L. Ballan, and R. Caldelli. Localization of JPEG double compression through multi-domain convolutional neural networks. IEEE Conference on Computer Vision and Pattern Recognition Workshops (CVPRW), Honolulu, HI, USA, pp. 1865-1871, 2017.\n\n[9]P. Zhou, X. Han, V. I. Morariu, and L. S. Davis. Learning Rich Features for Image Manipulation Detection. IEEE Conference on Computer Vision and Pattern Recognition (CVPR), Salt Lake City, UT, USA, pp. 1053-1061, 2018.\n\n[10]M. Tagliasacchi, M. V.-Scarzanella, P. L. Dragotti, and S. Tubaro. Transform coder identification. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Vancouver, BC, Canada pp. 5785-5789, 2013.\n\n[11]T. Bianchi, A. Piva, and F. Pérez-González. Near optimal detection of quantized signals and application to JPEG forensics. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 168-173, 2013.\n\n[12]M. C. Stamm, and K. J. Ray Liu. Forensic detection of image manipulation using statistical intrinsic fingerprints. IEEE Transactions on Information Forensics and Security, vol. 5, no. 3, pp. 492-506, 2010.\n\n[13]G. Cao, Y. Zhao, R. Ni, and X. Li. Contrast enhancement-based forensics in digital images. IEEE Transactions on Information Forensics and Security, vol. 9, no. 3, pp. 515-525, 2014.\n\n[14]C. Zhang, D. Du, L. Ke, H. Qi, and S. Lyu. Global contrast enhancement detection via deep multi-path network. International Conference on Pattern Recognition (ICPR), Beijing, China, pp. 2815-2820, 2018.\n\n[15]王金伟, 吴国静. 基于线性模型的图像对比度增强取证[J]. 网络空间安全, 2019, vol. 10, no. 8, pp. 47-54.\n\n[16]周琳娜, 王东明, 郭云彪, 杨义先. 基于数字图像边缘特性的形态学滤波取证技术[J]. 电子学报, 2008, vol. 36, no. 6, pp. 1047-1051.\n\n[17]B. Su, S. Lu, and C. L. Tan. Blurred image region detection and classification. ACM International Conference on Multimedia (ACM MM), New York, NY, USA, pp. 1397-1400, 2011.\n\n[18]W. Xu, J. Mulligan, D. Xu, and X. Chen. Detecting and classifying blurred image regions. IEEE International Conference on Multimedia and Expo (ICME), San Jose, CA, USA, 2013.\n\n[19]M. Kirchner, and R. Bohme. Hiding traces of resampling in digital images. IEEE Transactions on Information Forensics and Security, vol. 3, no. 4, pp. 582-592, 2008.\n\n[20]M. C. Stamm, and K. J. Ray Liu. Anti-forensic of digital image compression. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1050-1065, 2011.\n\n[21]M. Kirchner, and J. Fridrich. On detection of median filtering in digital images. The SPIE-Media Forensics and Security, San Jose, USA, pp. 754110-1-75411012, 2010.\n\n[22]X. Kang, M. C. Stamm, A. Peng, and K. J. Ray Liu. Robust median filtering forensics using an autoregressive model. IEEE Transactions on Information Forensics and Security, vol. 8, no. 9, pp. 1456-1468, 2013.\n\n[23]彭安杰, 康显桂. 基于滤波残差多方向差分的中值滤波取证技术[J]. 计算机学报, 2016. vol. 39, no. 3, pp. 503-515.\n\n[24]G. Cao, Y. Zhao, R. Ni, and A. C. Kot. Unsharp masking sharpening detection via overshoot artifacts analysis. IEEE Signal Processing Letters, vol. 18, no. 10, pp. 603-606, 2011.\n\n[25]F. Ding, G. Zhu, and Y. Q. Shi. A novel method for detecting image sharpening based on local binary pattern. International Conference on Digital Forensics and Watermarking (IWDW), Berlin, Germany, pp. 180-191, 2013.\n\n[26]F. Ding, G. Zhu, J. Yang, J. Xie, and Y. Q. Shi. Edge perpendicular binary coding for USM sharpening detection. IEEE Signal Processing Letters, vol. 22, no. 3, pp. 327-331, 2015.\n\n[27]A. C. Popescu, and H. Farid. Exposing digital forgeries by detecting traces of resampling. IEEE Transactions on Signal Processing, vol. 53, no. 2, pp. 758-767, 2005.\n\n[28]A. C. Gallagher. Detection of linear and cubic interpolation in JPEG compressed images. Canadian Conference on Computer and Robot Vision (CRV), Victoria, BC, Canada, pp. 65-72, 2005.\n\n[29]B. Mahdian, and S. Saic. Blind authentication using periodic properties of interpolation. IEEE Transactions on Information Forensics and Security, vol. 3, no. 3, pp. 529-538, 2008.\n\n[30]M. Kirchner. Fast and reliable resampling detection by spectral analysis of fixed linear predictor residue. ACM Workshop on Multimedia and Security (MM & Sec), Oxford, UK, pp. 11-20, 2008.\n\n[31]X. Feng, I. J. Cox, and D. Gwenaël. Normalized energy density-based forensic detection of resampled images. IEEE Transactions on Multimedia, vol. 14, no. 3, pp. 536-545, 2012.\n\n[32]B. Bayar, and M. C. Stamm. On the robustness of constrained convolutional neural networks to JPEG post-compression for image resampling detection. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), New Orleans, LA, USA, pp. 2152-2156, 2017.\n\n[33]B. Bayar, and M. C. Stamm. Constrained convolutional neural networks: A new approach towards general purpose image manipulation detection. IEEE Transactions on Information Forensics and Security, vol. 13, no. 11, pp. 2691–2706, 2018.\n\n[34]C. Liu, and M. Kirchner. CNN-based rescaling factor estimation. ACM Workshop, pp. 119–124, 2019.\n\n[35]S. Luo, J. Luo, W. Lu, Y. Fang, J. Zeng, S. Shi, and Y. Zhang. Resampling factor estimation via dual-stream convolutional neural network. Computers, Materials & Continua, vol. 66, no. 1, pp. 647–657, 2021.\n\n[36]X. Liu, W. Lu, Q. Zhang, J. Huang, and Y. Shi. Downscaling factor estimation on pre-JPEG compressed images. IEEE Transactions on Circuits and Systems for Video Technology, vol. 30, no. 3, pp. 618-631, 2019.\n\n[37]Q. Zhang, W. Lu, T. Huang, S. Luo, Z. Xu, and Y. Mao. On the robustness of JPEG post-compression to resampling factor estimation. Signal Processing, vol. 168, pp. 107371, 2020.\n\n[38]W. Lu, Q. Zhang, S. Luo, Y. Zhou, J. Huang, and Y. Q. Shi. Robust estimation of upscaling factor on double JPEG compressed images. IEEE Transactions on Cybernetics, pp. 1-13, 2021.\n\n[39]W. Wei, S. Wang, X. Zhang, and Z. Tang. Estimation of image rotation angle using interpolation-related spectral signatures with application to blind detection of image forgery. IEEE Transaction on Information Forensics and Security, vol. 5, no. 3, pp. 507-517, 2010.\n\n[40]C. Chen, J. Ni, Z. Shen, and Y.Q. Shi. Blind forensics of successive geometric transformations in digital images using spectral method: theory and applications. IEEE Transactions on Image Processing, vol. 26, no. 6, pp. 2811-2824, 2017.\n\n[41]J. Ou, and J. Ni. Blind estimation of affine transformation using 2D cyclostationarity of resampled images. Mippr: Multispectral Image Acquisition, Processing, & Analysis International Society for Optics and Photonics, 2015.\n\n[42]P. Comesaña. Detection information theoretic measures for quantifying the distinguishability between multimedia operator chains. IEEE International Workshop on Information Forensics and Security (WIFS), Tenerife, Spain, pp. 211-216, 2012.\n\n[43]P. Comesaña, and F. P. González. Multimedia operator chain topology and ordering estimation based on detection and information theoretic tools. International Conference on Digital Forensics and Watermarking (IWDW), Berlin, Germany, pp. 213-227, 2013.\n\n[44]M. C. Stamm, X. Chu, and K. J. Ray Liu. Forensically determining the order of signal processing operations. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 162-167, 2013.\n\n[45]J. Li, Y. Zhao, and R. Ni. Detection of seam carving and contrast enhancement operation chain. International Conference on Intelligent Information Hiding and Multimedia Signal Processing (IIH-MMSP), Adelaide, SA, Australia, pp. 235-238, 2015.\n\n[46]X. Chu, Y. Chen, and K. J. Ray Liu. Detectability of the order of operations: An information theoretic approach. IEEE Transactions on Information Forensics and Security, vol. 11, no. 4, pp. 823-836, 2016.\n\n[47]S. Gao, X. Liao, and X. Liu. Real-time detecting one specific tampering operation in multiple operator chains. Journal of Real-Time Image Processing, vol. 16, pp. 741-750, 2019.\n\n[48]J. Chen, X. Liao, and Z. Qing. Identifying tampering operations in image operator chains based on decision fusion. Signal Processing: Image Communication, vol. 95, pp. 116287-1-116287-10, 2021.\n\n[49]X. Liao, and Z. Huang. A framework for parameters estimation of image operator chain. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Barcelona, Spain, pp. 2787-2791, 2020.\n\n[50]M. Boroumand, and J. Fridrich. Deep learning for detecting processing history of images. Electronic Imaging, pp. 213-1-213-9, 2018.\n\n[51]B. Bayar, and M. C. Stamm. Towards order of processing operations detection in JPEG-compressed images with convolutional neural networks. Electronic Imaging, pp. 211-1-211-9, 2018.\n\n[52]Y. Chen, Z. Wang, Z. J. Wang, and X. Kang. Automated design of neural network architectures with reinforcement learning for detection of global manipulations. IEEE Journal of Selected Topics in Signal Processing, vol. 14, no. 5, pp. 997-1011, 2020.\n\n[53]X. Liao, K. Li, X. Zhu, and K. J. Ray Liu. Robust detection of image operator chain with two-stream convolutional neural network. IEEE Journal of Selected Topics in Signal Processing, vol. 14, no. 5, pp. 955-968, 2020.\n\n## 视频编辑篡改检测Video manipulation Detetion综述\n\n从公开发表论文数量来看，目前绝大多数的篡改被动检测算法都是专用篡改检测算法，且效果十分显著，但需要已知篡改方法和类型的先验知识.通用篡改检测算法针对多种或未知篡改检测准确率良好但也具有一定局限性，实用性和泛化能力有待提高，且对篡改类型的辨识能力不足，只能判断是否经历了篡改操作；**针对多类型+多次篡改的溯源篡改操作链识别能力有限，这也是未来可能的研究方向之一。**\n\n**通用篡改检测算法**的最大优势就是快速筛选可疑视频和辨识经历一次及以上篡改的数字视频，然后再用专用算法探测或穷举识别其可能的篡改操作类型或者溯源篡改操作链。总而言之，两者技术是互补关系。\n\n###  数字视频再编辑篡改技术\n\n数字视频编辑篡改技术的一般定义：为了视频画面提质、传输、存储，或改变内容内在关系的后编辑操作的技术集合。这一后编辑操作可能是常规的需求，也可能是恶意的目的。目前，本文中将常见的数字视频编辑篡改技术分为**四大类**：\n\n1. 数字视频**文件再编辑**的篡改方法：本文是指针对数字视频的码流、或者编码参数、容器等的编辑，达到对原始视频文件的再编辑目的，一般不改变视频内容。例**如，码率重采样、视频格式转码、容器转换、各种滤波器操作等后处理操作**；\n2. 数字视频**内容再编辑**的篡改方法：本文是指针对数字视频的部分解码或完全解码后内容进行内容级编辑操作，达到对原始视频内容的再编辑目的。例如，**视频帧间插入/删除攻击、帧内复制粘贴攻击操作**等；\n3. 数字视频**内容生成**的篡改方法：本文是指**针对数字视频内容的部分生成替换**或全部生成虚拟目标全局替换，进行视频内容级编辑操作，达到对原始视频内容的再编辑目的。例如，使用StyleGAN网络生成虚拟人物或目标的视频内容等操作；\n4. 数字视频的**重拍摄篡改**方法：本文是指针对数字视频内容的重新数字采集再编辑操作，达到对原始视频内容的再编辑目的。例如，**利用数字设备对屏幕画面进行重新拍摄和再编辑操作**。\n\n#### 视频文件再编辑篡改\n\n视频文件再编辑篡改是指在不改变视频内容的前提下对视频文件的编辑操作，比如转码操作、分辨率提升/降低、平滑操作、锐化操作、去噪操作、信息隐藏操作等。\n\n例如，数据隐藏技术可以在不影响视觉效果的前提下，向视频内嵌入信息，实现对视频文件的编辑。例如，北京交通大学的李赵红[4]等人研究了P帧种各尺寸PU划分类型在隐写前后的数目变化，构建了25维和3维特征用来检测HEVC视频的块划分模式隐写算法。帧率变化是通过提升或下降视频的帧率方法来达到编辑视频文件的目的。Khoubani[5]等人基于模糊平滑的快速四元数小波运动补偿进行帧率上转换。这篇论文使用图像序列的相位来考虑QWT运动估计，实现了更准确的运动估计、更少的后处理流程和更低的复杂度。码率变换是另外一种视频文件编辑的方法，Kevin[6]等人提出一种通过求解优化问题来选择比特率的方法即Bola算法。Yin等人[7]提出了MPC算法。Kim[8]等人结合残差学习方式提出了IFCNN网络，用以取代视频编码中的环路滤波算法，即把未经环路滤波的重建图像直接输入网络进行增强处理。\n\n#### 数字视频内容编辑篡改方法\n\n视频内容篡改是指部分解码或全解码后，针对音频、图象、视频中特定对象的操作过程，其结果是改变内容的原始属性，导致内容的不可信。从视频帧目标被攻击角度来看，数字视频内容编辑篡改分为**帧间编辑篡改和帧内编辑篡改**。\n\n视频的帧间编辑篡改方式主要有：帧删除篡改，即删除原始视频的至少一帧或连续多帧的操作；帧插入篡改，即非同源视频的帧片段插入到原视频帧序列中的操作；帧复制粘贴篡改，即同源视频的帧片段在相同视频中不同时间轴上复制插入到原视频中的操作。\n\n- 针对这类视频内容的帧间编辑篡改问题，2012年孙锬锋等人[9]提出了视频帧间篡改中主要篡改类型的定义，即包括视频帧复制粘贴、帧插入、帧删除等，其中对于帧的复制粘贴，可以划分为同源和异源两类，同源的帧复制表示复制的对象来自于当前视频片段，而异源帧复制粘贴是将其他视频的片段复制到当前视频片段中。\n- 2014年王婉等人[10]根据场景的差异性将视频内容编辑篡改划分为静止背景下的内容编辑篡改以及包含运动背景的篡改场景，并提出了一种可以同时检测帧删除，帧插入及帧复制的算法。\n- 同年柏正尧等人[11]针对帧间篡改对帧间相关性进行研究，并将非负张量分解（Nonnegative tensor factorization, NTF）算法应用到了视频帧间篡改检测中。\n- 冯春晖等人[13]通过分析残差强度在不同宏块间分布是否具有波动性来检测视频是否被帧删除，并定位删除点的位置。该作者在[13]的基础上进一步分析了具有丰富运动信息下的视频帧间篡改场景，考虑到运动视频容易导致帧间数据特征的变化，作者从帧间差异的角度，提出了一种删帧检测算法[14]，对复杂篡改环境下的序列中不同干扰帧进行分析，并利用运动残差特征区分不同干扰帧和删帧位置处的帧，进而提出一种去帧内编码处理算法，使算法能够应对运动信息带来的影响。\n- 不同于视频内容帧间篡改，视频内容帧内篡改并非以帧为单位进行篡改，而是以目标为单位进行编辑篡改操作，2021年Yang Quanxin等人[12] 指出视频帧内篡改主要有空域复制粘贴，帧内目标移除等，作者发现帧内篡改将引起视频在时空域上的高频信息的波动。\n\n#### 数字视频内容生成篡改方法\n\n视频内容生成方法是指在GAN网络及其衍生网络根据对抗原理，即生成器和判别器构成网络，从一幅噪声图像不断逼近真实图象的方法，其生成局部或全部图象和视频并不是真实的物理拍摄获得，从而达到以假乱真的目的。\n\n- 例如，Elor[15]等人的方案可以生成含有人物的视频，并且可以通过扭曲来轻微改变人物的头部姿势。因为这种方法是基于单个目标图像的，它从源视频中的嘴唇内部复制到目标视频，因此仅能部分保留目标视频中的人物身份。\n- Kim[16]等人的做法相对于以前的方法而言，可以生成更为逼真的视频。\n- Zhouhang[17]等人使用音频来生成视频。他们将一个无声的视频分解为两部分，一部分是人物身份信息，另一部分是语音信息，这里的语音信息是指通过人物嘴部动作传递出来的广义语音信息，而非听到的声音。\n- Fried[18]等人基于文本来编辑视频。给定任意文本，该方法就能改变一段视频中人物所说的话，同时保持无缝的试听流。要对一段视频中人物讲话内容进行改变，只需要编辑一下想要表达的文本内容，这种方法十分地简单易行。\n- Suwajanakorn[19]等人对人脸中的口型进行替换，生成最终的伪造视频。\n\n#### 数字视频重拍摄的篡改方法\n\n数字视频重拍摄的篡改方法是指物理上用物理设备对数字视频内容播放进行重拍摄而造成内容时空含义混乱，达到篡改内容的目的，也就是“二次拍摄篡改编辑”。\n\n现有的重拍摄的编辑篡改方法主要根据拍摄设备、拍摄场景以及拍摄对象的差异进行分类[20]。Lee[20]等人提出目前重拍摄视频大部分产生于视频投放到液晶屏幕（LCD）上时被重拍摄，因此该作者重点研究LCD显示的视频重拍摄编辑篡改，提出一种梳状纹理的特征识别其重拍摄操作。P. Bestagini[21]等人提出了同步性不一致的重拍摄编辑篡改，作者利用这种不一致性产生的块重影现象对重拍摄视频进行检测。另外，Xavier [22]等人根据电影被投影时引起屏幕空间上的亮度重分配效应、垂直投影在屏幕上的图像的稳定性效应、高频闪烁的显示屏与摄像机快门之间的相互作用这三种效应设计不同的重拍摄编辑篡改场景。Mahdian[23]等人分析了不同品牌LCD显示屏的重拍摄视频在频谱波纹上的差别。除了针对LCD屏幕的重拍摄，重拍摄编辑篡改还包括以手持摄像机拍摄的视频。此类视频中的运动分为帧内运动和手持引起的全局运动，其中全局运动为手持重拍摄独有的效应。Marco [24]等人提出了具有的全局运动特征的手持拍摄视频编辑篡改。另外，图像重拍摄编辑篡改方面的几个经典场景同样也可以在视频重拍摄上适用。比如Thongkamwitoon[25]针对图像的类别差异构建重拍摄图像集合，通过挖掘彩色图像和黑白图像在色度上的差异引起的重拍摄图像在像素上的失真特性对图像进行重拍摄检验。Anjum等人[26]通过挖掘图像中高层次边缘细节特征，进而根据在原始图像和重拍摄图像中不同组别的边缘像素数量具有一定差异这一特性，构建具有不同边缘特性的重拍摄场景并进行分类。\n\n### 数字视频被动取证检测技术\n\n上述数字视频编辑技术表明了：\n\n1. 数字视频无论是编码复杂性，还是数据量的规模庞大，都给篡改编辑带来了更多的可利用空间和隐藏空间；\n2. 篡改攻击的角度多样性，导致了针对篡改类型的通用识别算法实现具有较大难度。\n\n针对上述篡改编辑类型，对目前已经取得的被动检测成果进行介绍和分析。我们把数字视频篡改被动取证技术**分为三类**：\n\n1. **时空域**特征检测技术。即无论是音频、图象、视频完全解码后，就会是一种结构化或半结构化的媒体原始文件，在原始文件上，可以构建各种物理、几何、光学等的传统数学特征模型，而这些数学模型通常是某种目标特征属性的固定模式、或者连续变化的某种特征数据表征。篡改编辑的过程中会破坏这种上述固定内在模式，引起连续性质的某些突变、或者出现某些特殊非典型痕迹残留分布等情况，而这些情况就可以通过针对时空特征建模方法来加以检测和识别。**代表性算法有光流特征、运动场特征、亮度变化率特征、块效应强度特征等。**\n2. **编码域**特征检测技术。即在数字媒体不完全解码的情况下，码流域、编码域的编码参数、编码域的预测模式、编码域分块模式等环境下，同样具有潜在的首次编码后的系数分布规律和特殊内在统计模式。而这种潜在的分布规律和模式，需要构建高维特征模型，如高阶概率统计模型、多模态融合特征模型等才能洞悉其规律。而且这种高维特征模型对人眼和人耳不可感知的细微编辑痕迹更为敏感。而且编码技术本身也会对数字媒体产生失真效果，因此，对完全解码后媒体数据可能带来意想不到的影响。但是在编码域对篡改痕迹直接展开分析的同时，已经充分考虑了编码失真的影响，在检测过程中可以更加精细化感知各种篡改编辑残留的痕迹。**代表性算法有PU数量统计特征、预测残差分布特征、宏块类型变化特征、DCT系数分布特征**。\n3. **深度**特征检测技术。即无论数字媒体是什么容器格式或者什么编码，首先需要生成大量的篡改样本，把篡改样本进行初步的预处理之后，直接送到深度网络模型中加以学习叠代，直到获得预期稳定的输出，此时深度网络特征模型已经完成了参数训练，此后只需要给定输入就可给出分类结果。当然目前为止，这样简单粗暴的方法效果并不明显。学者们纷纷提出了多样化的**深度网络模型、预处理方法、增加Attention机制、修剪网络无意义的层、增加强化学习的机制**等等。通过深度网络自主学习的能力，学习到人类目前无法感知的特征，增强对篡改数据规律知识的学习，最终能否优于人类设计特征的效果。但是目前为止，大部分的深度网络模型对全局学习的效果不佳。**代表性算法有卷积神经网络、双通道残差网络、遗传卷积网络、混合深度学习网络**。\n\n#### 时空域特征检测技术\n\n在数字视频的拍摄过程中，**相邻帧或像素之间往往存在一定的关联**，而对于视频的篡改往往会破坏这种关联性，因此视频篡改操作往往会在时空与留下痕迹。在现有工作中，时空域的检测算法能够直接对篡改痕迹像素或帧之间的异常特性进行建模，但算法复杂度往往较高。\n\n- 文献[27]中，巢娟等人提出了一种基于光流一致性的帧间篡改检测方法，针对帧插入和帧删除的细微差别，提出了两种不同的检测方案。实验表明，该方案在识别帧插入和帧删除模型方面取得了较好的效果。\n- 在文献[28]中，吴俞醒等人提出了一种基于速度场一致性的视频帧间伪造（连续帧删除和连续帧复制）检测算法。在文献[3]中，许强等人结合GOP结构非对齐的HEVC重编码引起的质量下降特性，通过分析HEVC编码标准中帧间编码对重建像素值的影响，提出基于帧间质量下降机制分析的检测算法，该算法对GOP结构非对齐的重编码检测问题能取得0.98以上的AUC值。\n- 而对于视频转码检测，在[29]中，许强构建了去块滤波模式决策特征以及SAO补偿特征来进行重编码的检测，算法分别在公开数据集上进行了验证，算法能取得97.21%的平均准确率。\n- 在文献[30]、[31]中，何沛松等人将待测视频解码为一连串连续的视频帧后，根据块效应强度变化规律的不同能够对视频双编码视频进行检测。\n- 在文献[32]中，杨高波等人提出了一种基于边缘强度的被动取证方法来检测候选视频中可能的视频帧速率上转换（FRUC）操作。平均检测准确率达94.5%。\n- 在文献[33]中，边山等人在在大量实验的基础上，发现目前大多数视频编辑软件中采用的帧速率上转换算法不可避免地会在生成的视频帧序列的帧间相似性中引入一些周期性的伪影。\n\n综上所述，时空域特征检测技术可以较全面的解决帧间和帧内篡改编辑的被动检测问题，**但仍存在一下问题**：\n\n1. 视频包含快速运动的信息，或者包含场景切换，算法的性能将下降。这个问题是目前被动检测算法中普遍存在的鲁棒性问题，有待改善。\n2. 在重编码比特率较低时检测性能会出现明显下降。这是因为视频重编码时比特率（画面质量）较低，会造成严重的信息失真，与篡改编辑痕迹耦合在一起，造成检测困难。这一问题应该系统研究比特率变化与篡改编辑痕迹变化之间的关系。\n3. 时空特征检测技术基本上都是针对专用篡改编辑而设计的，因此通用性和泛化能力都十分有限。有的算法对复合篡改编辑的方式显得无能为力。这也是未来要解决的重要问题之一。\n\n####  编码域特征检测技术\n\n视频重编码操作是在首次编码的基础上再一次执行编码操作，基于编码域特征统计分析的视频重编码痕迹检测算法实际上就是根据重编码操作对视频编码后的参数扰动关系构建检测依据，依赖手工设计的特征来进行检测的算法。\n\n- 在文献[34]中，DAVID等人提出了基于The Variation of Prediction Footprint（VPF）的二次编码篡改检测算法。\n- 文献[35]中，该团队在MPEG-2标准上提出了一种基于广义VPF（G-VPF）的双编码检测算法，在首次编码使用QP（QP1）大于重编码使用QP（QP2）的情况下达到了98%以上的准确率。\n- 在文献[38]中，赵耀等人通过对预测模式特征（PMF）的分析，提出了一种用于假高清视频场景的重编码检测方案，该方法首先从四个方向的帧内预测模式中提取一个四维特征。其次，从三个预测模式中提取了6维特征。最后，将这两种特征集结合到PMF中，检测出伪造高清视频，并进一步估计其原始QPs和比特率。\n- 在文献[39]中，蒋兴浩等人提出了一种基于帧内预测模式的新方法。文献分析了帧内编码的质量退化机理，并充分考虑了帧内编码的误差来源，建立了等效误差模型，随后提出了基于帧内预测模式统计特征的双HEVC编码检测特征模型。最后，用720p和1080p的HEVC视频代替低分辨率（CIF或QCIF）视频进行了实验。实验结果表明，与现有方法相比，该方法具有更好的效率。此外，该方法对不同的编码配置具有较强的鲁棒性。\n\n综上所述，该类检测算法能有效的检测普通场景下的重编码操作，**但存在一些不足**：\n\n1. 算法过度依赖解码器对参数的提取，并且容易受到反取证手段的攻击。\n2. 当视频包含强运动成分信息或场景切换时，算法性能将下降。\n3. 智能编码技术的兴起，给重编码检测带来了新的危机。\n\n#### 深度特征检测技术\n\n近年来，卷积神经网络（CNN）已经在多媒体取证领域取得成功应用。CNN 能够从训练样本中自动有效地学习层次化的特征表达。受此启发，一系列算法利用卷积神经网络来解决视频重编码痕迹检测问题。\n\n- 在文献[40]中，何沛松等人首先建立视频帧集合，以 3 帧为单位进行分块，若 3 帧中第二帧为重定位I帧，则该片段定义为正样本，否则为负样本。通过这种预处理操作，构建一个卷积神经网络，利用平均池化，作者能很好地检测出重定位I帧。\n- 类似的在[41]中许强等人通过构建 Genetic CNN，来进行AVC视频中重定位 I 帧的检测。不同于一般的卷积神经网络，**Genetic CNN 能够结合遗传算法，实现自动设计网络架构的目的**，通过算法对比，该算法的有效性得到验证。\n- 在[42]中，何沛松等人通过**构建一个混合深度神经网络来揭露伪高清的HEVC重编码视频**。通过提取基于块的残差信号，并构建一个双支路的网络进行检测，不同分支的输出向量将拼接后再联合优化得到逐块的检测结果。最后采用多数投票(local-to-global)策略得到最终的检测结果。\n- 除此之外，何沛松等人在[2]中**提出了一种混合神经网络**，通过从编码域中的编码信息中学习鲁棒时空表示，来揭示具有双重编码的HEVC视频中异常帧。\n- 在[43]中，Gan等人提出了一种**基于VGG-11卷积神经网络的视频帧内伪造取证算法**，该算法能自动检测视频伪造帧。该算法首先将视频解编码为一系列帧，计算出每帧的运动剩余映射，提取隐写特征。然后，以四个不同的隐写特征样本集作为训练集，并将测试集作为训练和测试模型。通过对比实验，选择了最佳性能特征。最后，通过伪造视频对伪造的帧进行了成功的标记。\n\n综上所述，深度神经网络的运用在一定程度上解决了传统算法的缺陷，虽然这些算法都能够取得较高的准确率，**但其仍然存在一系列局限性**：\n\n1. 大多数基于深度神经网络的算法对样本数量要求较高，并且需要耗费大量的时间训练网络模型。\n2. 这些算法都是以重定位I帧或者块为单位作为输入，如何设计高效的网络**实现视频级别的重编码痕迹检测**是今后研究的重要方向。\n3. 深度神经网络在提升了人工检测效率和准确率，但其深度网络的可解释性和学习到特征的可解释性仍然是不透明的，很多时候“过学习”的现象或者“欠学习”的问题普遍存在。这一问题有待进一步改善。\n\n### 总结与展望\n\n1. 篡改编辑（攻击）残留痕迹与数字媒体编码技术的依赖关系尚存在空白领域有待探索。数字媒体**各类编码标准的不同特性内在机制和信息失真模型理论、特征模型建模的方法论、算法检测框架的性能等问题**，还需要不断完善，逐步建立起完整的被动检测理论体系；\n2. 人工智能理论、深度网络学习方法与对抗篡改攻击技术互为对抗和相互融合是未来的发展趋势。目前新型的**VVC编码已经采用了众多的神经网络模块替代传统编码框架中画面提质模块、滤波模块、运动预测模块**等，未来的人工智能技术与编码深度结合之下，如何检测篡改攻击痕迹是更加复杂和困难的挑战；\n3. 该领域的专用算法尽管已经取得了丰硕的成果，但还存在着诸多边界条件的限制，离实际应用存在较大差距；**新型篡改攻击方法不断涌现；新的深度学习模型削弱了篡改痕迹等问题；新的编码算法使得篡改痕迹被隐藏；概率性取证检测转化为确定性检测**的方法等一系列问题。\n4. 目前尽管已经出现了若干的公开视频篡改数据库，但是覆盖篡改类型还比较有限，数据库建设的标准也不统一，数据库的原始样本也存在容器、编码标准混乱的情况，对支撑整个领域研究还是远远不够的；\n5. 在该领域的客观评价指标大多数**仅限于传统的检测准确率、算法效率、定位准确率等指标，但这些指标无法满足对篡改检测算法性能进行全方位的评价**，对未来算法应用落地是一个不容回避的问题，亟待更多的学者参与其中。\n\n### 参考文献\n\n[1] Mi Z, Jiang X, Sun T, GAN-Generated Image Detection with Self-Attention Mechanism against GAN Generator Defect[J]. IEEE Journal of Selected Topics in Signal Processing, 2020, 14(5): 969-981.\n\n[2] Peisong He;Haoliang Li;Hongxia Wang;Shiqi Wang;Xinghao Jiang;Ruimei Zhang, Frame-wise Detection of Double HEVC Compression by Learning Deep Spatio-temporal Representations in Compression Domain[J]. IEEE Transactions on Multimedia, 2020, DOI: 10.1109/ TMM.2020.3021234.\n\n[3] Xu Q, Jiang X, Sun T, Detection of HEVC double compression with non-aligned GOP structures via inter-frame quality degradation analysis, Neurocomputing,2021, 452: 99-113.\n\n[4] Zhong hao Li, Meng, Laijin; Xu, Shutong; Li, Zhaohong; Shi, Yunqing; Liang, Yuanchang, A HEVC Video Steganalysis Algorithm Based on PU Partition Modes[J]. Computers, Materials & Continua, 2019, 59(2):563-574.\n\n[5] Khoubani Sahar and Moradi Mohammad Hassan. A fast quaternion wavelet-based motion compensated frame rate up-conversion with fuzzy smoothing: application to echocardiography temporal enhancement[J]. Multimedia Tools and Applications, 2020, 80(6):8999-9025.\n\n[6] Kevin Spiteri and Rahul Urgaonkar and Ramesh K. Sitaraman. BOLA: Near-Optimal Bitrate Adaptation for Online Videos[J]. IEEE/ACM Transactions on Networking, 2020, PP(99):1-14.\n\n[7] Yin, Xiaoqi, Jindal, Abhishek, Sekar, Vyas,Sinopoli, Bruno, A Control-Theoretic Approach for Dynamic Adaptive Video Streaming over HTTP[J]. Computer communication review, 2015, 45(4):325-338.\n\n[8] Park W S, Kim M., CNN-based in-loop filtering for coding efficiency improvement[C]// 2016 IEEE 12th Image, Video, and Multidimensional Signal Processing Workshop (IVMSP). IEEE, 2016, DOI: 10.1109 /IVMSPW.2016.7528223.\n\n[9] Sun T, Jiang X, Chao J, A Novel Video Inter-frame Forgery Model Detection Scheme Based on Optical Flow Consistency[J]. International Workshop on Digital Watermarking, 2012. [10] Wang W, Jiang X, Wang S, et al. Identifying Video Forgery Process Using Optical Flow[M]//Digital-Forensics and Watermarking. Springer Berlin Heidelberg, 2014: 244-257.\n\n[11] Yin L, Bai Z, Yang R. Video forgery detection based on nonnegative tensor factorization[C]//Information Science and Technology (ICIST), 2014 4th IEEE International Conference on. IEEE, 2014: 148-151.\n\n[12] Quanxin Yang, Dongjin Yu, Zhuxi Zhang, Ye Yao, Linqiang Chen, Spatiotemporal Trident Networks: Detection and Localization of Object Removal Tampering in Video Passive Forensics[J]. IEEE Transactions on Circuits and Systems for Video Technology. 2020/12, DOI: 10.1109/TCSVT.2020.3046240.\n\n[13] Feng C, Xu Z, Zhang W, et al. Automatic location of frame deletion point for digital video forensics[C]//Proceedings of the 2nd ACM workshop on Information hiding and multimedia security. ACM, 2014: 171-179.\n\n[14] Feng C, Xu Z, Jia S, Zhang W, Xu Y, Motion-adaptive frame deletion detection for digital video forensics[J], IEEE Transactions on Circuits and Systems for Video Technology, 2016, 27(12):2543–2554.\n\n[15] Averbuch-Elor, Hadar, Cohen-Or, Daniel, Kopf, Johannes. Bringing portraits to life[J]. ACM Transactions on Graphics, 2017, 36(6) :1-13.\n\n[16] Kim Hyeongwoo, Theobalt Christian, Carrido Pablo. Deep video portraits[J]. ACM Transactions on Graphics, 2018, 37(4):1-14.\n\n[17] Zhou H, Liu Y, Liu Z, et al. Talking Face Generation by Adversarially Disentangled Audio-Visual Representation[J]. Proceedings of the AAAI Conference on Artificial Intelligence, 2019, 33:9299-9306.\n\n[18] Fried, O., Tewari, A., Zollh, Zollhöfer M et al. Text-Based Editing of Talking-Head Video[J]. ACM Trans. Graph. 38(4), 2019: 1-14.\n\n[19] Supasorn Suwajanakorn, Steven M. Seitz. Synthesizing Obama: learning lip sync from audio[M]. ACM, 2017.\n\n[20]Lee J W, Lee M J, Lee H Y, et al. Screenshot identification by analysis of directional inequality of interlaced video[J]. Eurasip Journal on Image & Video Processing, 2012, (1):1-15.\n\n[21] Bestagini P, Visentini-Scarzanella M, Tagliasacchi M, et al. Video recapture detection based on ghosting artifact analysis[C]//Image Processing (ICIP), 2013 20th IEEE International Conference on. IEEE, 2013: 4457-4461.\n\n[22] Rolland-Neviere, X., Chupeau, B., Doerr, G., et al. (2012) Forensic Characterization of Camcorded Movies: Digital Cinema vs. Celluloid Film Prints[C]//Proceedings of SPIE—The International Society for Optical Engineering, Burlin-game, 9 February 2012, 83030R-83030R-11.\n\n[23] Mahdian B, Novozamsky A, Saic S. Identification of aliasing-based patterns in re-captured LCD screens[C]//Image Processing (ICIP), 2015 IEEE International Conference on. IEEE, 2015: 616-620.\n\n[24] Visentini-Scarzanella M, Dragotti P L. Video jitter analysis for automatic bootleg detection[C]//Multimedia Signal Processing (MMSP), 2012 IEEE 14th International Workshop on. IEEE, 2012: 101-106.\n\n[25] Thongkamwitoon T, Muammar H, Dragotti P L. An image recapture detection algorithm based on learning dictionaries of edge profiles[J]. Information Forensics and Security, IEEE Transactions on, 2015, 10(5): 953-968.\n\n[26] Anjum, A., Islam, S. Recapture detection technique based on edge-types by analysing high-frequency components in digital images acquired through LCD screens[J]. Multimed Tools Appl, 2020,79: 6965–6985.\n\n[27] Chao J, Jiang X, Sun T. A novel video inter-frame forgery model detection scheme based on optical flow consistency[C]//International Workshop on Digital Watermarking. Springer, Berlin, Heidelberg, 2012: 267-281.\n\n[28] Wu Y, Jiang X, Sun T, et al. Exposing video inter-frame forgery based on velocity field consistency[C]//2014 IEEE international conference on acoustics, speech and signal processing (ICASSP). IEEE, 2014: 2674-2678.\n\n[29] Qiang XU, Xinghao Jiang, Tanfeng Sun*, Alex C. Kot, Detection of transcoded HEVC videos based on in-loop filtering and PU partitioning analyses[J], Signal Processing: Image Communication, 2021, 92:116109.\n\n[30] He P, Sun T, Jiang X, et al. Double compression detection in MPEG-4 videos based on block artifact measurement with variation of prediction footprint[C]// International Conference on Intelligent Computing. Springer. 2015: 787–793.\n\n[31] He P, Jiang X, Sun T, et al. Detection of double compression in MPEG-4 videos based on block artifact measurement[J]. Neurocomputing, 2017, 228: 84–96.\n\n[32] Yao Y, Yang G, Sun X, et al. Detecting video frame-rate up-conversion based on periodic properties of edge-intensity[J]. Journal of Information Security and Applications, 2016, 26: 39–50.\n\n[33] Bian S, Luo W, Huang J. Detecting video frame-rate up-conversion based on periodic properties of inter-frame similarity[J]. Multimedia tools and applications, 2014, 72(1): 437–451.\n\n[34] Vazquezpadin D, Fontani M, Bianchi T, et al. Detection of video double encoding with GOP size estimation[C]// IEEE International Workshop on Information Forensics and Security (WIFS), 2012:151-156.\n\n[35] Vazquez-Padin D, Fontani M, Shullani D, et al. Video Integrity Verification and GOP Size Estimation Via Generalized Variation of Prediction Footprint[J]. IEEE transactions on information forensics and security, 2020, (15):1815-1830.\n\n[36] Li, Q., Wang, R. and Xu, D., Detection of double compression in HEVC videos based on TU size and quantized DCT coefficients[J]. IET Inf. Secur., 2019, (13): 1-6.\n\n[37] Yao H., Ni R., Zhao Y., Double compression detection for H.264 videos with adaptive GOP structure. Multimedia Tools and Applications, 2020, (79):5789-5806.\n\n[38] Yu Y , Yao H , Ni R , et al. Detection of fake high definition for HEVC videos based on prediction mode feature[J]. Signal processing, 2020, 166(Jan.):107269.1-107269.11.\n\n[39] X.H, Jiang, Q. Xu, T.F. Sun, Bin Li, Peisong He, Detection of HEVC double compression with the same coding parameters based on analysis of intra coding quality degradation process[J]. IEEE Transactions on Information Forensics and Security, 2019, (15): 250-263.\n\n[40] He P, Jiang X, Sun T, et al. Frame-wise detection of relocated I-frames in double compressed H.264 videos based on convolutional neural network[J]. Journal of Visual Communication and Image Representation, 2017, (48): 149-158.\n\n[41 Xu Q, Jiang X, Sun T, et al. Relocated I-Frames Detection in H. 264 Double Compressed Videos Based on Genetic-CNN[C]. in: 2018 Asia-Pacifc Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC). 2018: 710-716.\n\n[42] He P, Li H, Li B, et al. Exposing Fake Bitrate Videos Using Hybrid Deep-learning Network from Recompression Error[J]. IEEE Transactions on Circuits and Systems for Video Technology, 2019, (99):1-13.\n\n[43] Gan Y, Yang J, Lai W. Video object forgery detection algorithm based on VGG-11 convolutional neural network[C]//2019 International Conference on Intelligent Computing, Automation and Systems (ICICAS). IEEE, 2019: 575-580.\n\n\n> 本文转自公众号【隐者联盟】[【极简综述17】数字图像处理操作取证](https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485053&idx=1&sn=b658496c5826472b5cea4183ede69759)、[【极简综述18】数字图像篡改操作取证](https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485053&idx=2&sn=afbec76ac6f61518c50b6a040eb33fac)、[【极简综述19】数字视频再编辑篡改及被动取证检测技术综述](https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485207&idx=1&sn=c2be18dc1badc7c8731a91c0f926d55b)\n\n","slug":"03 图像和视频篡改检测Manipulation Detection综述","published":1,"updated":"2022-11-26T20:35:45.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4n000p64rgh3b2a7v2","content":"<ul>\n<li>数字图像篡改操作取证(Tamper )<ul>\n<li>Copy-move操作取证技术</li>\n<li>Inpainting操作取证技术</li>\n<li>Splicing操作取证技术</li>\n</ul>\n</li>\n<li>数字图像处理操作取证(Manipulation)<ul>\n<li>JPEG重压缩取证技术</li>\n<li>增强操作取证技术</li>\n<li>几何操作取证技术</li>\n<li>操作链取证技术</li>\n</ul>\n</li>\n<li>视频编辑篡改检测<ul>\n<li>数字视频再编辑篡改技术</li>\n<li>数字视频被动取证检测技术</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"数字图像篡改操作取证-Tamper\"><a href=\"#数字图像篡改操作取证-Tamper\" class=\"headerlink\" title=\"数字图像篡改操作取证(Tamper )\"></a>数字图像篡改操作取证(<strong>Tamper</strong> )</h2><h3 id=\"Copy-move操作取证技术\"><a href=\"#Copy-move操作取证技术\" class=\"headerlink\" title=\"Copy-move操作取证技术\"></a>Copy-move操作取证技术</h3><p>图像复制粘贴篡改（copy-move）是数字图像篡改中比较常用的一种手段。它把单个图像中的部分区域复制并粘贴到同一图像中不交叠的其它区域，从而增加或覆盖掉某些物体。为了使篡改后的图像能够以假乱真，在复制过程中，复制区域可能会经历旋转、缩放等几何变换，并且合成图像可能经历加噪、模糊、压缩等后期处理，这进一步加大了篡改检测的难度。现有的图像复制篡改检测方法可以粗略的分为<strong>基于图像块的方法</strong>、<strong>基于关键点的方法</strong>和<strong>基于深度学习的方法</strong>。</p>\n<h4 id=\"基于图像块的方法\"><a href=\"#基于图像块的方法\" class=\"headerlink\" title=\"基于图像块的方法\"></a>基于图像块的方法</h4><p>Fridrich等人[1]首次定义了复制粘贴篡改，并提出了<strong>基于块匹配</strong>的检测方法，将图像分割成固定大小且相互重叠的子块，并使用DCT量化系数作为图像块的特征描述。该算法对图像块的所有DCT系数都进行统计计算，所以算法的复杂度很高。</p>\n<p>后来，多位学者分别<strong>提出了DWT变换、FWT变换等用于描述图像块的特征</strong>。Bashar等人[2]提出了两个鲁棒的特征，分别基于DWT变换和KPCA，并将这些特征向量构成一个矩阵。Cozzolino等人[3]提出了CHT作为图像的特征。该方法将图像中的每一个像素点都进行处理，提取到每一个像素点的特征。为了减少计算量，使用了快速的近似最近邻搜索算法对密集区域处进行高效的计算。</p>\n<p>除了频率域的特征提取，<strong>基于空间域</strong>的特征提取也有很多经典的算法，其中将矩阵特征作为图像的特征进行处理就是经常使用的方法。Mahdian和Saic[4]较早提出了一种<strong>基于模糊矩阵</strong>的方法，并使用了主成分分析减少特征的维数，最后利用k-d树对多维的数据块进行相似性分析，从而对篡改区域进行定位。Ryu等人[5]则将<strong>Zernike矩阵</strong>作为图像块的特征，并在<strong>图像块匹配时使用了局部敏感哈希算法</strong>加速匹配过程，最终根据匹配块寻找篡改区域。</p>\n<p>除了使用矩阵特征以外，也有研究者利用图像本身的一些<strong>纹理亮度信息作为图像的特征</strong>。Davarzani等人[6]采用多分辨率局部二值模式（MLBP）作为图像块的特征信息。为了获得精确的匹配信息，还使用了<strong>RANSAC算法</strong>去除掉错误的匹配。</p>\n<p>基于图像块的检测算法虽然能达到一定的效果，但是随着图像复制粘贴篡改的多样化，以及实际图像复制篡改过程中经历更多几何变换如旋转、缩放等，基于图像块的检测方法的鲁棒性会降低。此外，基于图像块的方法需要大量的计算，难以在实际中进行应用。为了提高检测效率，增强对抗几何变换的鲁棒性，基于关键点匹配的检测方法成了新的研究热点。</p>\n<h4 id=\"基于关键点的方法\"><a href=\"#基于关键点的方法\" class=\"headerlink\" title=\"基于关键点的方法\"></a>基于关键点的方法</h4><p>基于关键点的检测方法计算效率高且有较强的鲁棒性，适用于实际情况下的多类型图像复制粘贴篡改检测，因此研究者也致力于用基于关键点的检测方法来解决各种图像复制粘贴篡改检测的问题。</p>\n<p><strong>该类方法首先从整幅图像中提取关键点，然后对其进行特征描述提取和匹配过程，最后通过得到关键点匹配进行后续处理从而定位复制粘贴篡改区域。</strong></p>\n<p>Huang等人[7]<strong>采用SIFT作为图像关键点检测与特征描述</strong>的方法，并使用<strong>Best Bin First算法</strong>来寻找相似的特征向量，进而确定匹配关键点的位置。此后很多学者也提出了基于SIFT特征的检测方法，Pan和Lyu[8]使用了<strong>RANSAC算法</strong>来计算复制粘贴区域之间的仿射变换关系。Amerini等人[9]基于2NN准则提出了<strong>新的匹配方法G2NN</strong>以应对多重复制粘贴的情形。除了SIFT以外，研究者还提出了其它一系列的优秀算法。Xu等人[10]<strong>使用SURF作为提取图像关键点特征的方法</strong>。相比SIFT，SURF运算比较简单，计算效率更高。此外，Yang等人[11]<strong>采用了SIFT和KAZE的融合</strong>作为提取关键点特征的方法。</p>\n<p>针对复杂的复制粘贴篡改检测以及定位的精确度的问题，有研究者提出了更为系统的检测框架。Ardizzone等人[12]利用<strong>提取的SIFT特征点来构建Delaunay 划分，然后利用每个三角形块的颜色信息和角度信息作为三角形区域的特征向量进行匹配</strong>。Li等人[13]首先使用 <strong>SLIC算法对图像进行分割成一系列的超像素块</strong>，根据分割块内关键点匹配对的数量处理匹配块，提升了处理的效率。Zandi等人[14]通过自适应迭代的方法，根据每个迭代周期的结果迭代地调整关键点的分布还有匹配过程以及仿射变换矩阵计算。Li等人[15]通过降低关键点提取时的阈值，使得小区域、平滑区域可以提取足量的关键点，并且提出了一种<strong>新的层次匹配策略来解决大量关键点匹配问题</strong>。和基于块匹配的检测方法相比，基于关键点匹配的方法避免了全局搜索，大大提高了检测效率，且对几何变换具有更好的鲁棒性。</p>\n<h4 id=\"基于深度学习的方法\"><a href=\"#基于深度学习的方法\" class=\"headerlink\" title=\"基于深度学习的方法\"></a>基于深度学习的方法</h4><p>随着深度学习尤其是卷积神经网络的发展，研究者开始尝试使用深度学习的方法进行图像复制粘贴篡改的检测。Wu等人[16]设计了<strong>端到端的BusterNet</strong>，采取双分支结构，对图像操作和图像相似性进行检测，具有一定的效果，可以同时识别源区域和目标区域。Chen等人[17]提出一种<strong>串行分支网络模型</strong>，包含<strong>相似性检测网络CMSDNet和源与目标鉴别网络STRDNet</strong>。STRDNet研究CMSDNet获得的相似块的分类问题，相对于BusterNet的分支更加简单且准确率更高。</p>\n<p>Barni等人[18]提出了多分支网络DisTool对图像复制篡改进行检测并识别源区域和目标区域，分别为两个Siamese组成的4-Twins Net分支和一个Siamese分支。该网络在真实的测试场景中也表现良好。Zhong等人[19]提出了<strong>基于Dense-InceptionNet</strong>的检测方案，充分使用了多尺度的信息和稠密特征链接，设计了<strong>金字塔特征提取器，特征相关匹配和层次后处理模块</strong>。<strong>该算法对几何变换操作和JPEG压缩都有一定的鲁棒性</strong>。</p>\n<h3 id=\"Inpainting操作取证技术\"><a href=\"#Inpainting操作取证技术\" class=\"headerlink\" title=\"Inpainting操作取证技术\"></a>Inpainting操作取证技术</h3><p>图像修复(inpainting)技术是数字图像篡改中比较常用的一种手段，它的核心思想是根据图像受损区域周围的已知像素信息通过插值相邻像素对未知区域进行修复[20]。目前，传统的图像inpainting算法可以分成两类：<strong>基于块的方法和基于扩散的方法。</strong></p>\n<ul>\n<li><p>基于块的方法主要是通过搜索图像已知区域的图像块，寻找合适的候选块对受损区域进行填补以达到修复的目的；</p>\n</li>\n<li><p>基于扩散的方法通常是通过求解偏微分方程或者依据扩散系统将图像信息从边界传播扩散到未知区域进行修复。</p>\n</li>\n</ul>\n<p>当恶意篡改者使用图像inpainting技术进行篡改并将这类图像应用于司法、科学等领域时，将会造成不可预料的严重影响。现有的针对图像inpainting的<strong>检测方法</strong>大致可以分为两类：<strong>基于传统手工特征的方法和基于深度学习的方法。</strong></p>\n<h4 id=\"基于传统手工特征的方法\"><a href=\"#基于传统手工特征的方法\" class=\"headerlink\" title=\"基于传统手工特征的方法\"></a>基于传统手工特征的方法</h4><p>最初，Wu等人[21]在2008年提出了一种<strong>基于零连通特征和模糊隶属度</strong>的检测方法。首先对图像中的块进行零连通标记，筛选可疑区域，然后通过计算模糊隶属度识别可疑区域内的修复块，并通过割集实现最终的修复篡改区域的定位。</p>\n<p>2013年，Bacchuwar等人[22]提出了一种可以同时检测图像修复和图像复制-粘贴两种篡改的方法。该方法<strong>利用图像的亮度分量，对可疑区域中的块进行中值匹配</strong>，引入“跳跃块”，从而有序检测篡改区域。它相较于文献[21]加速了修复区域的定位，但仍需要人工选择区域。</p>\n<p>为减少最佳匹配块的搜索时间，Chang等人[23]通过检测关键值进行相似度检测，提出了一种<strong>基于权值变换的搜索算法</strong>，包括可疑区域检测和篡改区域识别两个阶段。Liang等人[24]首先<strong>采用中心像素映射搜索</strong>可疑块对，在装载因子和搜索范围方面加速了对可疑块的搜索，使用最大零连通性区域标记和片段拼接检测技术实现篡改区域的定位。</p>\n<p>申林川等人[25]对已有的图像修复检测方法进行改进，<strong>利用一种hash映射函数将图片三维的颜色信息转换成一维的hash值映射至哈希表</strong>，再结合相似向量滤波和基于质心的篡改区域定位技术，实现篡改区域最终的准确定位。</p>\n<p>另外，JPEG是目前网络中使用最广泛的图像格式。Zhao等人[26]针对JPEG图像展开研究，<strong>通过计算和分割不同质量因子下的修复图像和再保存JPEG图像的绝对差值之和检测出被篡改的区域</strong>，不需要任何手动操作。</p>\n<p>Liu等人[27]也聚焦于JPEG图像，<strong>提出了一种大规模特征挖掘的经验方法，包含边缘密度和联合密度特征</strong>，采用集成学习，有效地检测了包括图像修复在内的复合攻击下的图像篡改，特别是在重压缩质量低于原始JPEG图像质量的情况下，显著提高了检测精度。</p>\n<p>Li等人[28]针对<strong>基于扩散的修复方法进行区域检测，发现修复区域和未修复区域图像沿垂直于梯度方向的拉普拉斯变换是不同的</strong>。基于此，根据通道内和通道间的局部变化方差构造了一个特征集。最后，设计了两个有效的后处理操作来进一步细化定位结果。但该方法鲁棒性较差，特别是对经过JPEG压缩后处理的图像取证性能显著下降。</p>\n<p>刘婷婷等人[29]<strong>提出了一种梯度域导向滤波增强的图像扩散修复检测算法</strong>。该算法对输入图像的各个颜色通道分别进行梯度域导向滤波增强，从多角度捕捉图像修复带来的影响，以实现图像扩散修复区域的定位。</p>\n<p>基于传统手工特征的图像inpainting检测算法在一些方面存在一定的局限性，比如<strong>需要手动选择区域、只针对特定的图像inpainting技术、鲁棒性较差</strong>等。近年来为提高检测效率，增强算法对抗几何变换的鲁棒性，基于深度学习的图像inpainting检测算法也在不断发展。</p>\n<h4 id=\"基于深度学习的方法-1\"><a href=\"#基于深度学习的方法-1\" class=\"headerlink\" title=\"基于深度学习的方法\"></a>基于深度学习的方法</h4><p>随着深度学习的发展，研究人员开始尝试使用深度学习方法实现图像修复检测。</p>\n<p>2018年，Zhu等人[30]提出了一种基于深度神经网络的图像inpainting篡改检测技术，通过神经网络自动提取篡改痕迹，实现图像像素级的预测并对修复区域进行定位。<strong>该框架在编码器-解码器的全卷积网络结构基础上还引入了特征金字塔网络对特征图进行信息补充</strong>，填充图像的语义信息，且具有一定的泛化性。进一步地，Zhu等人[31]提出了新的网络框架，并构建了类标签矩阵，设计了加权交叉熵解决图像像素不平衡的问题。该方法考虑了JPEG压缩和缩放等后处理操作，具有一定的鲁棒性。</p>\n<p>Wang等人[32]在2019年提出了一种<strong>基于Faster R-CNN网络的图像inpainting篡改检测方法</strong>，并<strong>自制</strong>了在两种深度学习图像修复算法下的<strong>数据集</strong>，实现了修复区域的边界框定位。但该方法只能得到标记有置信度分数的边界框，无法得到修复篡改区域的真实区域，定位精度有待进一步提高。</p>\n<p>Lu等人[33]提出了一种<strong>基于LSTM-CNN的图像目标去除方法</strong>，利用CNN搜索异常相似块，提高了搜索的速度和准确性，利用LSTM网络消除虚警补丁对检测结果的影响，降低虚警率。</p>\n<p>Li等人[34]探究发现在像素域中修复图像块和未修复图像块的转移概率值相似，而在残差域中表现出明显的差异，修复图像块包含较少的高频分量。因此，作者<strong>设计了HP-FCN网络，利用高通滤波模块对输入图像进行预处理，将其残差图输送到基于CNN的特征提取模块中，再通过上采样模块采样到输入图像大小，最终得到像素预测的定位图。</strong>该算法对深度学习下的修复数据集进行定位检测，且进一步考虑了随机修复和现实情况下的真实数据集，在准确率上都取得了较好的效果，具有一定的鲁棒性。</p>\n<p>为了提高已有算法对不可见图像修复方法的检测性能，Wu等人[35]提出了一种新型的<strong>端到端图像修复检测网络IID-Net，其中NAS算法用于设计适当的网络架构，并结合新提出的注意模块来进一步优化潜在特征。</strong>该算法在特定深度修复方法上训练的取证模型对其他修复方法具有良好的通用性检测能力。作者还基于10种不同的修复方法构建了一个<strong>包含10K张图片的不同修复测试数据集</strong>，每种修复方法提供1000张图片，作为一个公共可访问的数据集，用于修复检测方法的标准化比较。</p>\n<h3 id=\"Splicing操作取证技术\"><a href=\"#Splicing操作取证技术\" class=\"headerlink\" title=\"Splicing操作取证技术\"></a>Splicing操作取证技术</h3><p><strong>图像拼接(splicing)<strong>伪造不同于复制-粘贴伪造，它是将一个或多个源图像的区域复制粘贴到目标图像上得到篡改图像。图像拼接伪造检测与定位可以看作是一个全局二值分类问题，通过比较不同图像区域之间的特征来检测定位篡改区域。现有的图像拼接伪造检测方法大致可以归纳为四类：</strong>基于模糊类型不一致性的方法</strong>，<strong>基于噪声水平不一致性的方法</strong>，<strong>基于光照不一致性的方法</strong>和<strong>基于深度学习的方法</strong>。</p>\n<h4 id=\"基于模糊类型不一致性的方法\"><a href=\"#基于模糊类型不一致性的方法\" class=\"headerlink\" title=\"基于模糊类型不一致性的方法\"></a>基于模糊类型不一致性的方法</h4><p>2011年，Kakar等人[36]提出了一种<strong>利用运动模糊差异性检测图像拼接</strong>的新方法。通过对图像梯度的运动模糊水平的估计，检测拼接区域和原始区域之间的不一致性。作者还开发了一种新的方法，可以较好地对包含运动模糊的图像进行不一致性区域分割。</p>\n<p>为了适应不同范围的模糊程度，Bahrami等人[37] 提出了一种基于<strong>图像模糊度和深度信息不一致性的图像拼接检测框架</strong>。首先估计图像块的模糊核，再利用分步模糊技术测量局部模糊核的相对模糊度。基于此，对不同模糊程度的图像块进行分类。</p>\n<p>Rao等人[38]考虑手持摄像机中运动模糊现象这一特定场景，提出了一种<strong>以模糊为线索的被动图像拼接检测方法</strong>。离焦模糊也是图像拼接检测中的一种常用特征，然而纹理、光场、噪声等都会在一定范围内影响自然边缘的离焦模糊信息，导致边缘离焦模糊估计不一致。</p>\n<p>Song等人[39]分析了图像拼接边缘和自然边缘的离焦模糊特征的差异性，提出了<strong>一种新的基于离焦模糊差的自然图像拼接检测方法</strong>。当伪造者使用一些后处理操作来掩盖拼接痕迹时，图像拼接问题是一个具有挑战性的问题。</p>\n<p>为进一步解决这个问题，Bahrami等人[40]在2015年提出了一种<strong>基于局部模糊类型不一致性的模糊图像拼接定位框架</strong>。作者首先对图像进行分块，根据局部模糊核提取局部模糊类型检测特征用于离焦模糊和运动模糊的划分，从而生成模糊类型不变区域。最后，采用精细拼接定位方法提高区域边界的精度。</p>\n<h4 id=\"基于噪声水平不一致性的方法\"><a href=\"#基于噪声水平不一致性的方法\" class=\"headerlink\" title=\"基于噪声水平不一致性的方法\"></a>基于噪声水平不一致性的方法</h4><p>大多数图像在采集或后续处理过程中都会引入一定的噪声，而自然图像和具有不同来源的拼接图像中的噪声会存在不同程度的差异性。研究人员根据噪声的不一致性提出了相应的图像拼接检测算法。</p>\n<p>Mahdian等人[41]将待测图像分割成不同噪声水平的分区，<strong>利用基于中值的方法计算每个图像块的噪声标准差</strong>，通过一个阈值确定图像拼接篡改区域。</p>\n<p>Lyu等人[42]利用了自然图像在带通域内峰度的特殊规律以及噪声特征与峰度之间的关系。<strong>将噪声统计量的估计表述为一个具有封闭解的优化问题</strong>，并进一步推广到一种有效的局部噪声统计量估计方法。通过揭示局部噪声水平的不一致性来检测拼接区域。</p>\n<p>研究人员发现可以通过主成分分析(PCA)来估计图像的噪声水平。其中，2015年，Zhan等人[43]在主成分分析的基础上，根据不同的局部噪声方差，<strong>对待测图进行均匀噪声的区域分割</strong>，实现篡改区域的定位。Zeng等人[44]发现当拼接区域与原始区域噪声差较小时，一些基于噪声的图像拼接定位算法性能不佳。作者采用基于主成分分析的算法对图像进行分块噪声水平估计，<strong>通过k-means聚类从原始区域分割出篡改区域</strong>。Yao等人[45]通过探讨噪声水平函数(NLF)与相机相应函数(CRF)之间的关系，拟合了CRF约束下的NLF曲线，<strong>建立了一个贝叶斯最大后验(MAP)框架来优化NLF估计</strong>，并开发了一种基于不同来源图像块噪声水平不一致性的图像拼接检测方法。Liu等人[46]针对多目标拼接伪造场景，<strong>利用噪声水平函数(NLF)估计图像噪声与像素强度之间的关系，从而检测可疑篡改区域</strong>。2018年，Nan等人[47]提出一种新的噪声水平函数的图像拼接检测方法。作者首先将图像分成不重叠的块，将每个块的噪声方差拟合到锐利度下，<strong>通过计算图像块到拟合曲线的最小距离区分篡改区域</strong>。</p>\n<h4 id=\"基于光照不一致性的方法\"><a href=\"#基于光照不一致性的方法\" class=\"headerlink\" title=\"基于光照不一致性的方法\"></a>基于光照不一致性的方法</h4><p>一般来说，使用不同设备拍摄的图像会存在光照不一致性。基于此特性，Liu等人[48]在2011年提出了一种基于阴影亮度不一致性的图像拼接篡改检测框架。<strong>该框架首先提取图像中的阴影边界和半阴影区域</strong>，估计阴影的遮罩值来衡量其颜色特征。但当合成阴影和实际目标阴影一致时，该算法失效。Ke等人[49]对此提出改进，提出了基于阴影一致性的篡改图像检测方法。通过提取阴影区域和非阴影区域的纹理特征，<strong>利用相关函数来度量两种纹理特征的相似性。通过比较相似度，实现图像拼接篡改的检测。</strong></p>\n<h4 id=\"基于深度学习的方法-2\"><a href=\"#基于深度学习的方法-2\" class=\"headerlink\" title=\"基于深度学习的方法\"></a>基于深度学习的方法</h4><ul>\n<li>Xiao等人[50]提出了一种由粗到精的两阶段检测网络(<strong>C2RNet</strong>)和稀释自适应聚类两部分组成的拼接伪造检测方法，从不同尺度的图像块中学习图像属性的差异。</li>\n<li>Bappy等人[51]提出了一种<strong>利用空间域的编码器-解码器结构网络和频域的长短期记忆(LSTM)网络的双域检测方法</strong>。该网络利用更大的接受域和频域相关性，通过结合编码器和LSTM网络来分析篡改区域和非篡改区域之间的区别特征。最后使用解码器实现像素级预测图像篡改定位。</li>\n<li>进一步地，Wu等人[52]将伪造定位问题定义为局部异常检测问题，<strong>设计了Z-score特征来捕获局部异常，并提出了一种新的检测网络结构(Mantra-net)来评估局部异常</strong>。</li>\n<li>Bi等人[53]采用图像分割的思想，设计了一种用于图像拼接伪造检测的环形残差U-Net (RRU-Net)，<strong>利用残差传播和残差反馈使得未篡改区域和篡改区域</strong>之间的图像属性差异更加明显。</li>\n<li>Zhou等人[54]针对目前常见的几类局部篡改操作，<strong>结合传统特征提出了一个双流Faster R-CNN网络</strong>。不仅实现了篡改操作类型识别，更进一步地能够定位到篡改区域，在图像拼接伪造检测方面也具有比较好的性能。</li>\n</ul>\n<p>目前，图像拼接伪造检测和定位问题出现了一种新的定义：给定一幅探针图像Q和一幅潜在的供体图像P。检测供体图像的区域是否已拼接到探针图像中，如果已拼接到探针图像，则提供两个掩码，指示拼接到探针中的供体图像区域和从供体图像中拼接的图像区域。这一新问题将图像拼接检测约束为一对图像，相关研究人员将其称为约束图像拼接检测问题。针对这一问题，Wu等人[55]提出了一种开拓性的CISDL方法，设计了一种新的深度卷积神经网络结构—<strong>深度匹配与验证网络(DMVN)<strong>。Ye等人[56]在继承DMVN深度密集匹配层的基础上，提出了</strong>特征金字塔深度匹配与定位方法网络(FPLN)<strong>。Liu等人[57]提出了</strong>一种面向CISDL新的对抗性学习框架的深度匹配网络(DMAC)<strong>，用于生成两个高质量候选掩模，基于检测网络纠正候选掩模之间的不一致，并</strong>基于判别网络生成与真实篡改区域接近的掩模，检测网络与判别网络以对抗学习方式协同监督DMAC</strong>训练。</p>\n<h3 id=\"小结与思考\"><a href=\"#小结与思考\" class=\"headerlink\" title=\"小结与思考\"></a><strong>小结与思考</strong></h3><p>目前，除了上述图像篡改操作的取证，removal、seam carving等篡改操作的取证研究也吸引了国内外学者的广泛关注，并取得了一些阶段性成果。尤其是近年来，以卷积神经网络为代表的深度学习技术在图像篡改操作取证领域取得了突出的性能，但仍存在一些问题有待进一步研究。</p>\n<p>（1）篡改者在使用copy-move，inpainting或者splicing操作对图像语义进行恶意篡改后，通常会使用一些后处理操作或者反取证技术掩盖操作的篡改痕迹，如何设计对不同后处理操作和反取证技术鲁棒的篡改操作取证模型是值得进一步探索的方向。</p>\n<p>（2）针对inpainting操作检测问题，大多数取证方法都基于修复区域与未修复区域的块匹配原理，检测效率较低。如何在保证定位准确率的前提下，加快区域匹配速率是一个待解决的问题。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>[1]J. Fridrich, D. Soukal, and J. Lukas. Detection of copy-move forgery in digital images. Proceedings of Digital Forensic Research Workshop (DFRWS), Cleveland, OH, USA, 2003.</p>\n<p>[2]M. Bashar, K. Noda, N. Ohnishi, and K. Mori. Exploring duplicated regions in natural images. IEEE Transactions on Image Processing, DOI: 10.1109/TIP.2010.2046599, 2010.</p>\n<p>[3]D. Cozzolino, G. Poggi, and L. Verdoliva. Efficient dense¬field copy–move forgery detection. IEEE Transactions on Information Forensics and Security, vol. 10, no. 11, pp. 2284-2297, 2015.</p>\n<p>[4]B. Mahdian, and S. Saic. Detection of copy–move forgery using a method based on blur moment in-variants,.Forensic Science International, vol. 171, no. 2, pp. 180-189, 2017.</p>\n<p>[5]S. -J. Ryu, M. Kirchner, M. -J. Lee, and H. K. Lee. Rotation invariant localization of duplicated image regions based on zernike moments. IEEE Transactions on Information Forensics and Security, vol. 8, no. 8, pp. 1355-1370, 2013.</p>\n<p>[6]R. Davarzani, K. Yaghmaie, S. Mozaffari, and M.Tapak. Copy¬-move forgery detection using multiresolution local binary patterns. Forensic Science International, vol. 231, no. 1, pp. 61-72, 2013.</p>\n<p>[7]H. Huang, W. Guo, and Y. Zhang. Detection of copy-move forgery in digital images using sift algorithm. IEEE Pacific-Asia Workshop on Computational Intelligence and Industrial Application (PACIIA), Wuhan, China, pp. 272–276, 2008.</p>\n<p>[8]X. Pan, and S. Lyu. Region duplication detection using image feature matching. IEEE Transactions on Information Forensics and Security, vol. 5, no. 4, pp. 857-867, 2010.</p>\n<p>[9]I. Amerini, L. Ballan, R. Caldelli, A.D. Bimbo, and G. Serra. A sift-based forensic method for copy-move attack detection and transformation recovery. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1099-1110, 2011.</p>\n<p>[10]B. Xu, J. Wang, G. Liu, H. Li, and Y. Dai. Image copy-move forgery detection based on surf. International Conference on Multimedia Information Networking and Security (MINES), Nanjing, China, pp. 889-892, 2010.</p>\n<p>[11]F. Yang, J. Li, W. Lu, and J. Weng. Copy¬-move forgery detection based on hybrid features. Engineering Applications of Artificial Intelligence, vol. 59, pp. 73-83, 2017.</p>\n<p>[12]E. Ardizzone, A. Bruno, and G. Mazzola. Copy move forgery detection by matching triangles of keypoints. IEEE Transactions on Information Forensics and Security, vol. 10, no. 10, pp. 2084-2094, 2015.</p>\n<p>[13]J. Li, X. Li, B. Yang, and X. Sun. Segmentation¬ based image copy¬-move forgery detection scheme. IEEE Transactions on Information Forensics and Security, vol. 10, no. 3, pp. 507-518, 2015.</p>\n<p>[14]M. Zandi, A. M.-Aznaveh and A. Talebpour. Iterative copy-¬move forgery detection based on a new interest point detector. IEEE Transactions on Information Forensics and Security, vol. 11, no. 11, pp. 2499-2512, 2016.</p>\n<p>[15]Y. Li, and J. Zhou. Fast and effective image copy¬-move forgery detection via hierarchical feature point matching. IEEE Transactions on Information Forensics and Security, vol. 14, no. 5, pp. 1307-1322, 2019.</p>\n<p>[16]Y. Wu, W. A.-Almageed, and P. Natarajan. BusterNet: Detecting copy-move image forgery with source/target localization. Proceedings of the European Conference on Computer Vision (ECCV), Munich, Germany, pp.170-186, 2018.</p>\n<p>[17]B. Chen, W. Tan, G. Coatrieux, Y. Zheng, and Y. Q. Shi. A serial image copy-move forgery localization scheme with source/target distinguishment. IEEE Transactions on Multimedia, DOI: 10.1109/TMM.2020.3026868, 2020.</p>\n<p>[18]M. Barni, Q. -T. Phan, and B. Tondi. Copy move source-target disambiguation through multi-branch CNNs. IEEE Transactions on Information Forensics and Security, vol. 16, pp. 1825-1840, 2021.</p>\n<p>[19]J. Zhong, and C. Pun. An end-to-end Dense-InceptionNet for image copy-move forgery detection. IEEE Transactions on Information Forensics and Security, vol. 15, pp. 2134-2146, 2020.</p>\n<p>[20]A. Criminisi, P. Perez, and K. Toyama. Region filling and object removal by exemplar-based image inpainting. IEEE Transactions on Image Processing, vol. 13, no. 9, pp. 1200-1212, 2004.</p>\n<p>[21]Q. Wu, S. Sun, W. Zhu, G. Li, and D. Tu. Detection of digital doctoring in exemplar-based inpainted images. International Conference on Machine Learning and Cybernetics (ICMLC), Kunming, China, pp. 1222–1226, 2008.</p>\n<p>[22]K. S. Bacchuwar, Aakashdeep, and K. R. Ramakrishnan. A jump patch-block match algorithm for multiple forgery detection. International Mutli-Conference on Automation, Computing, Communication, Control and Compressed Sensing (iMac4s), Kottayam, India, pp. 723-728, 2013.</p>\n<p>[23]I. Chang, J. Yu, and C. Chang. A forgery detection algorithm for exemplar-based inpainting images using multi-region relation. Image and vision computing, vol. 31, no. 1, pp. 57-71, 2013.</p>\n<p>[24]Z. Liang, G. Yang, X. Ding, and L. Li. An efficient forgery detection algorithm for object removal by exemplar-based image inpainting. Journal of Visual Communication and Image Representation, vol. 30, pp. 75-85, 2015.</p>\n<p>[25]L. Shen, G. Yang, L. Li, X. Sun. Robust detection for object removal by exemplar-based image inpainting with post-processing. International Conference on Natural Computation, Fuzzy Systems and Knowledge Discovery (FSKD), Guilin, China, pp. 2730-2736, 2017.</p>\n<p>[26]Y. Zhao, M. Liao, F. Y. Shih, and Y. Q. Shic. Tampered region detection of inpainting JPEG images. Optik, vol. 124, no. 16, pp. 2487-2492, 2013.</p>\n<p>[27]Q. Liu, A. H. Sung, B. Zhou, and M. Qiao. Exposing inpainting forgery in JPEG images under recompression attacks. IEEE International Conference on Machine Learning and Applications (ICMLA), Anaheim, CA, USA, pp. 164-169, 2016.</p>\n<p>[28]H. Li, W. Luo, and J. Huang. Localization of diffusion-based inpainting in digital images. IEEE transactions on information forensics and security, vol. 12, no. 12, pp. 3050-3064, 2017.</p>\n<p>[29]刘婷婷, 张玉金, 吴飞等. 基于梯度域导向滤波增强的图像扩散修复取证[J]. 激光与光电子学进展, 2020, vol. 57, no. 8, pp. 35-42.</p>\n<p>[30]朱新山, 钱永军, 孙彪等. 基于深度神经网络的图像修复取证算法[J]. 光学学报, 2018, vol. 38, no. 11, pp. 97-105.</p>\n<p>[31]X. Zhu, Y. Qian, X. Zhao, B. Sun, and Y. Sun. A deep learning approach to patch-based image inpainting forensics. Signal Processing: Image Communication, vol. 67, pp. 90–99, 2018.</p>\n<p>[32]X. Wang, H. Wang, and S. Niu. An image forensic method for AI inpainting using faster R-CNN. International Conference on Artificial Intelligence and Security (ICAIS), New York, USA, pp. 476-487, 2019.</p>\n<p>[33]M. Lu, and S. Niu. A detection approach using LSTM-CNN for object removal caused by exemplar-based image inpainting. Electronics, vol. 9, pp. 858, 2020.</p>\n<p>[34]H. Li, and J. Huang. Localization of deep inpainting using high-pass fully convolutional network. IEEE International Conference on Computer Vision (ICCV), Seoul, South Korea, pp. 8301-8310, 2019.</p>\n<p>[35]H. Wu, and J. Zhou. IID-Net: image inpainting detection network via neural architecture search and attention. IEEE Transactions on Circuits and Systems for Video Technology, DOI: 10.1109/TCSVT.2021.3075039, 2021.</p>\n<p>[36]P. Kakar, N. Sudha, and W. Ser. Exposing digital image forgeries by detecting discrepancies in motion blur. IEEE Transactions on Multimedia, vol. 13, no. 3, pp. 443-452, 2011.</p>\n<p>[37]K. Bahrami, A. C. Kot, and J. Fan. Splicing detection in out-of-focus blurred images. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 144-149, 2013.</p>\n<p>[38]M. P. Rao, A. N. Rajagopalan, and G. Seetharaman. Harnessing motion blur to unveil splicing. IEEE Transactions on Information Forensics and Security, vol. 9, no. 4, pp. 583-595, 2014.</p>\n<p>[39]C. Song, and X. Lin. Natural image splicing detection based on defocus blur at edges. IEEE/CIC International Conference on Communications in China (ICCC), Shanghai, China, pp. 225-230, 2014.</p>\n<p>[40]K. Bahrami, A. C. Kot, L. Li, and H. Li. Blurred image splicing localization by exposing blur type inconsistency. IEEE Transactions on Information Forensics and Security, vol. 10, no. 5, pp. 999-1009, 2015.</p>\n<p>[41]B. Mahdian, and S. Saic. Using noise inconsistencies for blind image forensics. Image and Vision Computing, vol. 27, no. 10, pp. 1497-1503, 2009.</p>\n<p>[42]S. Lyu, X. Pan, and X. Zhang. Exposing region splicing forgeries with blind local noise estimation. International Journal of Computer Vision, vol. 110, no. 2, pp. 202–221, 2014.</p>\n<p>[43]L. Zhan, and Y. Zhu. Passive forensics for image splicing based on PCA noise estimation. International Conference for Internet Technology and Secured Transactions (ICITST), London, UK, pp. 78-83, 2015.</p>\n<p>[44]H. Zeng, Y. Zhan, X. Kang, and X. Lin. Image splicing localization using PCA-based noise level estimation. Multimedia Tools and Applications, vol. 76, no. 4, pp. 4783–4799, 2017.</p>\n<p>[45]H. Yao, S. Wang, X. Zhang, C. Qin, and J. Wang. Detecting image splicing based on noise level inconsistency. Multimedia Tools and Applications, vol. 76, no. 10, pp. 12457–12479, 2017.</p>\n<p>[46]B. Liu, and C. Pun. Multi-object splicing forgery detection using noise level difference. IEEE Conference on Dependable and Secure Computing (DSC), Taipei, Taiwan, pp. 533-534, 2017.</p>\n<p>[47]Z. Nan, and L. Zhao. Blind image splicing detection via noise level function. Signal Processing: Image Communication, vol. 69, pp. 181-192, 2018.</p>\n<p>[48]Q. Liu, X. Cao, C. Deng, and X. Guo. Identifying image composites through shadow matte consistency. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1111-1122, 2011.</p>\n<p>[49]Y. Ke, F. Qin, W. Min, and G. Zhang. Exposing image forgery by detecting consistency of shadow. The scientific world journal, vol. 2014, no. 3, pp. 1-9, 2014.</p>\n<p>[50]B. Xiao, Y. Wei, X. Bi, W. Li, and J. Ma. Image splicing forgery detection combining coarse to refined convolutional neural network and adaptive clustering. Information Sciences, vol. 511, pp. 172–191, 2020.</p>\n<p>[51]J. H. Bappy, C. Simons, L. Nataraj, B. S. Manjunath, and A. K. Roy-Chowdhury. Hybrid LSTM and encoder-decoder architecture for detection of image forgeries. IEEE Transactions on Image Processing, vol. 28, no. 7, pp. 3286-3300, 2019.</p>\n<p>[52]Y. Wu, W. AbdAlmageed, and P. Natarajan. ManTra-Net: manipulation tracing network for detection and localization of image forgeries with anomalous features. IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), Long Beach, CA, USA, pp. 9535-9544, 2019.</p>\n<p>[53]X. Bi, Y. Wei, B. Xiao, and W. Li. RRU-Net: the ringed residual U-Net for image splicing forgery detection. IEEE/CVF Conference on Computer Vision and Pattern Recognition Workshops (CVPRW), Long Beach, CA, USA, pp. 30-39, 2019.</p>\n<p>[54]P. Zhou, X. Han, V. I. Morariu, and L. S. Davis. Learning rich features for image manipulation detection. IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), Salt Lake, USA pp. 1053-1061, 2018.</p>\n<p>[55]Y. Wu, W. Abd-Almageed, and P. Natarajan. Deep matching and validation network: An end-to-end solution to constrained image splicing localization and detection. ACM international conference on Multimedia (MM), Mountain View, CA, USA, pp. 1480–1502, 2017.</p>\n<p>[56]K. Ye, J. Dong, W. Wang, B. Peng, and T. Tan. Feature pyramid deep matching and localization network for image forensics. Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC), Honolulu, Hawaii, USA, pp. 1796–1802, 2018.</p>\n<p>[57]Y. Liu, X. Zhu, X. Zhao, and Y. Cao. Adversarial learning for constrained image splicing detection and localization based on atrous convolution. IEEE Transactions on Information Forensics and Security, vol. 14, no. 10, pp. 2551-2566, 2019.</p>\n<h2 id=\"数字图像处理操作取证-Manipulation\"><a href=\"#数字图像处理操作取证-Manipulation\" class=\"headerlink\" title=\"数字图像处理操作取证(Manipulation)\"></a>数字图像处理操作取证(Manipulation)</h2><h3 id=\"JPEG重压缩取证技术\"><a href=\"#JPEG重压缩取证技术\" class=\"headerlink\" title=\"JPEG重压缩取证技术\"></a>JPEG重压缩取证技术</h3><p>篡改图像必然会经过重压缩这一步骤，因此数字图像重压缩检测能够为数字图像取证提供强有力的辅助依据。目前，使用最广泛的图像压缩标准是JPEG，若原始的图像是JPEG格式，篡改后的图像为达到不易于检测的效果，同样会保存为JPEG格式，则图像会进行两次JPEG压缩。现如今JPEG重压缩取证包含两个主要研究课题，一是<strong>JPEG重压缩检测</strong>，二是<strong>对JPEG重压缩区域进行定位</strong>。</p>\n<h4 id=\"JPEG重压缩检测\"><a href=\"#JPEG重压缩检测\" class=\"headerlink\" title=\"JPEG重压缩检测\"></a>JPEG重压缩检测</h4><p>JPEG压缩属于有损压缩，每次压缩都会丢失一部分信息，由于JPEG重压缩对图像数据进行了两次量化操作，引入了一些单次JPEG压缩所没有的特征，因此通过一定的统计检测可以发现图像是否经历过JPEG重压缩。</p>\n<p>现今的重压缩检测算法大多遵循一个检测模式，第一步是从图像中<strong>找到能最大化单次压缩和双重压缩类间差异的特征</strong>；第二步则是在得到特征后，基于数据驱动训练分类器，<strong>用于识别和分类双重压缩和单次压缩</strong>。</p>\n<ul>\n<li>比如，Shang等人[1]<strong>以DCT系数</strong>矩阵水平、垂直、对角、反对角方向差分的高阶马尔科夫转移概率作为特征，用SVM和EC分类器分类实现JPEG重压缩图像检测。</li>\n<li>Zeng等人[2]提出了一种改进的密集连接的<strong>卷积网络（DenseNet）</strong>来完成双压缩图像中主JPEG压缩的检测任务。他们在网络的前端加入了一个特殊的滤波层，该层通常包含选定的滤波和，可以帮助后续网络更容易地识别图像。</li>\n<li>Wang等人[3]提出了<strong>一种基于四元数离散余弦变换（QDCT）域的改进马尔可夫压缩检测算法</strong>。首先，对给定JPEG图像的颜色信息提取图像构造四元数；然后，构造图像块QDCT系数矩阵，包括振幅和三个角；接着，在相应的细化过程中，由转移概率矩阵生成细化的马尔可夫特征；最后，使用支持向量机（SVM）方法进行NA-DJPEG压缩检测。然而这些统计模型大多关注变换域系数本身，忽略了JPEG压缩给变换域系数引入的相关性，使得当后压缩质量因子远小于前压缩质量因子时，难以判定双重压缩的存在性。</li>\n</ul>\n<p>此外，<strong>为了更进一步获取重压缩痕迹，首次压缩时的量化步长估计</strong>是非常关键的问题。</p>\n<ul>\n<li>Galvan等人[4]首先使用直方图滤波除去二次量化以外操作引入的直方图噪声，然后使用一个新的估计方程来估计第一次量化使用的量化步长。该方法在实际应用中可以更准确估计量化步长。然而当后压缩质量因子较小时，大量图像数据会被破坏乃至丢弃，使得这类方法检测效果不佳。</li>\n<li>此外，Thai等人[5]<strong>将量化效应和DCT系数统计相结合</strong>，对先前压缩并存储为无损的图像进行量化步长的估计。</li>\n</ul>\n<h4 id=\"JPEG重压缩定位\"><a href=\"#JPEG重压缩定位\" class=\"headerlink\" title=\"JPEG重压缩定位\"></a>JPEG重压缩定位</h4><p>一些研究将JPEG重压缩检测和篡改区域定位相结合。</p>\n<ul>\n<li>Yang等人[6]先提取相同频率的量化DCT系数，建立新的数据矩阵，然后考虑方向对DCT域相邻位置相关性的影响，执行12种不同方向的高通滤波模板，计算每个滤波数据的平移概率矩阵。然后利用PCA和SVM分别对特征维数进行降维和分类器训练，以此确定图像是否被篡改。</li>\n<li>Wang等人[7]利用Laplacian分布来描述在拼接区域和原图像的DCT系数分布，通过估计DCT块的后验概率来确定被篡改区域。</li>\n<li>Amerini等人[8]使用卷积神经网络（CNN）实现了JPEG重压缩的篡改定位。</li>\n<li>Zhou等人[9]使用一种双通道的快速R-CNN网络，并对其进行端到端的训练，对图像进行篡改检测。双通道之一是<strong>RGB流</strong>，其目的是从RGB图像输入中提取特征，以发现篡改特征，如强烈的对比度差、非自然的篡改边界等。<strong>另一种是利用隐写分析丰富模型滤波层提取的噪声特征</strong>，发现真实区域和篡改区域之间的噪声不一致。然后，通过双线性池化层融合来自两种流的特征，进一步合并这两种模式的检测结果。</li>\n</ul>\n<p>除JPEG压缩外，已经有一些学者研究更为一般的情况，估计图像可能经受过的各种变换和压缩。</p>\n<ul>\n<li>Tagliasacchi等人[10]给出了一个<strong>一般估计使用的图像变换技术和量化步长的方法</strong>。</li>\n<li>Bianchi等人[11]<strong>给出了一个判定信号是否经历过格量化的最优检测子</strong>，进而将该检测方法应用于实际的场景，并判断图像是否经历过双重JPEG压缩。<strong>但该方法要求两次压缩使用的块划分必须相同</strong>。</li>\n</ul>\n<h3 id=\"增强操作取证技术\"><a href=\"#增强操作取证技术\" class=\"headerlink\" title=\"增强操作取证技术\"></a>增强操作取证技术</h3><p>在现实生活中，经常会遇到数码设备由于光线、环境以及设备自身性能的问题而得到不清晰的图像，导致无法辨识原始图像中的关键目标，需要对图像进行增强处理。图像增强指通过某些图像处理操作，如对比度增强、中值滤波、锐化、模糊等，对原始图像附加一些信息或变换数据，有目的地突出图像中某些“有用”信息或者抑制掩盖图像中某些“无用”信息，扩大图像中不同物体特征之间的差别，以改善图像的视觉效果，丰富信息量。<strong>然而，图像增强操作可以淡化隐藏其他篡改操作的痕迹，达到降低篡改检测性能的目的。</strong>目前，<strong>图像增强操作取证</strong>研究已经吸引了国内外学者的广泛关注，并取得了一些阶段性成果。</p>\n<h4 id=\"对比度增强取证\"><a href=\"#对比度增强取证\" class=\"headerlink\" title=\"对比度增强取证\"></a>对比度增强取证</h4><p>对比度增强是一种被广泛使用的图像增强处理技术，是对图像中每个像素点的值进行非线性映射，通过累积函数对灰度值进行调整，改变图像中像素强度的整体分布，最终达到对比度的增强效果。</p>\n<ul>\n<li>Stamm等人[12]利用像素值映射在图像直方图上的统计特征，通过观察对比度增强操作向图像直方图的高频成分添加的能量信息，<strong>检测对比度增强操作</strong>。</li>\n<li>Cao等人[13]提出了零波谷特征，即当图像经过对比度增强操作处理后，图像直方图能呈现出明显的波峰波谷，并且生成的波谷都是值为0的零波谷。利用零波谷特征，基于阈值化二类分类检测对比度增强操作。</li>\n<li>Zhang等人[14]提出一种深度多路径网络，基于灰度直方图，通过共享多个卷积层捕获图像底层特征，并利用由多条路径组成的特定操作层学习不同对比度增强操作的特征，最后通过聚合层对原始图像和对比度增强操作处理的图像进行分类。</li>\n<li>王金伟等人[15]提出一种基于线性模型的图像对比度增强检测算法，提取图像噪声残差，采取分块策略计算每块残差的线性模型，并计算相应的功率谱密度，以整幅图像的均值功率谱密度作为分类特征，利用支持向量机进行分类。</li>\n</ul>\n<h4 id=\"模糊取证\"><a href=\"#模糊取证\" class=\"headerlink\" title=\"模糊取证\"></a>模糊取证</h4><p>为了消除图像篡改在拼接边缘产生的视觉或统计上的畸变，通常会在图像篡改后使用模糊操作消除简单拼接留下的伪造痕迹。模糊操作的基本原理是对图像的局部邻近像素值进行邻域灰度平均。</p>\n<ul>\n<li>周琳娜等人[16]提出一种基于图像形态学滤波边缘特征的模糊操作取证方法，用同态滤波和形态学滤波增强模糊操作的图像边缘，利用离焦模糊和人工模糊的边缘特性，<strong>检测伪造图像的模糊操作痕迹</strong>。</li>\n<li>Su等人[17]提出一种三维模糊识别方法，将图像划分为非模糊区、离焦模糊区和运动模糊区，利用梯度信息预测不同类型的模糊区域，并采用超像素分割技术对模糊区域进行细化识别。</li>\n<li>Xu等人[18]提出几种新的局部模糊度量方法，使用不同类型的图像信息，包括颜色、梯度和光谱信息，基于支持向量机，构造最优模糊检测分类器。</li>\n</ul>\n<h4 id=\"中值滤波取证\"><a href=\"#中值滤波取证\" class=\"headerlink\" title=\"中值滤波取证\"></a>中值滤波取证</h4><p>中值滤波操作是一种高度非线性操作，由于其良好的平滑滤波性质，通常被用于反取证技术中[19-20]，使得中值滤波取证越来越受到关注。</p>\n<ul>\n<li>Kirchner等人[21]利用图像差分转移概率矩阵构造特征，检测图像是否经过中值滤波操作处理。</li>\n<li>Kang等人[22]利用中值滤波残差特征，将特征相邻元素之间的关系建模为自回归模型，利用自回归系数检测中值滤波。</li>\n<li>彭安杰等人[23]提出一种基于中值滤波残差及其差分的鲁棒中值滤波取证技术，根据方向性和对称性将多方向差分特征分组，分别建立自回归模型，并提取其模型参数和直方图特征，组合成中值滤波检测特征。</li>\n</ul>\n<h4 id=\"锐化取证\"><a href=\"#锐化取证\" class=\"headerlink\" title=\"锐化取证\"></a>锐化取证</h4><p>锐化滤波常用于增强图像的局部对比度，使边缘和文理等细节变得更加清晰锐利。同样，作为常用的图像润饰操作，锐化经常被用于削弱掩盖图像篡改时遗留的痕迹。</p>\n<ul>\n<li>Cao等人[24]提出了一种有效的过冲效应测度方法，进而提取有效的指纹特征，通过阈值化分类来鉴别图像是否经历过USM锐化操作。</li>\n<li>Ding等人[25]提出一种基于局部二值模式LBP的锐化检测方法，采用Canny算子进行边缘检测，将LBP应用于图像检测到的边缘像素并提取特征，基于支持向量机进行锐化分类。</li>\n<li>F. Ding等人[26]利用图像USM锐化引起的纹理变化，提出一种边缘垂直二值编码的USM锐化检测方法。</li>\n</ul>\n<h3 id=\"几何操作取证技术\"><a href=\"#几何操作取证技术\" class=\"headerlink\" title=\"几何操作取证技术\"></a><strong>几何操作取证技术</strong></h3><p>当一幅图像被篡改时，例如拷贝一副图像的某一区域覆盖到被篡改图像中，篡改者通常需要<strong>采取缩放、旋转等几何变换来掩盖篡改痕迹</strong>。而这一过程需要对图像重新采样和重构，因此图像重采样检测是数字图像取证中十分重要的研究课题。重采样取证主要包含两个主要的研究目标，第一是<strong>判断图像是否经过重采样的重采样检测</strong>，第二是<strong>估计重采样操作过程中施加于图像上的相关参数，如重采样因子、旋转角度</strong>等。</p>\n<h4 id=\"缩放取证\"><a href=\"#缩放取证\" class=\"headerlink\" title=\"缩放取证\"></a>缩放取证</h4><p>缩放操作是最常见的几何操作，常见于篡改图像后，调整篡改区域的大小以适配图像内容。然而在实际情况中，受限于网络传输速度与机器存储容量，篡改图像在缩放前后很可能会经历JPEG压缩。</p>\n<p>因此，涉及缩放操作的重采样取证有两大类研究方向，第一是针对无JPEG压缩的单一重采样取证场景；第二是和JPEG压缩操作相结合的复合取证场景，根据JPEG压缩出现的顺序，该场景可细分为三种复合取证场景，即Pre-JPEG重采样<strong>（JPEG格式缩放后保存为无损格式）</strong>、Post-JPEG重采样<strong>（无损格式缩放后保存为JPEG格式）</strong>和Double-JPEG重采样<strong>（JPEG格式缩放后保存为JPEG格式）</strong>三种情况。</p>\n<p>针对无JPEG压缩的单一重采样取证场景，重采样图像中每一个像素都由原始像素与插值函数卷积而成，且像素之间隐藏着重采样痕迹。由于插值的影响，这种重采样痕迹反映在空域上体现为像素之间存在相关性[27]，且相邻插值像素的间隔存在一种周期性；反映在频域上体现为存在频谱峰值，且峰值位置与放缩因子有关[28]。鉴于重采样操作的这些特点，近年来专家学者们提出了许多重采样检测算法，虽然这些算法的思路各异，但是大体都遵循一个流程。首先，从待检测图像中通过某种方式提取出残差信号，这种残差信号放大了重采样痕迹，剔除噪音与视觉信息，显性的揭露出重采样操作遗留下的周期性。根据所采用的数学模型不同，这种残差信号可以通过计算图像的二阶差分获得[29]，也可以通过快速滤波计算出插值像素得到相应的概率图[30]。在得到蕴含周期性的残差信号后，第二步就是根据这种信号判别重采样操作的存在，最常用的手段是频谱方法，通过对残差信号进行傅里叶变换，由于周期函数傅里叶变换的特殊性，重采样图像的频谱图上会出现与放缩因子有关的频谱峰值[28]，这些峰值可以作为重采样操作存在的证据，更进一步，根据峰值与放缩因子的关系估计出相应的放缩因子。除此之外，可以将第一步得到的残差信号视为手工设计的特征，作为输入训练一个强有力的分类器，通过数据驱动学习一个重采样判别模型[31]。更进一步，可以借鉴深度学习在图像检测领域的发展，提出用于重采样检测和因子估计的深度网络[32-35]。</p>\n<p>然而上述方法无法直接运用于与JPEG压缩操作相结合的复合取证场景，这是因为JPEG压缩通过分块将图像保存并复原，使得JPEG图像像素之间先天就带有周期性，当与放缩操作结合时，会混淆放缩操作带来的周期性，最终形成复合的周期，使得现有的重采样图像检测算法失效。</p>\n<ul>\n<li>针对Pre-JPEG重采样的情况，Liu等人[36]基于自相关函数构建了重采样图像的数学模型，他们通过该模型推导出了重采样系数、插值函数和重采样谱峰位置的关系，他们提出了基于图像差分极值点距离直方图的方法，通过挖掘图像差分的规律来取证重采样操作和进行因子估计。而后，他们还提出了针对Post-JPEG重采样图像的取证方案[37]，他们基于循环平稳信号分析发现Post-JPEG重采样图像上会出现一系列的对称谐波峰，并提出一种基于相位抵消的图像重采样检测和因子估计方法。</li>\n<li>除此之外，Lu等人[38]还提出了基于反缩放策略的双域联合估计算法，从频谱域和DCT域综合估计重采样因子，他们首先通过搜索匹配从Double-JPEG图像频谱中提取数个可能的候选因子，然后根据DCT域系数的独立同分布模型，使用反缩放策略得到最优估计。</li>\n</ul>\n<h4 id=\"旋转取证\"><a href=\"#旋转取证\" class=\"headerlink\" title=\"旋转取证\"></a>旋转取证</h4><p>旋转操作也是常见的几何操作之一，同样涉及到图像像素重采样，在空域和频域上的操作痕迹与缩放操作有许多共通之处。</p>\n<ul>\n<li>Wei等人将旋转操作视为一种特殊的缩放操作[39]，将旋转角度与特定的缩放因子结合在一起，通过频谱峰值与缩放因子的关系推导出图像经历的旋转角度，不仅如此，他们发现不同的频谱提取操作顺序可以更加明显的突出重采样峰值特征，有利于进一步区分旋转操作和缩放操作，并在此基础上提出了只包含旋转和缩放的二次几何变换操作链恢复算法。</li>\n<li>此后，Chen等人[40]提出对图像连续几何变换的取证方法，他们基于平方信号分析图像重采样特征，将Gallagher的理论推广到连续二次几何变换领域，揭示了二次几何变换的频谱特征，并提出了更细粒度的只包含旋转和缩放的二次几何变换操作链恢复算法。随后，他们根据二维自相关函数，提出了针对旋转缩放等仿射变换的参数估计方案[41]。</li>\n</ul>\n<h3 id=\"操作链取证技术\"><a href=\"#操作链取证技术\" class=\"headerlink\" title=\"操作链取证技术\"></a>操作链取证技术</h3><p>实际的图像处理过程可能包含多个操作，它们按照一定的顺序共同构成图像操作链。当图像经历多种操作处理时，不同操作遗留在图像中的痕迹可能相互叠加和覆盖，从而导致某个操作的遗留痕迹被掩盖或者破坏。同时，痕迹间的相互影响与操作的执行顺序有关，当操作顺序发生变化时，最终的遗留痕迹也会有所不同。因此，由于多个操作之间的相互影响，针对单个篡改操作的取证方法难以满足图像操作链取证的实际需求。<strong>为了完整地揭示数字图像可能经历的处理过程，需要明确图像操作链包含的操作类型，多个操作的拓扑顺序，以及处理操作的关键参数。目前，图像操作链取证研究可以粗略的分为基于传统手工特征的方法和基于深度学习的方法。</strong></p>\n<h4 id=\"基于传统手工特征的方法-1\"><a href=\"#基于传统手工特征的方法-1\" class=\"headerlink\" title=\"基于传统手工特征的方法\"></a>基于传统手工特征的方法</h4><ul>\n<li>西班牙维戈大学P. Comesaña于2012年最先提出操作链取证[42]。他从理论上分析了利用已有的单操作篡改取证算法检测图像操作链的可能性,并以量化和加性高斯白噪声组成的操作链为例进行了实验验证。随后, 他还进一步实验分析了包含更多操作的操作链拓扑结构[43]。</li>\n<li>Stamm [44]等人针对对比度增强与缩放组成的二元操作链取证，提出采用直方图缺值特征和图像预测误差评价，分别进行对比度增强和图像缩放的检测，并引入了条件指纹的概念，用以单独识别对比度增强先于缩放操作的操作顺序。</li>\n<li>Li [45]等人针对内容感知缩放和对比度增强组成的二元操作链取证，提出了通过计算马尔科夫一步转移概率矩阵以及提取DCT域的高维特征进行检测的方法。</li>\n<li>Chu [46]等人从信息论的角度分析了操作顺序检测的可能性以及最优检测阈值的选取问题。</li>\n<li>Gao等人[47]将操作可检测性问题转换为复杂假设检验问题，提出一种基于信息理论框架的图像操作链中特定操作的检测方案。</li>\n<li>Chen等人[48]提出了一种基于决策融合的图像操作链中操作类型识别方法，挖掘不同图像特征，获取不同的取证证据。基于可信度计算策略，重新分配各证据权重，并通过决策融合识别操作链中包含的操作类型。</li>\n<li>Liao等人[49]从操作相关性程度分析入手，开展操作链的参数估计研究。通过探究操作顺序和参数变化对生成图像及已有参数估计特征所带来的影响，将操作链中各操作间相关性分为耦合与非耦合，并设计了不同的参数估计策略。</li>\n</ul>\n<h4 id=\"基于深度学习的方法-3\"><a href=\"#基于深度学习的方法-3\" class=\"headerlink\" title=\"基于深度学习的方法\"></a>基于深度学习的方法</h4><ul>\n<li>Boroumand等人[50]针对特定二元操作链，通过<strong>在卷积神经网络结构中添加全局平均池化层</strong>, 实现对任意尺寸篡改图像的操作种类鉴别。</li>\n<li>Stamm等人[51]基于设计的CNN约束分类器, <strong>通过联合提取与操作序列相关的条件指纹特征</strong>, 实现了对特定二元操作序列的种类识别和顺序鉴定。</li>\n<li>Chen等人[52]设计了一个自动化的神经网络，通<strong>过强化学习生成高性能的神经网络，用于多目标取证和处理历史检测。</strong>同时，利用基于模块的搜索空间，通过密集连接，提升网络设计效率。</li>\n<li>Liao等人[53]提出了<strong>基于双流卷积神经网络的图像操作链取证框架</strong>，并设计了多个针对特定操作组合的预处理。该网络包括空域卷积流和变换特征提取流，利用空域卷积流提取可视篡改特征，而变换特征提取流则通过结合针对性设计的预处理从图像的变换域提取残差特征。</li>\n</ul>\n<h3 id=\"小结与思考-1\"><a href=\"#小结与思考-1\" class=\"headerlink\" title=\"小结与思考\"></a><strong>小结与思考</strong></h3><p>图像处理操作取证是多媒体安全领域中的热点问题，除了上述处理操作的取证，小波去噪、直方图均衡化、仿射变换等图像处理操作的取证也都受到了政治、经济、社会文化等多个领域的广泛关注。尽管图像处理取证技术已经在特定篡改操作的取证等方面取得了阶段性进展，但在研究的深度和广度上仍未成熟，还有一些亟待解决的问题，主要表现在：</p>\n<ol>\n<li>在已知图像处理操作的情况下，可以通过模拟操作来训练模型，但对未知操作，如何设计对不同强度、不同操作组合均有效的取证模型是值得进一步探索的方向。</li>\n<li>当图像经历多种处理操作编辑润饰时，<strong>不同操作的痕迹相互掩盖混淆</strong>，图像处理操作取证变得困难。大多<strong>数图像处理操作取证方法是对单个特定操作或者特定二元操作链检测有效</strong>，<strong>缺乏适用于各种图像处理操作链取证</strong>的通用理论基础。</li>\n</ol>\n<h3 id=\"参考文献-1\"><a href=\"#参考文献-1\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>[1]S. Shang, Y. Zhao, and R. Ni. Double JPEG detection using high order statistic features. IEEE International Conference on Digital Signal Processing (DSP), Beijing, China, pp. 550-554, 2016.</p>\n<p>[2]X. Zeng, G. Feng, and X. Zhang. Detection of double JPEG compression using modified DenseNet model. Multimedia Tools and Applications, vol. 78, no. 7, pp. 8183-8196, 2019.</p>\n<p>[3]J. Wang, W. Huang, X. Luo, Y.-Q. Shi, and S. Kr. Jha. Non-aligned double JPEG compression detection based on refined Markov features in QDCT domain. Journal of Real-time Image Processing, vol. 17, no. 1, pp.7-16, 2019.</p>\n<p>[4]F. Galvan, G. Puglisi, A. R. Bruna, and S. Battiato. First quantization matrix estimation from double compressed JPEG images. IEEE Transactions on Information Forensics and Security, vol. 9, no. 8, pp. 1299-1310, 2014.</p>\n<p>[5]T. Hai Thai, R. Cogranne, F. Retraint, and T. Doan. JPEG quantization step estimation and its applications to digital image forensics. IEEE Transactions on Information Forensics and Security, vol. 12, no. 1, pp. 123-133, 2017.</p>\n<p>[6]P. Yang, R. Ni, and Y. Zhao. Double JPEG compression detection by exploring the correlations in DCT domain. Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC), Honolulu, HI, USA, pp. 728-732, 2018.</p>\n<p>[7]W. Wang, J. Dong, and T. Tan. Exploring DCT coefficient quantization effects for local tampering detection. IEEE Transactions on Information Forensics and Security, vol. 9, no. 10, pp. 1653-1666, 2014.</p>\n<p>[8]I. Amerini, T. Uricchio, L. Ballan, and R. Caldelli. Localization of JPEG double compression through multi-domain convolutional neural networks. IEEE Conference on Computer Vision and Pattern Recognition Workshops (CVPRW), Honolulu, HI, USA, pp. 1865-1871, 2017.</p>\n<p>[9]P. Zhou, X. Han, V. I. Morariu, and L. S. Davis. Learning Rich Features for Image Manipulation Detection. IEEE Conference on Computer Vision and Pattern Recognition (CVPR), Salt Lake City, UT, USA, pp. 1053-1061, 2018.</p>\n<p>[10]M. Tagliasacchi, M. V.-Scarzanella, P. L. Dragotti, and S. Tubaro. Transform coder identification. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Vancouver, BC, Canada pp. 5785-5789, 2013.</p>\n<p>[11]T. Bianchi, A. Piva, and F. Pérez-González. Near optimal detection of quantized signals and application to JPEG forensics. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 168-173, 2013.</p>\n<p>[12]M. C. Stamm, and K. J. Ray Liu. Forensic detection of image manipulation using statistical intrinsic fingerprints. IEEE Transactions on Information Forensics and Security, vol. 5, no. 3, pp. 492-506, 2010.</p>\n<p>[13]G. Cao, Y. Zhao, R. Ni, and X. Li. Contrast enhancement-based forensics in digital images. IEEE Transactions on Information Forensics and Security, vol. 9, no. 3, pp. 515-525, 2014.</p>\n<p>[14]C. Zhang, D. Du, L. Ke, H. Qi, and S. Lyu. Global contrast enhancement detection via deep multi-path network. International Conference on Pattern Recognition (ICPR), Beijing, China, pp. 2815-2820, 2018.</p>\n<p>[15]王金伟, 吴国静. 基于线性模型的图像对比度增强取证[J]. 网络空间安全, 2019, vol. 10, no. 8, pp. 47-54.</p>\n<p>[16]周琳娜, 王东明, 郭云彪, 杨义先. 基于数字图像边缘特性的形态学滤波取证技术[J]. 电子学报, 2008, vol. 36, no. 6, pp. 1047-1051.</p>\n<p>[17]B. Su, S. Lu, and C. L. Tan. Blurred image region detection and classification. ACM International Conference on Multimedia (ACM MM), New York, NY, USA, pp. 1397-1400, 2011.</p>\n<p>[18]W. Xu, J. Mulligan, D. Xu, and X. Chen. Detecting and classifying blurred image regions. IEEE International Conference on Multimedia and Expo (ICME), San Jose, CA, USA, 2013.</p>\n<p>[19]M. Kirchner, and R. Bohme. Hiding traces of resampling in digital images. IEEE Transactions on Information Forensics and Security, vol. 3, no. 4, pp. 582-592, 2008.</p>\n<p>[20]M. C. Stamm, and K. J. Ray Liu. Anti-forensic of digital image compression. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1050-1065, 2011.</p>\n<p>[21]M. Kirchner, and J. Fridrich. On detection of median filtering in digital images. The SPIE-Media Forensics and Security, San Jose, USA, pp. 754110-1-75411012, 2010.</p>\n<p>[22]X. Kang, M. C. Stamm, A. Peng, and K. J. Ray Liu. Robust median filtering forensics using an autoregressive model. IEEE Transactions on Information Forensics and Security, vol. 8, no. 9, pp. 1456-1468, 2013.</p>\n<p>[23]彭安杰, 康显桂. 基于滤波残差多方向差分的中值滤波取证技术[J]. 计算机学报, 2016. vol. 39, no. 3, pp. 503-515.</p>\n<p>[24]G. Cao, Y. Zhao, R. Ni, and A. C. Kot. Unsharp masking sharpening detection via overshoot artifacts analysis. IEEE Signal Processing Letters, vol. 18, no. 10, pp. 603-606, 2011.</p>\n<p>[25]F. Ding, G. Zhu, and Y. Q. Shi. A novel method for detecting image sharpening based on local binary pattern. International Conference on Digital Forensics and Watermarking (IWDW), Berlin, Germany, pp. 180-191, 2013.</p>\n<p>[26]F. Ding, G. Zhu, J. Yang, J. Xie, and Y. Q. Shi. Edge perpendicular binary coding for USM sharpening detection. IEEE Signal Processing Letters, vol. 22, no. 3, pp. 327-331, 2015.</p>\n<p>[27]A. C. Popescu, and H. Farid. Exposing digital forgeries by detecting traces of resampling. IEEE Transactions on Signal Processing, vol. 53, no. 2, pp. 758-767, 2005.</p>\n<p>[28]A. C. Gallagher. Detection of linear and cubic interpolation in JPEG compressed images. Canadian Conference on Computer and Robot Vision (CRV), Victoria, BC, Canada, pp. 65-72, 2005.</p>\n<p>[29]B. Mahdian, and S. Saic. Blind authentication using periodic properties of interpolation. IEEE Transactions on Information Forensics and Security, vol. 3, no. 3, pp. 529-538, 2008.</p>\n<p>[30]M. Kirchner. Fast and reliable resampling detection by spectral analysis of fixed linear predictor residue. ACM Workshop on Multimedia and Security (MM &amp; Sec), Oxford, UK, pp. 11-20, 2008.</p>\n<p>[31]X. Feng, I. J. Cox, and D. Gwenaël. Normalized energy density-based forensic detection of resampled images. IEEE Transactions on Multimedia, vol. 14, no. 3, pp. 536-545, 2012.</p>\n<p>[32]B. Bayar, and M. C. Stamm. On the robustness of constrained convolutional neural networks to JPEG post-compression for image resampling detection. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), New Orleans, LA, USA, pp. 2152-2156, 2017.</p>\n<p>[33]B. Bayar, and M. C. Stamm. Constrained convolutional neural networks: A new approach towards general purpose image manipulation detection. IEEE Transactions on Information Forensics and Security, vol. 13, no. 11, pp. 2691–2706, 2018.</p>\n<p>[34]C. Liu, and M. Kirchner. CNN-based rescaling factor estimation. ACM Workshop, pp. 119–124, 2019.</p>\n<p>[35]S. Luo, J. Luo, W. Lu, Y. Fang, J. Zeng, S. Shi, and Y. Zhang. Resampling factor estimation via dual-stream convolutional neural network. Computers, Materials &amp; Continua, vol. 66, no. 1, pp. 647–657, 2021.</p>\n<p>[36]X. Liu, W. Lu, Q. Zhang, J. Huang, and Y. Shi. Downscaling factor estimation on pre-JPEG compressed images. IEEE Transactions on Circuits and Systems for Video Technology, vol. 30, no. 3, pp. 618-631, 2019.</p>\n<p>[37]Q. Zhang, W. Lu, T. Huang, S. Luo, Z. Xu, and Y. Mao. On the robustness of JPEG post-compression to resampling factor estimation. Signal Processing, vol. 168, pp. 107371, 2020.</p>\n<p>[38]W. Lu, Q. Zhang, S. Luo, Y. Zhou, J. Huang, and Y. Q. Shi. Robust estimation of upscaling factor on double JPEG compressed images. IEEE Transactions on Cybernetics, pp. 1-13, 2021.</p>\n<p>[39]W. Wei, S. Wang, X. Zhang, and Z. Tang. Estimation of image rotation angle using interpolation-related spectral signatures with application to blind detection of image forgery. IEEE Transaction on Information Forensics and Security, vol. 5, no. 3, pp. 507-517, 2010.</p>\n<p>[40]C. Chen, J. Ni, Z. Shen, and Y.Q. Shi. Blind forensics of successive geometric transformations in digital images using spectral method: theory and applications. IEEE Transactions on Image Processing, vol. 26, no. 6, pp. 2811-2824, 2017.</p>\n<p>[41]J. Ou, and J. Ni. Blind estimation of affine transformation using 2D cyclostationarity of resampled images. Mippr: Multispectral Image Acquisition, Processing, &amp; Analysis International Society for Optics and Photonics, 2015.</p>\n<p>[42]P. Comesaña. Detection information theoretic measures for quantifying the distinguishability between multimedia operator chains. IEEE International Workshop on Information Forensics and Security (WIFS), Tenerife, Spain, pp. 211-216, 2012.</p>\n<p>[43]P. Comesaña, and F. P. González. Multimedia operator chain topology and ordering estimation based on detection and information theoretic tools. International Conference on Digital Forensics and Watermarking (IWDW), Berlin, Germany, pp. 213-227, 2013.</p>\n<p>[44]M. C. Stamm, X. Chu, and K. J. Ray Liu. Forensically determining the order of signal processing operations. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 162-167, 2013.</p>\n<p>[45]J. Li, Y. Zhao, and R. Ni. Detection of seam carving and contrast enhancement operation chain. International Conference on Intelligent Information Hiding and Multimedia Signal Processing (IIH-MMSP), Adelaide, SA, Australia, pp. 235-238, 2015.</p>\n<p>[46]X. Chu, Y. Chen, and K. J. Ray Liu. Detectability of the order of operations: An information theoretic approach. IEEE Transactions on Information Forensics and Security, vol. 11, no. 4, pp. 823-836, 2016.</p>\n<p>[47]S. Gao, X. Liao, and X. Liu. Real-time detecting one specific tampering operation in multiple operator chains. Journal of Real-Time Image Processing, vol. 16, pp. 741-750, 2019.</p>\n<p>[48]J. Chen, X. Liao, and Z. Qing. Identifying tampering operations in image operator chains based on decision fusion. Signal Processing: Image Communication, vol. 95, pp. 116287-1-116287-10, 2021.</p>\n<p>[49]X. Liao, and Z. Huang. A framework for parameters estimation of image operator chain. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Barcelona, Spain, pp. 2787-2791, 2020.</p>\n<p>[50]M. Boroumand, and J. Fridrich. Deep learning for detecting processing history of images. Electronic Imaging, pp. 213-1-213-9, 2018.</p>\n<p>[51]B. Bayar, and M. C. Stamm. Towards order of processing operations detection in JPEG-compressed images with convolutional neural networks. Electronic Imaging, pp. 211-1-211-9, 2018.</p>\n<p>[52]Y. Chen, Z. Wang, Z. J. Wang, and X. Kang. Automated design of neural network architectures with reinforcement learning for detection of global manipulations. IEEE Journal of Selected Topics in Signal Processing, vol. 14, no. 5, pp. 997-1011, 2020.</p>\n<p>[53]X. Liao, K. Li, X. Zhu, and K. J. Ray Liu. Robust detection of image operator chain with two-stream convolutional neural network. IEEE Journal of Selected Topics in Signal Processing, vol. 14, no. 5, pp. 955-968, 2020.</p>\n<h2 id=\"视频编辑篡改检测Video-manipulation-Detetion综述\"><a href=\"#视频编辑篡改检测Video-manipulation-Detetion综述\" class=\"headerlink\" title=\"视频编辑篡改检测Video manipulation Detetion综述\"></a>视频编辑篡改检测Video manipulation Detetion综述</h2><p>从公开发表论文数量来看，目前绝大多数的篡改被动检测算法都是专用篡改检测算法，且效果十分显著，但需要已知篡改方法和类型的先验知识.通用篡改检测算法针对多种或未知篡改检测准确率良好但也具有一定局限性，实用性和泛化能力有待提高，且对篡改类型的辨识能力不足，只能判断是否经历了篡改操作；<strong>针对多类型+多次篡改的溯源篡改操作链识别能力有限，这也是未来可能的研究方向之一。</strong></p>\n<p><strong>通用篡改检测算法</strong>的最大优势就是快速筛选可疑视频和辨识经历一次及以上篡改的数字视频，然后再用专用算法探测或穷举识别其可能的篡改操作类型或者溯源篡改操作链。总而言之，两者技术是互补关系。</p>\n<h3 id=\"数字视频再编辑篡改技术\"><a href=\"#数字视频再编辑篡改技术\" class=\"headerlink\" title=\"数字视频再编辑篡改技术\"></a>数字视频再编辑篡改技术</h3><p>数字视频编辑篡改技术的一般定义：为了视频画面提质、传输、存储，或改变内容内在关系的后编辑操作的技术集合。这一后编辑操作可能是常规的需求，也可能是恶意的目的。目前，本文中将常见的数字视频编辑篡改技术分为<strong>四大类</strong>：</p>\n<ol>\n<li>数字视频<strong>文件再编辑</strong>的篡改方法：本文是指针对数字视频的码流、或者编码参数、容器等的编辑，达到对原始视频文件的再编辑目的，一般不改变视频内容。例<strong>如，码率重采样、视频格式转码、容器转换、各种滤波器操作等后处理操作</strong>；</li>\n<li>数字视频<strong>内容再编辑</strong>的篡改方法：本文是指针对数字视频的部分解码或完全解码后内容进行内容级编辑操作，达到对原始视频内容的再编辑目的。例如，<strong>视频帧间插入/删除攻击、帧内复制粘贴攻击操作</strong>等；</li>\n<li>数字视频<strong>内容生成</strong>的篡改方法：本文是指<strong>针对数字视频内容的部分生成替换</strong>或全部生成虚拟目标全局替换，进行视频内容级编辑操作，达到对原始视频内容的再编辑目的。例如，使用StyleGAN网络生成虚拟人物或目标的视频内容等操作；</li>\n<li>数字视频的<strong>重拍摄篡改</strong>方法：本文是指针对数字视频内容的重新数字采集再编辑操作，达到对原始视频内容的再编辑目的。例如，<strong>利用数字设备对屏幕画面进行重新拍摄和再编辑操作</strong>。</li>\n</ol>\n<h4 id=\"视频文件再编辑篡改\"><a href=\"#视频文件再编辑篡改\" class=\"headerlink\" title=\"视频文件再编辑篡改\"></a>视频文件再编辑篡改</h4><p>视频文件再编辑篡改是指在不改变视频内容的前提下对视频文件的编辑操作，比如转码操作、分辨率提升/降低、平滑操作、锐化操作、去噪操作、信息隐藏操作等。</p>\n<p>例如，数据隐藏技术可以在不影响视觉效果的前提下，向视频内嵌入信息，实现对视频文件的编辑。例如，北京交通大学的李赵红[4]等人研究了P帧种各尺寸PU划分类型在隐写前后的数目变化，构建了25维和3维特征用来检测HEVC视频的块划分模式隐写算法。帧率变化是通过提升或下降视频的帧率方法来达到编辑视频文件的目的。Khoubani[5]等人基于模糊平滑的快速四元数小波运动补偿进行帧率上转换。这篇论文使用图像序列的相位来考虑QWT运动估计，实现了更准确的运动估计、更少的后处理流程和更低的复杂度。码率变换是另外一种视频文件编辑的方法，Kevin[6]等人提出一种通过求解优化问题来选择比特率的方法即Bola算法。Yin等人[7]提出了MPC算法。Kim[8]等人结合残差学习方式提出了IFCNN网络，用以取代视频编码中的环路滤波算法，即把未经环路滤波的重建图像直接输入网络进行增强处理。</p>\n<h4 id=\"数字视频内容编辑篡改方法\"><a href=\"#数字视频内容编辑篡改方法\" class=\"headerlink\" title=\"数字视频内容编辑篡改方法\"></a>数字视频内容编辑篡改方法</h4><p>视频内容篡改是指部分解码或全解码后，针对音频、图象、视频中特定对象的操作过程，其结果是改变内容的原始属性，导致内容的不可信。从视频帧目标被攻击角度来看，数字视频内容编辑篡改分为<strong>帧间编辑篡改和帧内编辑篡改</strong>。</p>\n<p>视频的帧间编辑篡改方式主要有：帧删除篡改，即删除原始视频的至少一帧或连续多帧的操作；帧插入篡改，即非同源视频的帧片段插入到原视频帧序列中的操作；帧复制粘贴篡改，即同源视频的帧片段在相同视频中不同时间轴上复制插入到原视频中的操作。</p>\n<ul>\n<li>针对这类视频内容的帧间编辑篡改问题，2012年孙锬锋等人[9]提出了视频帧间篡改中主要篡改类型的定义，即包括视频帧复制粘贴、帧插入、帧删除等，其中对于帧的复制粘贴，可以划分为同源和异源两类，同源的帧复制表示复制的对象来自于当前视频片段，而异源帧复制粘贴是将其他视频的片段复制到当前视频片段中。</li>\n<li>2014年王婉等人[10]根据场景的差异性将视频内容编辑篡改划分为静止背景下的内容编辑篡改以及包含运动背景的篡改场景，并提出了一种可以同时检测帧删除，帧插入及帧复制的算法。</li>\n<li>同年柏正尧等人[11]针对帧间篡改对帧间相关性进行研究，并将非负张量分解（Nonnegative tensor factorization, NTF）算法应用到了视频帧间篡改检测中。</li>\n<li>冯春晖等人[13]通过分析残差强度在不同宏块间分布是否具有波动性来检测视频是否被帧删除，并定位删除点的位置。该作者在[13]的基础上进一步分析了具有丰富运动信息下的视频帧间篡改场景，考虑到运动视频容易导致帧间数据特征的变化，作者从帧间差异的角度，提出了一种删帧检测算法[14]，对复杂篡改环境下的序列中不同干扰帧进行分析，并利用运动残差特征区分不同干扰帧和删帧位置处的帧，进而提出一种去帧内编码处理算法，使算法能够应对运动信息带来的影响。</li>\n<li>不同于视频内容帧间篡改，视频内容帧内篡改并非以帧为单位进行篡改，而是以目标为单位进行编辑篡改操作，2021年Yang Quanxin等人[12] 指出视频帧内篡改主要有空域复制粘贴，帧内目标移除等，作者发现帧内篡改将引起视频在时空域上的高频信息的波动。</li>\n</ul>\n<h4 id=\"数字视频内容生成篡改方法\"><a href=\"#数字视频内容生成篡改方法\" class=\"headerlink\" title=\"数字视频内容生成篡改方法\"></a>数字视频内容生成篡改方法</h4><p>视频内容生成方法是指在GAN网络及其衍生网络根据对抗原理，即生成器和判别器构成网络，从一幅噪声图像不断逼近真实图象的方法，其生成局部或全部图象和视频并不是真实的物理拍摄获得，从而达到以假乱真的目的。</p>\n<ul>\n<li>例如，Elor[15]等人的方案可以生成含有人物的视频，并且可以通过扭曲来轻微改变人物的头部姿势。因为这种方法是基于单个目标图像的，它从源视频中的嘴唇内部复制到目标视频，因此仅能部分保留目标视频中的人物身份。</li>\n<li>Kim[16]等人的做法相对于以前的方法而言，可以生成更为逼真的视频。</li>\n<li>Zhouhang[17]等人使用音频来生成视频。他们将一个无声的视频分解为两部分，一部分是人物身份信息，另一部分是语音信息，这里的语音信息是指通过人物嘴部动作传递出来的广义语音信息，而非听到的声音。</li>\n<li>Fried[18]等人基于文本来编辑视频。给定任意文本，该方法就能改变一段视频中人物所说的话，同时保持无缝的试听流。要对一段视频中人物讲话内容进行改变，只需要编辑一下想要表达的文本内容，这种方法十分地简单易行。</li>\n<li>Suwajanakorn[19]等人对人脸中的口型进行替换，生成最终的伪造视频。</li>\n</ul>\n<h4 id=\"数字视频重拍摄的篡改方法\"><a href=\"#数字视频重拍摄的篡改方法\" class=\"headerlink\" title=\"数字视频重拍摄的篡改方法\"></a>数字视频重拍摄的篡改方法</h4><p>数字视频重拍摄的篡改方法是指物理上用物理设备对数字视频内容播放进行重拍摄而造成内容时空含义混乱，达到篡改内容的目的，也就是“二次拍摄篡改编辑”。</p>\n<p>现有的重拍摄的编辑篡改方法主要根据拍摄设备、拍摄场景以及拍摄对象的差异进行分类[20]。Lee[20]等人提出目前重拍摄视频大部分产生于视频投放到液晶屏幕（LCD）上时被重拍摄，因此该作者重点研究LCD显示的视频重拍摄编辑篡改，提出一种梳状纹理的特征识别其重拍摄操作。P. Bestagini[21]等人提出了同步性不一致的重拍摄编辑篡改，作者利用这种不一致性产生的块重影现象对重拍摄视频进行检测。另外，Xavier [22]等人根据电影被投影时引起屏幕空间上的亮度重分配效应、垂直投影在屏幕上的图像的稳定性效应、高频闪烁的显示屏与摄像机快门之间的相互作用这三种效应设计不同的重拍摄编辑篡改场景。Mahdian[23]等人分析了不同品牌LCD显示屏的重拍摄视频在频谱波纹上的差别。除了针对LCD屏幕的重拍摄，重拍摄编辑篡改还包括以手持摄像机拍摄的视频。此类视频中的运动分为帧内运动和手持引起的全局运动，其中全局运动为手持重拍摄独有的效应。Marco [24]等人提出了具有的全局运动特征的手持拍摄视频编辑篡改。另外，图像重拍摄编辑篡改方面的几个经典场景同样也可以在视频重拍摄上适用。比如Thongkamwitoon[25]针对图像的类别差异构建重拍摄图像集合，通过挖掘彩色图像和黑白图像在色度上的差异引起的重拍摄图像在像素上的失真特性对图像进行重拍摄检验。Anjum等人[26]通过挖掘图像中高层次边缘细节特征，进而根据在原始图像和重拍摄图像中不同组别的边缘像素数量具有一定差异这一特性，构建具有不同边缘特性的重拍摄场景并进行分类。</p>\n<h3 id=\"数字视频被动取证检测技术\"><a href=\"#数字视频被动取证检测技术\" class=\"headerlink\" title=\"数字视频被动取证检测技术\"></a>数字视频被动取证检测技术</h3><p>上述数字视频编辑技术表明了：</p>\n<ol>\n<li>数字视频无论是编码复杂性，还是数据量的规模庞大，都给篡改编辑带来了更多的可利用空间和隐藏空间；</li>\n<li>篡改攻击的角度多样性，导致了针对篡改类型的通用识别算法实现具有较大难度。</li>\n</ol>\n<p>针对上述篡改编辑类型，对目前已经取得的被动检测成果进行介绍和分析。我们把数字视频篡改被动取证技术<strong>分为三类</strong>：</p>\n<ol>\n<li><strong>时空域</strong>特征检测技术。即无论是音频、图象、视频完全解码后，就会是一种结构化或半结构化的媒体原始文件，在原始文件上，可以构建各种物理、几何、光学等的传统数学特征模型，而这些数学模型通常是某种目标特征属性的固定模式、或者连续变化的某种特征数据表征。篡改编辑的过程中会破坏这种上述固定内在模式，引起连续性质的某些突变、或者出现某些特殊非典型痕迹残留分布等情况，而这些情况就可以通过针对时空特征建模方法来加以检测和识别。<strong>代表性算法有光流特征、运动场特征、亮度变化率特征、块效应强度特征等。</strong></li>\n<li><strong>编码域</strong>特征检测技术。即在数字媒体不完全解码的情况下，码流域、编码域的编码参数、编码域的预测模式、编码域分块模式等环境下，同样具有潜在的首次编码后的系数分布规律和特殊内在统计模式。而这种潜在的分布规律和模式，需要构建高维特征模型，如高阶概率统计模型、多模态融合特征模型等才能洞悉其规律。而且这种高维特征模型对人眼和人耳不可感知的细微编辑痕迹更为敏感。而且编码技术本身也会对数字媒体产生失真效果，因此，对完全解码后媒体数据可能带来意想不到的影响。但是在编码域对篡改痕迹直接展开分析的同时，已经充分考虑了编码失真的影响，在检测过程中可以更加精细化感知各种篡改编辑残留的痕迹。<strong>代表性算法有PU数量统计特征、预测残差分布特征、宏块类型变化特征、DCT系数分布特征</strong>。</li>\n<li><strong>深度</strong>特征检测技术。即无论数字媒体是什么容器格式或者什么编码，首先需要生成大量的篡改样本，把篡改样本进行初步的预处理之后，直接送到深度网络模型中加以学习叠代，直到获得预期稳定的输出，此时深度网络特征模型已经完成了参数训练，此后只需要给定输入就可给出分类结果。当然目前为止，这样简单粗暴的方法效果并不明显。学者们纷纷提出了多样化的<strong>深度网络模型、预处理方法、增加Attention机制、修剪网络无意义的层、增加强化学习的机制</strong>等等。通过深度网络自主学习的能力，学习到人类目前无法感知的特征，增强对篡改数据规律知识的学习，最终能否优于人类设计特征的效果。但是目前为止，大部分的深度网络模型对全局学习的效果不佳。<strong>代表性算法有卷积神经网络、双通道残差网络、遗传卷积网络、混合深度学习网络</strong>。</li>\n</ol>\n<h4 id=\"时空域特征检测技术\"><a href=\"#时空域特征检测技术\" class=\"headerlink\" title=\"时空域特征检测技术\"></a>时空域特征检测技术</h4><p>在数字视频的拍摄过程中，<strong>相邻帧或像素之间往往存在一定的关联</strong>，而对于视频的篡改往往会破坏这种关联性，因此视频篡改操作往往会在时空与留下痕迹。在现有工作中，时空域的检测算法能够直接对篡改痕迹像素或帧之间的异常特性进行建模，但算法复杂度往往较高。</p>\n<ul>\n<li>文献[27]中，巢娟等人提出了一种基于光流一致性的帧间篡改检测方法，针对帧插入和帧删除的细微差别，提出了两种不同的检测方案。实验表明，该方案在识别帧插入和帧删除模型方面取得了较好的效果。</li>\n<li>在文献[28]中，吴俞醒等人提出了一种基于速度场一致性的视频帧间伪造（连续帧删除和连续帧复制）检测算法。在文献[3]中，许强等人结合GOP结构非对齐的HEVC重编码引起的质量下降特性，通过分析HEVC编码标准中帧间编码对重建像素值的影响，提出基于帧间质量下降机制分析的检测算法，该算法对GOP结构非对齐的重编码检测问题能取得0.98以上的AUC值。</li>\n<li>而对于视频转码检测，在[29]中，许强构建了去块滤波模式决策特征以及SAO补偿特征来进行重编码的检测，算法分别在公开数据集上进行了验证，算法能取得97.21%的平均准确率。</li>\n<li>在文献[30]、[31]中，何沛松等人将待测视频解码为一连串连续的视频帧后，根据块效应强度变化规律的不同能够对视频双编码视频进行检测。</li>\n<li>在文献[32]中，杨高波等人提出了一种基于边缘强度的被动取证方法来检测候选视频中可能的视频帧速率上转换（FRUC）操作。平均检测准确率达94.5%。</li>\n<li>在文献[33]中，边山等人在在大量实验的基础上，发现目前大多数视频编辑软件中采用的帧速率上转换算法不可避免地会在生成的视频帧序列的帧间相似性中引入一些周期性的伪影。</li>\n</ul>\n<p>综上所述，时空域特征检测技术可以较全面的解决帧间和帧内篡改编辑的被动检测问题，<strong>但仍存在一下问题</strong>：</p>\n<ol>\n<li>视频包含快速运动的信息，或者包含场景切换，算法的性能将下降。这个问题是目前被动检测算法中普遍存在的鲁棒性问题，有待改善。</li>\n<li>在重编码比特率较低时检测性能会出现明显下降。这是因为视频重编码时比特率（画面质量）较低，会造成严重的信息失真，与篡改编辑痕迹耦合在一起，造成检测困难。这一问题应该系统研究比特率变化与篡改编辑痕迹变化之间的关系。</li>\n<li>时空特征检测技术基本上都是针对专用篡改编辑而设计的，因此通用性和泛化能力都十分有限。有的算法对复合篡改编辑的方式显得无能为力。这也是未来要解决的重要问题之一。</li>\n</ol>\n<h4 id=\"编码域特征检测技术\"><a href=\"#编码域特征检测技术\" class=\"headerlink\" title=\"编码域特征检测技术\"></a>编码域特征检测技术</h4><p>视频重编码操作是在首次编码的基础上再一次执行编码操作，基于编码域特征统计分析的视频重编码痕迹检测算法实际上就是根据重编码操作对视频编码后的参数扰动关系构建检测依据，依赖手工设计的特征来进行检测的算法。</p>\n<ul>\n<li>在文献[34]中，DAVID等人提出了基于The Variation of Prediction Footprint（VPF）的二次编码篡改检测算法。</li>\n<li>文献[35]中，该团队在MPEG-2标准上提出了一种基于广义VPF（G-VPF）的双编码检测算法，在首次编码使用QP（QP1）大于重编码使用QP（QP2）的情况下达到了98%以上的准确率。</li>\n<li>在文献[38]中，赵耀等人通过对预测模式特征（PMF）的分析，提出了一种用于假高清视频场景的重编码检测方案，该方法首先从四个方向的帧内预测模式中提取一个四维特征。其次，从三个预测模式中提取了6维特征。最后，将这两种特征集结合到PMF中，检测出伪造高清视频，并进一步估计其原始QPs和比特率。</li>\n<li>在文献[39]中，蒋兴浩等人提出了一种基于帧内预测模式的新方法。文献分析了帧内编码的质量退化机理，并充分考虑了帧内编码的误差来源，建立了等效误差模型，随后提出了基于帧内预测模式统计特征的双HEVC编码检测特征模型。最后，用720p和1080p的HEVC视频代替低分辨率（CIF或QCIF）视频进行了实验。实验结果表明，与现有方法相比，该方法具有更好的效率。此外，该方法对不同的编码配置具有较强的鲁棒性。</li>\n</ul>\n<p>综上所述，该类检测算法能有效的检测普通场景下的重编码操作，<strong>但存在一些不足</strong>：</p>\n<ol>\n<li>算法过度依赖解码器对参数的提取，并且容易受到反取证手段的攻击。</li>\n<li>当视频包含强运动成分信息或场景切换时，算法性能将下降。</li>\n<li>智能编码技术的兴起，给重编码检测带来了新的危机。</li>\n</ol>\n<h4 id=\"深度特征检测技术\"><a href=\"#深度特征检测技术\" class=\"headerlink\" title=\"深度特征检测技术\"></a>深度特征检测技术</h4><p>近年来，卷积神经网络（CNN）已经在多媒体取证领域取得成功应用。CNN 能够从训练样本中自动有效地学习层次化的特征表达。受此启发，一系列算法利用卷积神经网络来解决视频重编码痕迹检测问题。</p>\n<ul>\n<li>在文献[40]中，何沛松等人首先建立视频帧集合，以 3 帧为单位进行分块，若 3 帧中第二帧为重定位I帧，则该片段定义为正样本，否则为负样本。通过这种预处理操作，构建一个卷积神经网络，利用平均池化，作者能很好地检测出重定位I帧。</li>\n<li>类似的在[41]中许强等人通过构建 Genetic CNN，来进行AVC视频中重定位 I 帧的检测。不同于一般的卷积神经网络，<strong>Genetic CNN 能够结合遗传算法，实现自动设计网络架构的目的</strong>，通过算法对比，该算法的有效性得到验证。</li>\n<li>在[42]中，何沛松等人通过<strong>构建一个混合深度神经网络来揭露伪高清的HEVC重编码视频</strong>。通过提取基于块的残差信号，并构建一个双支路的网络进行检测，不同分支的输出向量将拼接后再联合优化得到逐块的检测结果。最后采用多数投票(local-to-global)策略得到最终的检测结果。</li>\n<li>除此之外，何沛松等人在[2]中<strong>提出了一种混合神经网络</strong>，通过从编码域中的编码信息中学习鲁棒时空表示，来揭示具有双重编码的HEVC视频中异常帧。</li>\n<li>在[43]中，Gan等人提出了一种<strong>基于VGG-11卷积神经网络的视频帧内伪造取证算法</strong>，该算法能自动检测视频伪造帧。该算法首先将视频解编码为一系列帧，计算出每帧的运动剩余映射，提取隐写特征。然后，以四个不同的隐写特征样本集作为训练集，并将测试集作为训练和测试模型。通过对比实验，选择了最佳性能特征。最后，通过伪造视频对伪造的帧进行了成功的标记。</li>\n</ul>\n<p>综上所述，深度神经网络的运用在一定程度上解决了传统算法的缺陷，虽然这些算法都能够取得较高的准确率，<strong>但其仍然存在一系列局限性</strong>：</p>\n<ol>\n<li>大多数基于深度神经网络的算法对样本数量要求较高，并且需要耗费大量的时间训练网络模型。</li>\n<li>这些算法都是以重定位I帧或者块为单位作为输入，如何设计高效的网络<strong>实现视频级别的重编码痕迹检测</strong>是今后研究的重要方向。</li>\n<li>深度神经网络在提升了人工检测效率和准确率，但其深度网络的可解释性和学习到特征的可解释性仍然是不透明的，很多时候“过学习”的现象或者“欠学习”的问题普遍存在。这一问题有待进一步改善。</li>\n</ol>\n<h3 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h3><ol>\n<li>篡改编辑（攻击）残留痕迹与数字媒体编码技术的依赖关系尚存在空白领域有待探索。数字媒体<strong>各类编码标准的不同特性内在机制和信息失真模型理论、特征模型建模的方法论、算法检测框架的性能等问题</strong>，还需要不断完善，逐步建立起完整的被动检测理论体系；</li>\n<li>人工智能理论、深度网络学习方法与对抗篡改攻击技术互为对抗和相互融合是未来的发展趋势。目前新型的<strong>VVC编码已经采用了众多的神经网络模块替代传统编码框架中画面提质模块、滤波模块、运动预测模块</strong>等，未来的人工智能技术与编码深度结合之下，如何检测篡改攻击痕迹是更加复杂和困难的挑战；</li>\n<li>该领域的专用算法尽管已经取得了丰硕的成果，但还存在着诸多边界条件的限制，离实际应用存在较大差距；<strong>新型篡改攻击方法不断涌现；新的深度学习模型削弱了篡改痕迹等问题；新的编码算法使得篡改痕迹被隐藏；概率性取证检测转化为确定性检测</strong>的方法等一系列问题。</li>\n<li>目前尽管已经出现了若干的公开视频篡改数据库，但是覆盖篡改类型还比较有限，数据库建设的标准也不统一，数据库的原始样本也存在容器、编码标准混乱的情况，对支撑整个领域研究还是远远不够的；</li>\n<li>在该领域的客观评价指标大多数<strong>仅限于传统的检测准确率、算法效率、定位准确率等指标，但这些指标无法满足对篡改检测算法性能进行全方位的评价</strong>，对未来算法应用落地是一个不容回避的问题，亟待更多的学者参与其中。</li>\n</ol>\n<h3 id=\"参考文献-2\"><a href=\"#参考文献-2\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>[1] Mi Z, Jiang X, Sun T, GAN-Generated Image Detection with Self-Attention Mechanism against GAN Generator Defect[J]. IEEE Journal of Selected Topics in Signal Processing, 2020, 14(5): 969-981.</p>\n<p>[2] Peisong He;Haoliang Li;Hongxia Wang;Shiqi Wang;Xinghao Jiang;Ruimei Zhang, Frame-wise Detection of Double HEVC Compression by Learning Deep Spatio-temporal Representations in Compression Domain[J]. IEEE Transactions on Multimedia, 2020, DOI: 10.1109/ TMM.2020.3021234.</p>\n<p>[3] Xu Q, Jiang X, Sun T, Detection of HEVC double compression with non-aligned GOP structures via inter-frame quality degradation analysis, Neurocomputing,2021, 452: 99-113.</p>\n<p>[4] Zhong hao Li, Meng, Laijin; Xu, Shutong; Li, Zhaohong; Shi, Yunqing; Liang, Yuanchang, A HEVC Video Steganalysis Algorithm Based on PU Partition Modes[J]. Computers, Materials &amp; Continua, 2019, 59(2):563-574.</p>\n<p>[5] Khoubani Sahar and Moradi Mohammad Hassan. A fast quaternion wavelet-based motion compensated frame rate up-conversion with fuzzy smoothing: application to echocardiography temporal enhancement[J]. Multimedia Tools and Applications, 2020, 80(6):8999-9025.</p>\n<p>[6] Kevin Spiteri and Rahul Urgaonkar and Ramesh K. Sitaraman. BOLA: Near-Optimal Bitrate Adaptation for Online Videos[J]. IEEE/ACM Transactions on Networking, 2020, PP(99):1-14.</p>\n<p>[7] Yin, Xiaoqi, Jindal, Abhishek, Sekar, Vyas,Sinopoli, Bruno, A Control-Theoretic Approach for Dynamic Adaptive Video Streaming over HTTP[J]. Computer communication review, 2015, 45(4):325-338.</p>\n<p>[8] Park W S, Kim M., CNN-based in-loop filtering for coding efficiency improvement[C]// 2016 IEEE 12th Image, Video, and Multidimensional Signal Processing Workshop (IVMSP). IEEE, 2016, DOI: 10.1109 /IVMSPW.2016.7528223.</p>\n<p>[9] Sun T, Jiang X, Chao J, A Novel Video Inter-frame Forgery Model Detection Scheme Based on Optical Flow Consistency[J]. International Workshop on Digital Watermarking, 2012. [10] Wang W, Jiang X, Wang S, et al. Identifying Video Forgery Process Using Optical Flow[M]//Digital-Forensics and Watermarking. Springer Berlin Heidelberg, 2014: 244-257.</p>\n<p>[11] Yin L, Bai Z, Yang R. Video forgery detection based on nonnegative tensor factorization[C]//Information Science and Technology (ICIST), 2014 4th IEEE International Conference on. IEEE, 2014: 148-151.</p>\n<p>[12] Quanxin Yang, Dongjin Yu, Zhuxi Zhang, Ye Yao, Linqiang Chen, Spatiotemporal Trident Networks: Detection and Localization of Object Removal Tampering in Video Passive Forensics[J]. IEEE Transactions on Circuits and Systems for Video Technology. 2020/12, DOI: 10.1109/TCSVT.2020.3046240.</p>\n<p>[13] Feng C, Xu Z, Zhang W, et al. Automatic location of frame deletion point for digital video forensics[C]//Proceedings of the 2nd ACM workshop on Information hiding and multimedia security. ACM, 2014: 171-179.</p>\n<p>[14] Feng C, Xu Z, Jia S, Zhang W, Xu Y, Motion-adaptive frame deletion detection for digital video forensics[J], IEEE Transactions on Circuits and Systems for Video Technology, 2016, 27(12):2543–2554.</p>\n<p>[15] Averbuch-Elor, Hadar, Cohen-Or, Daniel, Kopf, Johannes. Bringing portraits to life[J]. ACM Transactions on Graphics, 2017, 36(6) :1-13.</p>\n<p>[16] Kim Hyeongwoo, Theobalt Christian, Carrido Pablo. Deep video portraits[J]. ACM Transactions on Graphics, 2018, 37(4):1-14.</p>\n<p>[17] Zhou H, Liu Y, Liu Z, et al. Talking Face Generation by Adversarially Disentangled Audio-Visual Representation[J]. Proceedings of the AAAI Conference on Artificial Intelligence, 2019, 33:9299-9306.</p>\n<p>[18] Fried, O., Tewari, A., Zollh, Zollhöfer M et al. Text-Based Editing of Talking-Head Video[J]. ACM Trans. Graph. 38(4), 2019: 1-14.</p>\n<p>[19] Supasorn Suwajanakorn, Steven M. Seitz. Synthesizing Obama: learning lip sync from audio[M]. ACM, 2017.</p>\n<p>[20]Lee J W, Lee M J, Lee H Y, et al. Screenshot identification by analysis of directional inequality of interlaced video[J]. Eurasip Journal on Image &amp; Video Processing, 2012, (1):1-15.</p>\n<p>[21] Bestagini P, Visentini-Scarzanella M, Tagliasacchi M, et al. Video recapture detection based on ghosting artifact analysis[C]//Image Processing (ICIP), 2013 20th IEEE International Conference on. IEEE, 2013: 4457-4461.</p>\n<p>[22] Rolland-Neviere, X., Chupeau, B., Doerr, G., et al. (2012) Forensic Characterization of Camcorded Movies: Digital Cinema vs. Celluloid Film Prints[C]//Proceedings of SPIE—The International Society for Optical Engineering, Burlin-game, 9 February 2012, 83030R-83030R-11.</p>\n<p>[23] Mahdian B, Novozamsky A, Saic S. Identification of aliasing-based patterns in re-captured LCD screens[C]//Image Processing (ICIP), 2015 IEEE International Conference on. IEEE, 2015: 616-620.</p>\n<p>[24] Visentini-Scarzanella M, Dragotti P L. Video jitter analysis for automatic bootleg detection[C]//Multimedia Signal Processing (MMSP), 2012 IEEE 14th International Workshop on. IEEE, 2012: 101-106.</p>\n<p>[25] Thongkamwitoon T, Muammar H, Dragotti P L. An image recapture detection algorithm based on learning dictionaries of edge profiles[J]. Information Forensics and Security, IEEE Transactions on, 2015, 10(5): 953-968.</p>\n<p>[26] Anjum, A., Islam, S. Recapture detection technique based on edge-types by analysing high-frequency components in digital images acquired through LCD screens[J]. Multimed Tools Appl, 2020,79: 6965–6985.</p>\n<p>[27] Chao J, Jiang X, Sun T. A novel video inter-frame forgery model detection scheme based on optical flow consistency[C]//International Workshop on Digital Watermarking. Springer, Berlin, Heidelberg, 2012: 267-281.</p>\n<p>[28] Wu Y, Jiang X, Sun T, et al. Exposing video inter-frame forgery based on velocity field consistency[C]//2014 IEEE international conference on acoustics, speech and signal processing (ICASSP). IEEE, 2014: 2674-2678.</p>\n<p>[29] Qiang XU, Xinghao Jiang, Tanfeng Sun*, Alex C. Kot, Detection of transcoded HEVC videos based on in-loop filtering and PU partitioning analyses[J], Signal Processing: Image Communication, 2021, 92:116109.</p>\n<p>[30] He P, Sun T, Jiang X, et al. Double compression detection in MPEG-4 videos based on block artifact measurement with variation of prediction footprint[C]// International Conference on Intelligent Computing. Springer. 2015: 787–793.</p>\n<p>[31] He P, Jiang X, Sun T, et al. Detection of double compression in MPEG-4 videos based on block artifact measurement[J]. Neurocomputing, 2017, 228: 84–96.</p>\n<p>[32] Yao Y, Yang G, Sun X, et al. Detecting video frame-rate up-conversion based on periodic properties of edge-intensity[J]. Journal of Information Security and Applications, 2016, 26: 39–50.</p>\n<p>[33] Bian S, Luo W, Huang J. Detecting video frame-rate up-conversion based on periodic properties of inter-frame similarity[J]. Multimedia tools and applications, 2014, 72(1): 437–451.</p>\n<p>[34] Vazquezpadin D, Fontani M, Bianchi T, et al. Detection of video double encoding with GOP size estimation[C]// IEEE International Workshop on Information Forensics and Security (WIFS), 2012:151-156.</p>\n<p>[35] Vazquez-Padin D, Fontani M, Shullani D, et al. Video Integrity Verification and GOP Size Estimation Via Generalized Variation of Prediction Footprint[J]. IEEE transactions on information forensics and security, 2020, (15):1815-1830.</p>\n<p>[36] Li, Q., Wang, R. and Xu, D., Detection of double compression in HEVC videos based on TU size and quantized DCT coefficients[J]. IET Inf. Secur., 2019, (13): 1-6.</p>\n<p>[37] Yao H., Ni R., Zhao Y., Double compression detection for H.264 videos with adaptive GOP structure. Multimedia Tools and Applications, 2020, (79):5789-5806.</p>\n<p>[38] Yu Y , Yao H , Ni R , et al. Detection of fake high definition for HEVC videos based on prediction mode feature[J]. Signal processing, 2020, 166(Jan.):107269.1-107269.11.</p>\n<p>[39] X.H, Jiang, Q. Xu, T.F. Sun, Bin Li, Peisong He, Detection of HEVC double compression with the same coding parameters based on analysis of intra coding quality degradation process[J]. IEEE Transactions on Information Forensics and Security, 2019, (15): 250-263.</p>\n<p>[40] He P, Jiang X, Sun T, et al. Frame-wise detection of relocated I-frames in double compressed H.264 videos based on convolutional neural network[J]. Journal of Visual Communication and Image Representation, 2017, (48): 149-158.</p>\n<p>[41 Xu Q, Jiang X, Sun T, et al. Relocated I-Frames Detection in H. 264 Double Compressed Videos Based on Genetic-CNN[C]. in: 2018 Asia-Pacifc Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC). 2018: 710-716.</p>\n<p>[42] He P, Li H, Li B, et al. Exposing Fake Bitrate Videos Using Hybrid Deep-learning Network from Recompression Error[J]. IEEE Transactions on Circuits and Systems for Video Technology, 2019, (99):1-13.</p>\n<p>[43] Gan Y, Yang J, Lai W. Video object forgery detection algorithm based on VGG-11 convolutional neural network[C]//2019 International Conference on Intelligent Computing, Automation and Systems (ICICAS). IEEE, 2019: 575-580.</p>\n<blockquote>\n<p>本文转自公众号【隐者联盟】<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485053&idx=1&sn=b658496c5826472b5cea4183ede69759\">【极简综述17】数字图像处理操作取证</a>、<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485053&idx=2&sn=afbec76ac6f61518c50b6a040eb33fac\">【极简综述18】数字图像篡改操作取证</a>、<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485207&idx=1&sn=c2be18dc1badc7c8731a91c0f926d55b\">【极简综述19】数字视频再编辑篡改及被动取证检测技术综述</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<ul>\n<li>数字图像篡改操作取证(Tamper )<ul>\n<li>Copy-move操作取证技术</li>\n<li>Inpainting操作取证技术</li>\n<li>Splicing操作取证技术</li>\n</ul>\n</li>\n<li>数字图像处理操作取证(Manipulation)<ul>\n<li>JPEG重压缩取证技术</li>\n<li>增强操作取证技术</li>\n<li>几何操作取证技术</li>\n<li>操作链取证技术</li>\n</ul>\n</li>\n<li>视频编辑篡改检测<ul>\n<li>数字视频再编辑篡改技术</li>\n<li>数字视频被动取证检测技术</li>\n</ul>\n</li>\n</ul>","more":"<h2 id=\"数字图像篡改操作取证-Tamper\"><a href=\"#数字图像篡改操作取证-Tamper\" class=\"headerlink\" title=\"数字图像篡改操作取证(Tamper )\"></a>数字图像篡改操作取证(<strong>Tamper</strong> )</h2><h3 id=\"Copy-move操作取证技术\"><a href=\"#Copy-move操作取证技术\" class=\"headerlink\" title=\"Copy-move操作取证技术\"></a>Copy-move操作取证技术</h3><p>图像复制粘贴篡改（copy-move）是数字图像篡改中比较常用的一种手段。它把单个图像中的部分区域复制并粘贴到同一图像中不交叠的其它区域，从而增加或覆盖掉某些物体。为了使篡改后的图像能够以假乱真，在复制过程中，复制区域可能会经历旋转、缩放等几何变换，并且合成图像可能经历加噪、模糊、压缩等后期处理，这进一步加大了篡改检测的难度。现有的图像复制篡改检测方法可以粗略的分为<strong>基于图像块的方法</strong>、<strong>基于关键点的方法</strong>和<strong>基于深度学习的方法</strong>。</p>\n<h4 id=\"基于图像块的方法\"><a href=\"#基于图像块的方法\" class=\"headerlink\" title=\"基于图像块的方法\"></a>基于图像块的方法</h4><p>Fridrich等人[1]首次定义了复制粘贴篡改，并提出了<strong>基于块匹配</strong>的检测方法，将图像分割成固定大小且相互重叠的子块，并使用DCT量化系数作为图像块的特征描述。该算法对图像块的所有DCT系数都进行统计计算，所以算法的复杂度很高。</p>\n<p>后来，多位学者分别<strong>提出了DWT变换、FWT变换等用于描述图像块的特征</strong>。Bashar等人[2]提出了两个鲁棒的特征，分别基于DWT变换和KPCA，并将这些特征向量构成一个矩阵。Cozzolino等人[3]提出了CHT作为图像的特征。该方法将图像中的每一个像素点都进行处理，提取到每一个像素点的特征。为了减少计算量，使用了快速的近似最近邻搜索算法对密集区域处进行高效的计算。</p>\n<p>除了频率域的特征提取，<strong>基于空间域</strong>的特征提取也有很多经典的算法，其中将矩阵特征作为图像的特征进行处理就是经常使用的方法。Mahdian和Saic[4]较早提出了一种<strong>基于模糊矩阵</strong>的方法，并使用了主成分分析减少特征的维数，最后利用k-d树对多维的数据块进行相似性分析，从而对篡改区域进行定位。Ryu等人[5]则将<strong>Zernike矩阵</strong>作为图像块的特征，并在<strong>图像块匹配时使用了局部敏感哈希算法</strong>加速匹配过程，最终根据匹配块寻找篡改区域。</p>\n<p>除了使用矩阵特征以外，也有研究者利用图像本身的一些<strong>纹理亮度信息作为图像的特征</strong>。Davarzani等人[6]采用多分辨率局部二值模式（MLBP）作为图像块的特征信息。为了获得精确的匹配信息，还使用了<strong>RANSAC算法</strong>去除掉错误的匹配。</p>\n<p>基于图像块的检测算法虽然能达到一定的效果，但是随着图像复制粘贴篡改的多样化，以及实际图像复制篡改过程中经历更多几何变换如旋转、缩放等，基于图像块的检测方法的鲁棒性会降低。此外，基于图像块的方法需要大量的计算，难以在实际中进行应用。为了提高检测效率，增强对抗几何变换的鲁棒性，基于关键点匹配的检测方法成了新的研究热点。</p>\n<h4 id=\"基于关键点的方法\"><a href=\"#基于关键点的方法\" class=\"headerlink\" title=\"基于关键点的方法\"></a>基于关键点的方法</h4><p>基于关键点的检测方法计算效率高且有较强的鲁棒性，适用于实际情况下的多类型图像复制粘贴篡改检测，因此研究者也致力于用基于关键点的检测方法来解决各种图像复制粘贴篡改检测的问题。</p>\n<p><strong>该类方法首先从整幅图像中提取关键点，然后对其进行特征描述提取和匹配过程，最后通过得到关键点匹配进行后续处理从而定位复制粘贴篡改区域。</strong></p>\n<p>Huang等人[7]<strong>采用SIFT作为图像关键点检测与特征描述</strong>的方法，并使用<strong>Best Bin First算法</strong>来寻找相似的特征向量，进而确定匹配关键点的位置。此后很多学者也提出了基于SIFT特征的检测方法，Pan和Lyu[8]使用了<strong>RANSAC算法</strong>来计算复制粘贴区域之间的仿射变换关系。Amerini等人[9]基于2NN准则提出了<strong>新的匹配方法G2NN</strong>以应对多重复制粘贴的情形。除了SIFT以外，研究者还提出了其它一系列的优秀算法。Xu等人[10]<strong>使用SURF作为提取图像关键点特征的方法</strong>。相比SIFT，SURF运算比较简单，计算效率更高。此外，Yang等人[11]<strong>采用了SIFT和KAZE的融合</strong>作为提取关键点特征的方法。</p>\n<p>针对复杂的复制粘贴篡改检测以及定位的精确度的问题，有研究者提出了更为系统的检测框架。Ardizzone等人[12]利用<strong>提取的SIFT特征点来构建Delaunay 划分，然后利用每个三角形块的颜色信息和角度信息作为三角形区域的特征向量进行匹配</strong>。Li等人[13]首先使用 <strong>SLIC算法对图像进行分割成一系列的超像素块</strong>，根据分割块内关键点匹配对的数量处理匹配块，提升了处理的效率。Zandi等人[14]通过自适应迭代的方法，根据每个迭代周期的结果迭代地调整关键点的分布还有匹配过程以及仿射变换矩阵计算。Li等人[15]通过降低关键点提取时的阈值，使得小区域、平滑区域可以提取足量的关键点，并且提出了一种<strong>新的层次匹配策略来解决大量关键点匹配问题</strong>。和基于块匹配的检测方法相比，基于关键点匹配的方法避免了全局搜索，大大提高了检测效率，且对几何变换具有更好的鲁棒性。</p>\n<h4 id=\"基于深度学习的方法\"><a href=\"#基于深度学习的方法\" class=\"headerlink\" title=\"基于深度学习的方法\"></a>基于深度学习的方法</h4><p>随着深度学习尤其是卷积神经网络的发展，研究者开始尝试使用深度学习的方法进行图像复制粘贴篡改的检测。Wu等人[16]设计了<strong>端到端的BusterNet</strong>，采取双分支结构，对图像操作和图像相似性进行检测，具有一定的效果，可以同时识别源区域和目标区域。Chen等人[17]提出一种<strong>串行分支网络模型</strong>，包含<strong>相似性检测网络CMSDNet和源与目标鉴别网络STRDNet</strong>。STRDNet研究CMSDNet获得的相似块的分类问题，相对于BusterNet的分支更加简单且准确率更高。</p>\n<p>Barni等人[18]提出了多分支网络DisTool对图像复制篡改进行检测并识别源区域和目标区域，分别为两个Siamese组成的4-Twins Net分支和一个Siamese分支。该网络在真实的测试场景中也表现良好。Zhong等人[19]提出了<strong>基于Dense-InceptionNet</strong>的检测方案，充分使用了多尺度的信息和稠密特征链接，设计了<strong>金字塔特征提取器，特征相关匹配和层次后处理模块</strong>。<strong>该算法对几何变换操作和JPEG压缩都有一定的鲁棒性</strong>。</p>\n<h3 id=\"Inpainting操作取证技术\"><a href=\"#Inpainting操作取证技术\" class=\"headerlink\" title=\"Inpainting操作取证技术\"></a>Inpainting操作取证技术</h3><p>图像修复(inpainting)技术是数字图像篡改中比较常用的一种手段，它的核心思想是根据图像受损区域周围的已知像素信息通过插值相邻像素对未知区域进行修复[20]。目前，传统的图像inpainting算法可以分成两类：<strong>基于块的方法和基于扩散的方法。</strong></p>\n<ul>\n<li><p>基于块的方法主要是通过搜索图像已知区域的图像块，寻找合适的候选块对受损区域进行填补以达到修复的目的；</p>\n</li>\n<li><p>基于扩散的方法通常是通过求解偏微分方程或者依据扩散系统将图像信息从边界传播扩散到未知区域进行修复。</p>\n</li>\n</ul>\n<p>当恶意篡改者使用图像inpainting技术进行篡改并将这类图像应用于司法、科学等领域时，将会造成不可预料的严重影响。现有的针对图像inpainting的<strong>检测方法</strong>大致可以分为两类：<strong>基于传统手工特征的方法和基于深度学习的方法。</strong></p>\n<h4 id=\"基于传统手工特征的方法\"><a href=\"#基于传统手工特征的方法\" class=\"headerlink\" title=\"基于传统手工特征的方法\"></a>基于传统手工特征的方法</h4><p>最初，Wu等人[21]在2008年提出了一种<strong>基于零连通特征和模糊隶属度</strong>的检测方法。首先对图像中的块进行零连通标记，筛选可疑区域，然后通过计算模糊隶属度识别可疑区域内的修复块，并通过割集实现最终的修复篡改区域的定位。</p>\n<p>2013年，Bacchuwar等人[22]提出了一种可以同时检测图像修复和图像复制-粘贴两种篡改的方法。该方法<strong>利用图像的亮度分量，对可疑区域中的块进行中值匹配</strong>，引入“跳跃块”，从而有序检测篡改区域。它相较于文献[21]加速了修复区域的定位，但仍需要人工选择区域。</p>\n<p>为减少最佳匹配块的搜索时间，Chang等人[23]通过检测关键值进行相似度检测，提出了一种<strong>基于权值变换的搜索算法</strong>，包括可疑区域检测和篡改区域识别两个阶段。Liang等人[24]首先<strong>采用中心像素映射搜索</strong>可疑块对，在装载因子和搜索范围方面加速了对可疑块的搜索，使用最大零连通性区域标记和片段拼接检测技术实现篡改区域的定位。</p>\n<p>申林川等人[25]对已有的图像修复检测方法进行改进，<strong>利用一种hash映射函数将图片三维的颜色信息转换成一维的hash值映射至哈希表</strong>，再结合相似向量滤波和基于质心的篡改区域定位技术，实现篡改区域最终的准确定位。</p>\n<p>另外，JPEG是目前网络中使用最广泛的图像格式。Zhao等人[26]针对JPEG图像展开研究，<strong>通过计算和分割不同质量因子下的修复图像和再保存JPEG图像的绝对差值之和检测出被篡改的区域</strong>，不需要任何手动操作。</p>\n<p>Liu等人[27]也聚焦于JPEG图像，<strong>提出了一种大规模特征挖掘的经验方法，包含边缘密度和联合密度特征</strong>，采用集成学习，有效地检测了包括图像修复在内的复合攻击下的图像篡改，特别是在重压缩质量低于原始JPEG图像质量的情况下，显著提高了检测精度。</p>\n<p>Li等人[28]针对<strong>基于扩散的修复方法进行区域检测，发现修复区域和未修复区域图像沿垂直于梯度方向的拉普拉斯变换是不同的</strong>。基于此，根据通道内和通道间的局部变化方差构造了一个特征集。最后，设计了两个有效的后处理操作来进一步细化定位结果。但该方法鲁棒性较差，特别是对经过JPEG压缩后处理的图像取证性能显著下降。</p>\n<p>刘婷婷等人[29]<strong>提出了一种梯度域导向滤波增强的图像扩散修复检测算法</strong>。该算法对输入图像的各个颜色通道分别进行梯度域导向滤波增强，从多角度捕捉图像修复带来的影响，以实现图像扩散修复区域的定位。</p>\n<p>基于传统手工特征的图像inpainting检测算法在一些方面存在一定的局限性，比如<strong>需要手动选择区域、只针对特定的图像inpainting技术、鲁棒性较差</strong>等。近年来为提高检测效率，增强算法对抗几何变换的鲁棒性，基于深度学习的图像inpainting检测算法也在不断发展。</p>\n<h4 id=\"基于深度学习的方法-1\"><a href=\"#基于深度学习的方法-1\" class=\"headerlink\" title=\"基于深度学习的方法\"></a>基于深度学习的方法</h4><p>随着深度学习的发展，研究人员开始尝试使用深度学习方法实现图像修复检测。</p>\n<p>2018年，Zhu等人[30]提出了一种基于深度神经网络的图像inpainting篡改检测技术，通过神经网络自动提取篡改痕迹，实现图像像素级的预测并对修复区域进行定位。<strong>该框架在编码器-解码器的全卷积网络结构基础上还引入了特征金字塔网络对特征图进行信息补充</strong>，填充图像的语义信息，且具有一定的泛化性。进一步地，Zhu等人[31]提出了新的网络框架，并构建了类标签矩阵，设计了加权交叉熵解决图像像素不平衡的问题。该方法考虑了JPEG压缩和缩放等后处理操作，具有一定的鲁棒性。</p>\n<p>Wang等人[32]在2019年提出了一种<strong>基于Faster R-CNN网络的图像inpainting篡改检测方法</strong>，并<strong>自制</strong>了在两种深度学习图像修复算法下的<strong>数据集</strong>，实现了修复区域的边界框定位。但该方法只能得到标记有置信度分数的边界框，无法得到修复篡改区域的真实区域，定位精度有待进一步提高。</p>\n<p>Lu等人[33]提出了一种<strong>基于LSTM-CNN的图像目标去除方法</strong>，利用CNN搜索异常相似块，提高了搜索的速度和准确性，利用LSTM网络消除虚警补丁对检测结果的影响，降低虚警率。</p>\n<p>Li等人[34]探究发现在像素域中修复图像块和未修复图像块的转移概率值相似，而在残差域中表现出明显的差异，修复图像块包含较少的高频分量。因此，作者<strong>设计了HP-FCN网络，利用高通滤波模块对输入图像进行预处理，将其残差图输送到基于CNN的特征提取模块中，再通过上采样模块采样到输入图像大小，最终得到像素预测的定位图。</strong>该算法对深度学习下的修复数据集进行定位检测，且进一步考虑了随机修复和现实情况下的真实数据集，在准确率上都取得了较好的效果，具有一定的鲁棒性。</p>\n<p>为了提高已有算法对不可见图像修复方法的检测性能，Wu等人[35]提出了一种新型的<strong>端到端图像修复检测网络IID-Net，其中NAS算法用于设计适当的网络架构，并结合新提出的注意模块来进一步优化潜在特征。</strong>该算法在特定深度修复方法上训练的取证模型对其他修复方法具有良好的通用性检测能力。作者还基于10种不同的修复方法构建了一个<strong>包含10K张图片的不同修复测试数据集</strong>，每种修复方法提供1000张图片，作为一个公共可访问的数据集，用于修复检测方法的标准化比较。</p>\n<h3 id=\"Splicing操作取证技术\"><a href=\"#Splicing操作取证技术\" class=\"headerlink\" title=\"Splicing操作取证技术\"></a>Splicing操作取证技术</h3><p><strong>图像拼接(splicing)<strong>伪造不同于复制-粘贴伪造，它是将一个或多个源图像的区域复制粘贴到目标图像上得到篡改图像。图像拼接伪造检测与定位可以看作是一个全局二值分类问题，通过比较不同图像区域之间的特征来检测定位篡改区域。现有的图像拼接伪造检测方法大致可以归纳为四类：</strong>基于模糊类型不一致性的方法</strong>，<strong>基于噪声水平不一致性的方法</strong>，<strong>基于光照不一致性的方法</strong>和<strong>基于深度学习的方法</strong>。</p>\n<h4 id=\"基于模糊类型不一致性的方法\"><a href=\"#基于模糊类型不一致性的方法\" class=\"headerlink\" title=\"基于模糊类型不一致性的方法\"></a>基于模糊类型不一致性的方法</h4><p>2011年，Kakar等人[36]提出了一种<strong>利用运动模糊差异性检测图像拼接</strong>的新方法。通过对图像梯度的运动模糊水平的估计，检测拼接区域和原始区域之间的不一致性。作者还开发了一种新的方法，可以较好地对包含运动模糊的图像进行不一致性区域分割。</p>\n<p>为了适应不同范围的模糊程度，Bahrami等人[37] 提出了一种基于<strong>图像模糊度和深度信息不一致性的图像拼接检测框架</strong>。首先估计图像块的模糊核，再利用分步模糊技术测量局部模糊核的相对模糊度。基于此，对不同模糊程度的图像块进行分类。</p>\n<p>Rao等人[38]考虑手持摄像机中运动模糊现象这一特定场景，提出了一种<strong>以模糊为线索的被动图像拼接检测方法</strong>。离焦模糊也是图像拼接检测中的一种常用特征，然而纹理、光场、噪声等都会在一定范围内影响自然边缘的离焦模糊信息，导致边缘离焦模糊估计不一致。</p>\n<p>Song等人[39]分析了图像拼接边缘和自然边缘的离焦模糊特征的差异性，提出了<strong>一种新的基于离焦模糊差的自然图像拼接检测方法</strong>。当伪造者使用一些后处理操作来掩盖拼接痕迹时，图像拼接问题是一个具有挑战性的问题。</p>\n<p>为进一步解决这个问题，Bahrami等人[40]在2015年提出了一种<strong>基于局部模糊类型不一致性的模糊图像拼接定位框架</strong>。作者首先对图像进行分块，根据局部模糊核提取局部模糊类型检测特征用于离焦模糊和运动模糊的划分，从而生成模糊类型不变区域。最后，采用精细拼接定位方法提高区域边界的精度。</p>\n<h4 id=\"基于噪声水平不一致性的方法\"><a href=\"#基于噪声水平不一致性的方法\" class=\"headerlink\" title=\"基于噪声水平不一致性的方法\"></a>基于噪声水平不一致性的方法</h4><p>大多数图像在采集或后续处理过程中都会引入一定的噪声，而自然图像和具有不同来源的拼接图像中的噪声会存在不同程度的差异性。研究人员根据噪声的不一致性提出了相应的图像拼接检测算法。</p>\n<p>Mahdian等人[41]将待测图像分割成不同噪声水平的分区，<strong>利用基于中值的方法计算每个图像块的噪声标准差</strong>，通过一个阈值确定图像拼接篡改区域。</p>\n<p>Lyu等人[42]利用了自然图像在带通域内峰度的特殊规律以及噪声特征与峰度之间的关系。<strong>将噪声统计量的估计表述为一个具有封闭解的优化问题</strong>，并进一步推广到一种有效的局部噪声统计量估计方法。通过揭示局部噪声水平的不一致性来检测拼接区域。</p>\n<p>研究人员发现可以通过主成分分析(PCA)来估计图像的噪声水平。其中，2015年，Zhan等人[43]在主成分分析的基础上，根据不同的局部噪声方差，<strong>对待测图进行均匀噪声的区域分割</strong>，实现篡改区域的定位。Zeng等人[44]发现当拼接区域与原始区域噪声差较小时，一些基于噪声的图像拼接定位算法性能不佳。作者采用基于主成分分析的算法对图像进行分块噪声水平估计，<strong>通过k-means聚类从原始区域分割出篡改区域</strong>。Yao等人[45]通过探讨噪声水平函数(NLF)与相机相应函数(CRF)之间的关系，拟合了CRF约束下的NLF曲线，<strong>建立了一个贝叶斯最大后验(MAP)框架来优化NLF估计</strong>，并开发了一种基于不同来源图像块噪声水平不一致性的图像拼接检测方法。Liu等人[46]针对多目标拼接伪造场景，<strong>利用噪声水平函数(NLF)估计图像噪声与像素强度之间的关系，从而检测可疑篡改区域</strong>。2018年，Nan等人[47]提出一种新的噪声水平函数的图像拼接检测方法。作者首先将图像分成不重叠的块，将每个块的噪声方差拟合到锐利度下，<strong>通过计算图像块到拟合曲线的最小距离区分篡改区域</strong>。</p>\n<h4 id=\"基于光照不一致性的方法\"><a href=\"#基于光照不一致性的方法\" class=\"headerlink\" title=\"基于光照不一致性的方法\"></a>基于光照不一致性的方法</h4><p>一般来说，使用不同设备拍摄的图像会存在光照不一致性。基于此特性，Liu等人[48]在2011年提出了一种基于阴影亮度不一致性的图像拼接篡改检测框架。<strong>该框架首先提取图像中的阴影边界和半阴影区域</strong>，估计阴影的遮罩值来衡量其颜色特征。但当合成阴影和实际目标阴影一致时，该算法失效。Ke等人[49]对此提出改进，提出了基于阴影一致性的篡改图像检测方法。通过提取阴影区域和非阴影区域的纹理特征，<strong>利用相关函数来度量两种纹理特征的相似性。通过比较相似度，实现图像拼接篡改的检测。</strong></p>\n<h4 id=\"基于深度学习的方法-2\"><a href=\"#基于深度学习的方法-2\" class=\"headerlink\" title=\"基于深度学习的方法\"></a>基于深度学习的方法</h4><ul>\n<li>Xiao等人[50]提出了一种由粗到精的两阶段检测网络(<strong>C2RNet</strong>)和稀释自适应聚类两部分组成的拼接伪造检测方法，从不同尺度的图像块中学习图像属性的差异。</li>\n<li>Bappy等人[51]提出了一种<strong>利用空间域的编码器-解码器结构网络和频域的长短期记忆(LSTM)网络的双域检测方法</strong>。该网络利用更大的接受域和频域相关性，通过结合编码器和LSTM网络来分析篡改区域和非篡改区域之间的区别特征。最后使用解码器实现像素级预测图像篡改定位。</li>\n<li>进一步地，Wu等人[52]将伪造定位问题定义为局部异常检测问题，<strong>设计了Z-score特征来捕获局部异常，并提出了一种新的检测网络结构(Mantra-net)来评估局部异常</strong>。</li>\n<li>Bi等人[53]采用图像分割的思想，设计了一种用于图像拼接伪造检测的环形残差U-Net (RRU-Net)，<strong>利用残差传播和残差反馈使得未篡改区域和篡改区域</strong>之间的图像属性差异更加明显。</li>\n<li>Zhou等人[54]针对目前常见的几类局部篡改操作，<strong>结合传统特征提出了一个双流Faster R-CNN网络</strong>。不仅实现了篡改操作类型识别，更进一步地能够定位到篡改区域，在图像拼接伪造检测方面也具有比较好的性能。</li>\n</ul>\n<p>目前，图像拼接伪造检测和定位问题出现了一种新的定义：给定一幅探针图像Q和一幅潜在的供体图像P。检测供体图像的区域是否已拼接到探针图像中，如果已拼接到探针图像，则提供两个掩码，指示拼接到探针中的供体图像区域和从供体图像中拼接的图像区域。这一新问题将图像拼接检测约束为一对图像，相关研究人员将其称为约束图像拼接检测问题。针对这一问题，Wu等人[55]提出了一种开拓性的CISDL方法，设计了一种新的深度卷积神经网络结构—<strong>深度匹配与验证网络(DMVN)<strong>。Ye等人[56]在继承DMVN深度密集匹配层的基础上，提出了</strong>特征金字塔深度匹配与定位方法网络(FPLN)<strong>。Liu等人[57]提出了</strong>一种面向CISDL新的对抗性学习框架的深度匹配网络(DMAC)<strong>，用于生成两个高质量候选掩模，基于检测网络纠正候选掩模之间的不一致，并</strong>基于判别网络生成与真实篡改区域接近的掩模，检测网络与判别网络以对抗学习方式协同监督DMAC</strong>训练。</p>\n<h3 id=\"小结与思考\"><a href=\"#小结与思考\" class=\"headerlink\" title=\"小结与思考\"></a><strong>小结与思考</strong></h3><p>目前，除了上述图像篡改操作的取证，removal、seam carving等篡改操作的取证研究也吸引了国内外学者的广泛关注，并取得了一些阶段性成果。尤其是近年来，以卷积神经网络为代表的深度学习技术在图像篡改操作取证领域取得了突出的性能，但仍存在一些问题有待进一步研究。</p>\n<p>（1）篡改者在使用copy-move，inpainting或者splicing操作对图像语义进行恶意篡改后，通常会使用一些后处理操作或者反取证技术掩盖操作的篡改痕迹，如何设计对不同后处理操作和反取证技术鲁棒的篡改操作取证模型是值得进一步探索的方向。</p>\n<p>（2）针对inpainting操作检测问题，大多数取证方法都基于修复区域与未修复区域的块匹配原理，检测效率较低。如何在保证定位准确率的前提下，加快区域匹配速率是一个待解决的问题。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>[1]J. Fridrich, D. Soukal, and J. Lukas. Detection of copy-move forgery in digital images. Proceedings of Digital Forensic Research Workshop (DFRWS), Cleveland, OH, USA, 2003.</p>\n<p>[2]M. Bashar, K. Noda, N. Ohnishi, and K. Mori. Exploring duplicated regions in natural images. IEEE Transactions on Image Processing, DOI: 10.1109/TIP.2010.2046599, 2010.</p>\n<p>[3]D. Cozzolino, G. Poggi, and L. Verdoliva. Efficient dense¬field copy–move forgery detection. IEEE Transactions on Information Forensics and Security, vol. 10, no. 11, pp. 2284-2297, 2015.</p>\n<p>[4]B. Mahdian, and S. Saic. Detection of copy–move forgery using a method based on blur moment in-variants,.Forensic Science International, vol. 171, no. 2, pp. 180-189, 2017.</p>\n<p>[5]S. -J. Ryu, M. Kirchner, M. -J. Lee, and H. K. Lee. Rotation invariant localization of duplicated image regions based on zernike moments. IEEE Transactions on Information Forensics and Security, vol. 8, no. 8, pp. 1355-1370, 2013.</p>\n<p>[6]R. Davarzani, K. Yaghmaie, S. Mozaffari, and M.Tapak. Copy¬-move forgery detection using multiresolution local binary patterns. Forensic Science International, vol. 231, no. 1, pp. 61-72, 2013.</p>\n<p>[7]H. Huang, W. Guo, and Y. Zhang. Detection of copy-move forgery in digital images using sift algorithm. IEEE Pacific-Asia Workshop on Computational Intelligence and Industrial Application (PACIIA), Wuhan, China, pp. 272–276, 2008.</p>\n<p>[8]X. Pan, and S. Lyu. Region duplication detection using image feature matching. IEEE Transactions on Information Forensics and Security, vol. 5, no. 4, pp. 857-867, 2010.</p>\n<p>[9]I. Amerini, L. Ballan, R. Caldelli, A.D. Bimbo, and G. Serra. A sift-based forensic method for copy-move attack detection and transformation recovery. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1099-1110, 2011.</p>\n<p>[10]B. Xu, J. Wang, G. Liu, H. Li, and Y. Dai. Image copy-move forgery detection based on surf. International Conference on Multimedia Information Networking and Security (MINES), Nanjing, China, pp. 889-892, 2010.</p>\n<p>[11]F. Yang, J. Li, W. Lu, and J. Weng. Copy¬-move forgery detection based on hybrid features. Engineering Applications of Artificial Intelligence, vol. 59, pp. 73-83, 2017.</p>\n<p>[12]E. Ardizzone, A. Bruno, and G. Mazzola. Copy move forgery detection by matching triangles of keypoints. IEEE Transactions on Information Forensics and Security, vol. 10, no. 10, pp. 2084-2094, 2015.</p>\n<p>[13]J. Li, X. Li, B. Yang, and X. Sun. Segmentation¬ based image copy¬-move forgery detection scheme. IEEE Transactions on Information Forensics and Security, vol. 10, no. 3, pp. 507-518, 2015.</p>\n<p>[14]M. Zandi, A. M.-Aznaveh and A. Talebpour. Iterative copy-¬move forgery detection based on a new interest point detector. IEEE Transactions on Information Forensics and Security, vol. 11, no. 11, pp. 2499-2512, 2016.</p>\n<p>[15]Y. Li, and J. Zhou. Fast and effective image copy¬-move forgery detection via hierarchical feature point matching. IEEE Transactions on Information Forensics and Security, vol. 14, no. 5, pp. 1307-1322, 2019.</p>\n<p>[16]Y. Wu, W. A.-Almageed, and P. Natarajan. BusterNet: Detecting copy-move image forgery with source/target localization. Proceedings of the European Conference on Computer Vision (ECCV), Munich, Germany, pp.170-186, 2018.</p>\n<p>[17]B. Chen, W. Tan, G. Coatrieux, Y. Zheng, and Y. Q. Shi. A serial image copy-move forgery localization scheme with source/target distinguishment. IEEE Transactions on Multimedia, DOI: 10.1109/TMM.2020.3026868, 2020.</p>\n<p>[18]M. Barni, Q. -T. Phan, and B. Tondi. Copy move source-target disambiguation through multi-branch CNNs. IEEE Transactions on Information Forensics and Security, vol. 16, pp. 1825-1840, 2021.</p>\n<p>[19]J. Zhong, and C. Pun. An end-to-end Dense-InceptionNet for image copy-move forgery detection. IEEE Transactions on Information Forensics and Security, vol. 15, pp. 2134-2146, 2020.</p>\n<p>[20]A. Criminisi, P. Perez, and K. Toyama. Region filling and object removal by exemplar-based image inpainting. IEEE Transactions on Image Processing, vol. 13, no. 9, pp. 1200-1212, 2004.</p>\n<p>[21]Q. Wu, S. Sun, W. Zhu, G. Li, and D. Tu. Detection of digital doctoring in exemplar-based inpainted images. International Conference on Machine Learning and Cybernetics (ICMLC), Kunming, China, pp. 1222–1226, 2008.</p>\n<p>[22]K. S. Bacchuwar, Aakashdeep, and K. R. Ramakrishnan. A jump patch-block match algorithm for multiple forgery detection. International Mutli-Conference on Automation, Computing, Communication, Control and Compressed Sensing (iMac4s), Kottayam, India, pp. 723-728, 2013.</p>\n<p>[23]I. Chang, J. Yu, and C. Chang. A forgery detection algorithm for exemplar-based inpainting images using multi-region relation. Image and vision computing, vol. 31, no. 1, pp. 57-71, 2013.</p>\n<p>[24]Z. Liang, G. Yang, X. Ding, and L. Li. An efficient forgery detection algorithm for object removal by exemplar-based image inpainting. Journal of Visual Communication and Image Representation, vol. 30, pp. 75-85, 2015.</p>\n<p>[25]L. Shen, G. Yang, L. Li, X. Sun. Robust detection for object removal by exemplar-based image inpainting with post-processing. International Conference on Natural Computation, Fuzzy Systems and Knowledge Discovery (FSKD), Guilin, China, pp. 2730-2736, 2017.</p>\n<p>[26]Y. Zhao, M. Liao, F. Y. Shih, and Y. Q. Shic. Tampered region detection of inpainting JPEG images. Optik, vol. 124, no. 16, pp. 2487-2492, 2013.</p>\n<p>[27]Q. Liu, A. H. Sung, B. Zhou, and M. Qiao. Exposing inpainting forgery in JPEG images under recompression attacks. IEEE International Conference on Machine Learning and Applications (ICMLA), Anaheim, CA, USA, pp. 164-169, 2016.</p>\n<p>[28]H. Li, W. Luo, and J. Huang. Localization of diffusion-based inpainting in digital images. IEEE transactions on information forensics and security, vol. 12, no. 12, pp. 3050-3064, 2017.</p>\n<p>[29]刘婷婷, 张玉金, 吴飞等. 基于梯度域导向滤波增强的图像扩散修复取证[J]. 激光与光电子学进展, 2020, vol. 57, no. 8, pp. 35-42.</p>\n<p>[30]朱新山, 钱永军, 孙彪等. 基于深度神经网络的图像修复取证算法[J]. 光学学报, 2018, vol. 38, no. 11, pp. 97-105.</p>\n<p>[31]X. Zhu, Y. Qian, X. Zhao, B. Sun, and Y. Sun. A deep learning approach to patch-based image inpainting forensics. Signal Processing: Image Communication, vol. 67, pp. 90–99, 2018.</p>\n<p>[32]X. Wang, H. Wang, and S. Niu. An image forensic method for AI inpainting using faster R-CNN. International Conference on Artificial Intelligence and Security (ICAIS), New York, USA, pp. 476-487, 2019.</p>\n<p>[33]M. Lu, and S. Niu. A detection approach using LSTM-CNN for object removal caused by exemplar-based image inpainting. Electronics, vol. 9, pp. 858, 2020.</p>\n<p>[34]H. Li, and J. Huang. Localization of deep inpainting using high-pass fully convolutional network. IEEE International Conference on Computer Vision (ICCV), Seoul, South Korea, pp. 8301-8310, 2019.</p>\n<p>[35]H. Wu, and J. Zhou. IID-Net: image inpainting detection network via neural architecture search and attention. IEEE Transactions on Circuits and Systems for Video Technology, DOI: 10.1109/TCSVT.2021.3075039, 2021.</p>\n<p>[36]P. Kakar, N. Sudha, and W. Ser. Exposing digital image forgeries by detecting discrepancies in motion blur. IEEE Transactions on Multimedia, vol. 13, no. 3, pp. 443-452, 2011.</p>\n<p>[37]K. Bahrami, A. C. Kot, and J. Fan. Splicing detection in out-of-focus blurred images. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 144-149, 2013.</p>\n<p>[38]M. P. Rao, A. N. Rajagopalan, and G. Seetharaman. Harnessing motion blur to unveil splicing. IEEE Transactions on Information Forensics and Security, vol. 9, no. 4, pp. 583-595, 2014.</p>\n<p>[39]C. Song, and X. Lin. Natural image splicing detection based on defocus blur at edges. IEEE/CIC International Conference on Communications in China (ICCC), Shanghai, China, pp. 225-230, 2014.</p>\n<p>[40]K. Bahrami, A. C. Kot, L. Li, and H. Li. Blurred image splicing localization by exposing blur type inconsistency. IEEE Transactions on Information Forensics and Security, vol. 10, no. 5, pp. 999-1009, 2015.</p>\n<p>[41]B. Mahdian, and S. Saic. Using noise inconsistencies for blind image forensics. Image and Vision Computing, vol. 27, no. 10, pp. 1497-1503, 2009.</p>\n<p>[42]S. Lyu, X. Pan, and X. Zhang. Exposing region splicing forgeries with blind local noise estimation. International Journal of Computer Vision, vol. 110, no. 2, pp. 202–221, 2014.</p>\n<p>[43]L. Zhan, and Y. Zhu. Passive forensics for image splicing based on PCA noise estimation. International Conference for Internet Technology and Secured Transactions (ICITST), London, UK, pp. 78-83, 2015.</p>\n<p>[44]H. Zeng, Y. Zhan, X. Kang, and X. Lin. Image splicing localization using PCA-based noise level estimation. Multimedia Tools and Applications, vol. 76, no. 4, pp. 4783–4799, 2017.</p>\n<p>[45]H. Yao, S. Wang, X. Zhang, C. Qin, and J. Wang. Detecting image splicing based on noise level inconsistency. Multimedia Tools and Applications, vol. 76, no. 10, pp. 12457–12479, 2017.</p>\n<p>[46]B. Liu, and C. Pun. Multi-object splicing forgery detection using noise level difference. IEEE Conference on Dependable and Secure Computing (DSC), Taipei, Taiwan, pp. 533-534, 2017.</p>\n<p>[47]Z. Nan, and L. Zhao. Blind image splicing detection via noise level function. Signal Processing: Image Communication, vol. 69, pp. 181-192, 2018.</p>\n<p>[48]Q. Liu, X. Cao, C. Deng, and X. Guo. Identifying image composites through shadow matte consistency. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1111-1122, 2011.</p>\n<p>[49]Y. Ke, F. Qin, W. Min, and G. Zhang. Exposing image forgery by detecting consistency of shadow. The scientific world journal, vol. 2014, no. 3, pp. 1-9, 2014.</p>\n<p>[50]B. Xiao, Y. Wei, X. Bi, W. Li, and J. Ma. Image splicing forgery detection combining coarse to refined convolutional neural network and adaptive clustering. Information Sciences, vol. 511, pp. 172–191, 2020.</p>\n<p>[51]J. H. Bappy, C. Simons, L. Nataraj, B. S. Manjunath, and A. K. Roy-Chowdhury. Hybrid LSTM and encoder-decoder architecture for detection of image forgeries. IEEE Transactions on Image Processing, vol. 28, no. 7, pp. 3286-3300, 2019.</p>\n<p>[52]Y. Wu, W. AbdAlmageed, and P. Natarajan. ManTra-Net: manipulation tracing network for detection and localization of image forgeries with anomalous features. IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), Long Beach, CA, USA, pp. 9535-9544, 2019.</p>\n<p>[53]X. Bi, Y. Wei, B. Xiao, and W. Li. RRU-Net: the ringed residual U-Net for image splicing forgery detection. IEEE/CVF Conference on Computer Vision and Pattern Recognition Workshops (CVPRW), Long Beach, CA, USA, pp. 30-39, 2019.</p>\n<p>[54]P. Zhou, X. Han, V. I. Morariu, and L. S. Davis. Learning rich features for image manipulation detection. IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), Salt Lake, USA pp. 1053-1061, 2018.</p>\n<p>[55]Y. Wu, W. Abd-Almageed, and P. Natarajan. Deep matching and validation network: An end-to-end solution to constrained image splicing localization and detection. ACM international conference on Multimedia (MM), Mountain View, CA, USA, pp. 1480–1502, 2017.</p>\n<p>[56]K. Ye, J. Dong, W. Wang, B. Peng, and T. Tan. Feature pyramid deep matching and localization network for image forensics. Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC), Honolulu, Hawaii, USA, pp. 1796–1802, 2018.</p>\n<p>[57]Y. Liu, X. Zhu, X. Zhao, and Y. Cao. Adversarial learning for constrained image splicing detection and localization based on atrous convolution. IEEE Transactions on Information Forensics and Security, vol. 14, no. 10, pp. 2551-2566, 2019.</p>\n<h2 id=\"数字图像处理操作取证-Manipulation\"><a href=\"#数字图像处理操作取证-Manipulation\" class=\"headerlink\" title=\"数字图像处理操作取证(Manipulation)\"></a>数字图像处理操作取证(Manipulation)</h2><h3 id=\"JPEG重压缩取证技术\"><a href=\"#JPEG重压缩取证技术\" class=\"headerlink\" title=\"JPEG重压缩取证技术\"></a>JPEG重压缩取证技术</h3><p>篡改图像必然会经过重压缩这一步骤，因此数字图像重压缩检测能够为数字图像取证提供强有力的辅助依据。目前，使用最广泛的图像压缩标准是JPEG，若原始的图像是JPEG格式，篡改后的图像为达到不易于检测的效果，同样会保存为JPEG格式，则图像会进行两次JPEG压缩。现如今JPEG重压缩取证包含两个主要研究课题，一是<strong>JPEG重压缩检测</strong>，二是<strong>对JPEG重压缩区域进行定位</strong>。</p>\n<h4 id=\"JPEG重压缩检测\"><a href=\"#JPEG重压缩检测\" class=\"headerlink\" title=\"JPEG重压缩检测\"></a>JPEG重压缩检测</h4><p>JPEG压缩属于有损压缩，每次压缩都会丢失一部分信息，由于JPEG重压缩对图像数据进行了两次量化操作，引入了一些单次JPEG压缩所没有的特征，因此通过一定的统计检测可以发现图像是否经历过JPEG重压缩。</p>\n<p>现今的重压缩检测算法大多遵循一个检测模式，第一步是从图像中<strong>找到能最大化单次压缩和双重压缩类间差异的特征</strong>；第二步则是在得到特征后，基于数据驱动训练分类器，<strong>用于识别和分类双重压缩和单次压缩</strong>。</p>\n<ul>\n<li>比如，Shang等人[1]<strong>以DCT系数</strong>矩阵水平、垂直、对角、反对角方向差分的高阶马尔科夫转移概率作为特征，用SVM和EC分类器分类实现JPEG重压缩图像检测。</li>\n<li>Zeng等人[2]提出了一种改进的密集连接的<strong>卷积网络（DenseNet）</strong>来完成双压缩图像中主JPEG压缩的检测任务。他们在网络的前端加入了一个特殊的滤波层，该层通常包含选定的滤波和，可以帮助后续网络更容易地识别图像。</li>\n<li>Wang等人[3]提出了<strong>一种基于四元数离散余弦变换（QDCT）域的改进马尔可夫压缩检测算法</strong>。首先，对给定JPEG图像的颜色信息提取图像构造四元数；然后，构造图像块QDCT系数矩阵，包括振幅和三个角；接着，在相应的细化过程中，由转移概率矩阵生成细化的马尔可夫特征；最后，使用支持向量机（SVM）方法进行NA-DJPEG压缩检测。然而这些统计模型大多关注变换域系数本身，忽略了JPEG压缩给变换域系数引入的相关性，使得当后压缩质量因子远小于前压缩质量因子时，难以判定双重压缩的存在性。</li>\n</ul>\n<p>此外，<strong>为了更进一步获取重压缩痕迹，首次压缩时的量化步长估计</strong>是非常关键的问题。</p>\n<ul>\n<li>Galvan等人[4]首先使用直方图滤波除去二次量化以外操作引入的直方图噪声，然后使用一个新的估计方程来估计第一次量化使用的量化步长。该方法在实际应用中可以更准确估计量化步长。然而当后压缩质量因子较小时，大量图像数据会被破坏乃至丢弃，使得这类方法检测效果不佳。</li>\n<li>此外，Thai等人[5]<strong>将量化效应和DCT系数统计相结合</strong>，对先前压缩并存储为无损的图像进行量化步长的估计。</li>\n</ul>\n<h4 id=\"JPEG重压缩定位\"><a href=\"#JPEG重压缩定位\" class=\"headerlink\" title=\"JPEG重压缩定位\"></a>JPEG重压缩定位</h4><p>一些研究将JPEG重压缩检测和篡改区域定位相结合。</p>\n<ul>\n<li>Yang等人[6]先提取相同频率的量化DCT系数，建立新的数据矩阵，然后考虑方向对DCT域相邻位置相关性的影响，执行12种不同方向的高通滤波模板，计算每个滤波数据的平移概率矩阵。然后利用PCA和SVM分别对特征维数进行降维和分类器训练，以此确定图像是否被篡改。</li>\n<li>Wang等人[7]利用Laplacian分布来描述在拼接区域和原图像的DCT系数分布，通过估计DCT块的后验概率来确定被篡改区域。</li>\n<li>Amerini等人[8]使用卷积神经网络（CNN）实现了JPEG重压缩的篡改定位。</li>\n<li>Zhou等人[9]使用一种双通道的快速R-CNN网络，并对其进行端到端的训练，对图像进行篡改检测。双通道之一是<strong>RGB流</strong>，其目的是从RGB图像输入中提取特征，以发现篡改特征，如强烈的对比度差、非自然的篡改边界等。<strong>另一种是利用隐写分析丰富模型滤波层提取的噪声特征</strong>，发现真实区域和篡改区域之间的噪声不一致。然后，通过双线性池化层融合来自两种流的特征，进一步合并这两种模式的检测结果。</li>\n</ul>\n<p>除JPEG压缩外，已经有一些学者研究更为一般的情况，估计图像可能经受过的各种变换和压缩。</p>\n<ul>\n<li>Tagliasacchi等人[10]给出了一个<strong>一般估计使用的图像变换技术和量化步长的方法</strong>。</li>\n<li>Bianchi等人[11]<strong>给出了一个判定信号是否经历过格量化的最优检测子</strong>，进而将该检测方法应用于实际的场景，并判断图像是否经历过双重JPEG压缩。<strong>但该方法要求两次压缩使用的块划分必须相同</strong>。</li>\n</ul>\n<h3 id=\"增强操作取证技术\"><a href=\"#增强操作取证技术\" class=\"headerlink\" title=\"增强操作取证技术\"></a>增强操作取证技术</h3><p>在现实生活中，经常会遇到数码设备由于光线、环境以及设备自身性能的问题而得到不清晰的图像，导致无法辨识原始图像中的关键目标，需要对图像进行增强处理。图像增强指通过某些图像处理操作，如对比度增强、中值滤波、锐化、模糊等，对原始图像附加一些信息或变换数据，有目的地突出图像中某些“有用”信息或者抑制掩盖图像中某些“无用”信息，扩大图像中不同物体特征之间的差别，以改善图像的视觉效果，丰富信息量。<strong>然而，图像增强操作可以淡化隐藏其他篡改操作的痕迹，达到降低篡改检测性能的目的。</strong>目前，<strong>图像增强操作取证</strong>研究已经吸引了国内外学者的广泛关注，并取得了一些阶段性成果。</p>\n<h4 id=\"对比度增强取证\"><a href=\"#对比度增强取证\" class=\"headerlink\" title=\"对比度增强取证\"></a>对比度增强取证</h4><p>对比度增强是一种被广泛使用的图像增强处理技术，是对图像中每个像素点的值进行非线性映射，通过累积函数对灰度值进行调整，改变图像中像素强度的整体分布，最终达到对比度的增强效果。</p>\n<ul>\n<li>Stamm等人[12]利用像素值映射在图像直方图上的统计特征，通过观察对比度增强操作向图像直方图的高频成分添加的能量信息，<strong>检测对比度增强操作</strong>。</li>\n<li>Cao等人[13]提出了零波谷特征，即当图像经过对比度增强操作处理后，图像直方图能呈现出明显的波峰波谷，并且生成的波谷都是值为0的零波谷。利用零波谷特征，基于阈值化二类分类检测对比度增强操作。</li>\n<li>Zhang等人[14]提出一种深度多路径网络，基于灰度直方图，通过共享多个卷积层捕获图像底层特征，并利用由多条路径组成的特定操作层学习不同对比度增强操作的特征，最后通过聚合层对原始图像和对比度增强操作处理的图像进行分类。</li>\n<li>王金伟等人[15]提出一种基于线性模型的图像对比度增强检测算法，提取图像噪声残差，采取分块策略计算每块残差的线性模型，并计算相应的功率谱密度，以整幅图像的均值功率谱密度作为分类特征，利用支持向量机进行分类。</li>\n</ul>\n<h4 id=\"模糊取证\"><a href=\"#模糊取证\" class=\"headerlink\" title=\"模糊取证\"></a>模糊取证</h4><p>为了消除图像篡改在拼接边缘产生的视觉或统计上的畸变，通常会在图像篡改后使用模糊操作消除简单拼接留下的伪造痕迹。模糊操作的基本原理是对图像的局部邻近像素值进行邻域灰度平均。</p>\n<ul>\n<li>周琳娜等人[16]提出一种基于图像形态学滤波边缘特征的模糊操作取证方法，用同态滤波和形态学滤波增强模糊操作的图像边缘，利用离焦模糊和人工模糊的边缘特性，<strong>检测伪造图像的模糊操作痕迹</strong>。</li>\n<li>Su等人[17]提出一种三维模糊识别方法，将图像划分为非模糊区、离焦模糊区和运动模糊区，利用梯度信息预测不同类型的模糊区域，并采用超像素分割技术对模糊区域进行细化识别。</li>\n<li>Xu等人[18]提出几种新的局部模糊度量方法，使用不同类型的图像信息，包括颜色、梯度和光谱信息，基于支持向量机，构造最优模糊检测分类器。</li>\n</ul>\n<h4 id=\"中值滤波取证\"><a href=\"#中值滤波取证\" class=\"headerlink\" title=\"中值滤波取证\"></a>中值滤波取证</h4><p>中值滤波操作是一种高度非线性操作，由于其良好的平滑滤波性质，通常被用于反取证技术中[19-20]，使得中值滤波取证越来越受到关注。</p>\n<ul>\n<li>Kirchner等人[21]利用图像差分转移概率矩阵构造特征，检测图像是否经过中值滤波操作处理。</li>\n<li>Kang等人[22]利用中值滤波残差特征，将特征相邻元素之间的关系建模为自回归模型，利用自回归系数检测中值滤波。</li>\n<li>彭安杰等人[23]提出一种基于中值滤波残差及其差分的鲁棒中值滤波取证技术，根据方向性和对称性将多方向差分特征分组，分别建立自回归模型，并提取其模型参数和直方图特征，组合成中值滤波检测特征。</li>\n</ul>\n<h4 id=\"锐化取证\"><a href=\"#锐化取证\" class=\"headerlink\" title=\"锐化取证\"></a>锐化取证</h4><p>锐化滤波常用于增强图像的局部对比度，使边缘和文理等细节变得更加清晰锐利。同样，作为常用的图像润饰操作，锐化经常被用于削弱掩盖图像篡改时遗留的痕迹。</p>\n<ul>\n<li>Cao等人[24]提出了一种有效的过冲效应测度方法，进而提取有效的指纹特征，通过阈值化分类来鉴别图像是否经历过USM锐化操作。</li>\n<li>Ding等人[25]提出一种基于局部二值模式LBP的锐化检测方法，采用Canny算子进行边缘检测，将LBP应用于图像检测到的边缘像素并提取特征，基于支持向量机进行锐化分类。</li>\n<li>F. Ding等人[26]利用图像USM锐化引起的纹理变化，提出一种边缘垂直二值编码的USM锐化检测方法。</li>\n</ul>\n<h3 id=\"几何操作取证技术\"><a href=\"#几何操作取证技术\" class=\"headerlink\" title=\"几何操作取证技术\"></a><strong>几何操作取证技术</strong></h3><p>当一幅图像被篡改时，例如拷贝一副图像的某一区域覆盖到被篡改图像中，篡改者通常需要<strong>采取缩放、旋转等几何变换来掩盖篡改痕迹</strong>。而这一过程需要对图像重新采样和重构，因此图像重采样检测是数字图像取证中十分重要的研究课题。重采样取证主要包含两个主要的研究目标，第一是<strong>判断图像是否经过重采样的重采样检测</strong>，第二是<strong>估计重采样操作过程中施加于图像上的相关参数，如重采样因子、旋转角度</strong>等。</p>\n<h4 id=\"缩放取证\"><a href=\"#缩放取证\" class=\"headerlink\" title=\"缩放取证\"></a>缩放取证</h4><p>缩放操作是最常见的几何操作，常见于篡改图像后，调整篡改区域的大小以适配图像内容。然而在实际情况中，受限于网络传输速度与机器存储容量，篡改图像在缩放前后很可能会经历JPEG压缩。</p>\n<p>因此，涉及缩放操作的重采样取证有两大类研究方向，第一是针对无JPEG压缩的单一重采样取证场景；第二是和JPEG压缩操作相结合的复合取证场景，根据JPEG压缩出现的顺序，该场景可细分为三种复合取证场景，即Pre-JPEG重采样<strong>（JPEG格式缩放后保存为无损格式）</strong>、Post-JPEG重采样<strong>（无损格式缩放后保存为JPEG格式）</strong>和Double-JPEG重采样<strong>（JPEG格式缩放后保存为JPEG格式）</strong>三种情况。</p>\n<p>针对无JPEG压缩的单一重采样取证场景，重采样图像中每一个像素都由原始像素与插值函数卷积而成，且像素之间隐藏着重采样痕迹。由于插值的影响，这种重采样痕迹反映在空域上体现为像素之间存在相关性[27]，且相邻插值像素的间隔存在一种周期性；反映在频域上体现为存在频谱峰值，且峰值位置与放缩因子有关[28]。鉴于重采样操作的这些特点，近年来专家学者们提出了许多重采样检测算法，虽然这些算法的思路各异，但是大体都遵循一个流程。首先，从待检测图像中通过某种方式提取出残差信号，这种残差信号放大了重采样痕迹，剔除噪音与视觉信息，显性的揭露出重采样操作遗留下的周期性。根据所采用的数学模型不同，这种残差信号可以通过计算图像的二阶差分获得[29]，也可以通过快速滤波计算出插值像素得到相应的概率图[30]。在得到蕴含周期性的残差信号后，第二步就是根据这种信号判别重采样操作的存在，最常用的手段是频谱方法，通过对残差信号进行傅里叶变换，由于周期函数傅里叶变换的特殊性，重采样图像的频谱图上会出现与放缩因子有关的频谱峰值[28]，这些峰值可以作为重采样操作存在的证据，更进一步，根据峰值与放缩因子的关系估计出相应的放缩因子。除此之外，可以将第一步得到的残差信号视为手工设计的特征，作为输入训练一个强有力的分类器，通过数据驱动学习一个重采样判别模型[31]。更进一步，可以借鉴深度学习在图像检测领域的发展，提出用于重采样检测和因子估计的深度网络[32-35]。</p>\n<p>然而上述方法无法直接运用于与JPEG压缩操作相结合的复合取证场景，这是因为JPEG压缩通过分块将图像保存并复原，使得JPEG图像像素之间先天就带有周期性，当与放缩操作结合时，会混淆放缩操作带来的周期性，最终形成复合的周期，使得现有的重采样图像检测算法失效。</p>\n<ul>\n<li>针对Pre-JPEG重采样的情况，Liu等人[36]基于自相关函数构建了重采样图像的数学模型，他们通过该模型推导出了重采样系数、插值函数和重采样谱峰位置的关系，他们提出了基于图像差分极值点距离直方图的方法，通过挖掘图像差分的规律来取证重采样操作和进行因子估计。而后，他们还提出了针对Post-JPEG重采样图像的取证方案[37]，他们基于循环平稳信号分析发现Post-JPEG重采样图像上会出现一系列的对称谐波峰，并提出一种基于相位抵消的图像重采样检测和因子估计方法。</li>\n<li>除此之外，Lu等人[38]还提出了基于反缩放策略的双域联合估计算法，从频谱域和DCT域综合估计重采样因子，他们首先通过搜索匹配从Double-JPEG图像频谱中提取数个可能的候选因子，然后根据DCT域系数的独立同分布模型，使用反缩放策略得到最优估计。</li>\n</ul>\n<h4 id=\"旋转取证\"><a href=\"#旋转取证\" class=\"headerlink\" title=\"旋转取证\"></a>旋转取证</h4><p>旋转操作也是常见的几何操作之一，同样涉及到图像像素重采样，在空域和频域上的操作痕迹与缩放操作有许多共通之处。</p>\n<ul>\n<li>Wei等人将旋转操作视为一种特殊的缩放操作[39]，将旋转角度与特定的缩放因子结合在一起，通过频谱峰值与缩放因子的关系推导出图像经历的旋转角度，不仅如此，他们发现不同的频谱提取操作顺序可以更加明显的突出重采样峰值特征，有利于进一步区分旋转操作和缩放操作，并在此基础上提出了只包含旋转和缩放的二次几何变换操作链恢复算法。</li>\n<li>此后，Chen等人[40]提出对图像连续几何变换的取证方法，他们基于平方信号分析图像重采样特征，将Gallagher的理论推广到连续二次几何变换领域，揭示了二次几何变换的频谱特征，并提出了更细粒度的只包含旋转和缩放的二次几何变换操作链恢复算法。随后，他们根据二维自相关函数，提出了针对旋转缩放等仿射变换的参数估计方案[41]。</li>\n</ul>\n<h3 id=\"操作链取证技术\"><a href=\"#操作链取证技术\" class=\"headerlink\" title=\"操作链取证技术\"></a>操作链取证技术</h3><p>实际的图像处理过程可能包含多个操作，它们按照一定的顺序共同构成图像操作链。当图像经历多种操作处理时，不同操作遗留在图像中的痕迹可能相互叠加和覆盖，从而导致某个操作的遗留痕迹被掩盖或者破坏。同时，痕迹间的相互影响与操作的执行顺序有关，当操作顺序发生变化时，最终的遗留痕迹也会有所不同。因此，由于多个操作之间的相互影响，针对单个篡改操作的取证方法难以满足图像操作链取证的实际需求。<strong>为了完整地揭示数字图像可能经历的处理过程，需要明确图像操作链包含的操作类型，多个操作的拓扑顺序，以及处理操作的关键参数。目前，图像操作链取证研究可以粗略的分为基于传统手工特征的方法和基于深度学习的方法。</strong></p>\n<h4 id=\"基于传统手工特征的方法-1\"><a href=\"#基于传统手工特征的方法-1\" class=\"headerlink\" title=\"基于传统手工特征的方法\"></a>基于传统手工特征的方法</h4><ul>\n<li>西班牙维戈大学P. Comesaña于2012年最先提出操作链取证[42]。他从理论上分析了利用已有的单操作篡改取证算法检测图像操作链的可能性,并以量化和加性高斯白噪声组成的操作链为例进行了实验验证。随后, 他还进一步实验分析了包含更多操作的操作链拓扑结构[43]。</li>\n<li>Stamm [44]等人针对对比度增强与缩放组成的二元操作链取证，提出采用直方图缺值特征和图像预测误差评价，分别进行对比度增强和图像缩放的检测，并引入了条件指纹的概念，用以单独识别对比度增强先于缩放操作的操作顺序。</li>\n<li>Li [45]等人针对内容感知缩放和对比度增强组成的二元操作链取证，提出了通过计算马尔科夫一步转移概率矩阵以及提取DCT域的高维特征进行检测的方法。</li>\n<li>Chu [46]等人从信息论的角度分析了操作顺序检测的可能性以及最优检测阈值的选取问题。</li>\n<li>Gao等人[47]将操作可检测性问题转换为复杂假设检验问题，提出一种基于信息理论框架的图像操作链中特定操作的检测方案。</li>\n<li>Chen等人[48]提出了一种基于决策融合的图像操作链中操作类型识别方法，挖掘不同图像特征，获取不同的取证证据。基于可信度计算策略，重新分配各证据权重，并通过决策融合识别操作链中包含的操作类型。</li>\n<li>Liao等人[49]从操作相关性程度分析入手，开展操作链的参数估计研究。通过探究操作顺序和参数变化对生成图像及已有参数估计特征所带来的影响，将操作链中各操作间相关性分为耦合与非耦合，并设计了不同的参数估计策略。</li>\n</ul>\n<h4 id=\"基于深度学习的方法-3\"><a href=\"#基于深度学习的方法-3\" class=\"headerlink\" title=\"基于深度学习的方法\"></a>基于深度学习的方法</h4><ul>\n<li>Boroumand等人[50]针对特定二元操作链，通过<strong>在卷积神经网络结构中添加全局平均池化层</strong>, 实现对任意尺寸篡改图像的操作种类鉴别。</li>\n<li>Stamm等人[51]基于设计的CNN约束分类器, <strong>通过联合提取与操作序列相关的条件指纹特征</strong>, 实现了对特定二元操作序列的种类识别和顺序鉴定。</li>\n<li>Chen等人[52]设计了一个自动化的神经网络，通<strong>过强化学习生成高性能的神经网络，用于多目标取证和处理历史检测。</strong>同时，利用基于模块的搜索空间，通过密集连接，提升网络设计效率。</li>\n<li>Liao等人[53]提出了<strong>基于双流卷积神经网络的图像操作链取证框架</strong>，并设计了多个针对特定操作组合的预处理。该网络包括空域卷积流和变换特征提取流，利用空域卷积流提取可视篡改特征，而变换特征提取流则通过结合针对性设计的预处理从图像的变换域提取残差特征。</li>\n</ul>\n<h3 id=\"小结与思考-1\"><a href=\"#小结与思考-1\" class=\"headerlink\" title=\"小结与思考\"></a><strong>小结与思考</strong></h3><p>图像处理操作取证是多媒体安全领域中的热点问题，除了上述处理操作的取证，小波去噪、直方图均衡化、仿射变换等图像处理操作的取证也都受到了政治、经济、社会文化等多个领域的广泛关注。尽管图像处理取证技术已经在特定篡改操作的取证等方面取得了阶段性进展，但在研究的深度和广度上仍未成熟，还有一些亟待解决的问题，主要表现在：</p>\n<ol>\n<li>在已知图像处理操作的情况下，可以通过模拟操作来训练模型，但对未知操作，如何设计对不同强度、不同操作组合均有效的取证模型是值得进一步探索的方向。</li>\n<li>当图像经历多种处理操作编辑润饰时，<strong>不同操作的痕迹相互掩盖混淆</strong>，图像处理操作取证变得困难。大多<strong>数图像处理操作取证方法是对单个特定操作或者特定二元操作链检测有效</strong>，<strong>缺乏适用于各种图像处理操作链取证</strong>的通用理论基础。</li>\n</ol>\n<h3 id=\"参考文献-1\"><a href=\"#参考文献-1\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>[1]S. Shang, Y. Zhao, and R. Ni. Double JPEG detection using high order statistic features. IEEE International Conference on Digital Signal Processing (DSP), Beijing, China, pp. 550-554, 2016.</p>\n<p>[2]X. Zeng, G. Feng, and X. Zhang. Detection of double JPEG compression using modified DenseNet model. Multimedia Tools and Applications, vol. 78, no. 7, pp. 8183-8196, 2019.</p>\n<p>[3]J. Wang, W. Huang, X. Luo, Y.-Q. Shi, and S. Kr. Jha. Non-aligned double JPEG compression detection based on refined Markov features in QDCT domain. Journal of Real-time Image Processing, vol. 17, no. 1, pp.7-16, 2019.</p>\n<p>[4]F. Galvan, G. Puglisi, A. R. Bruna, and S. Battiato. First quantization matrix estimation from double compressed JPEG images. IEEE Transactions on Information Forensics and Security, vol. 9, no. 8, pp. 1299-1310, 2014.</p>\n<p>[5]T. Hai Thai, R. Cogranne, F. Retraint, and T. Doan. JPEG quantization step estimation and its applications to digital image forensics. IEEE Transactions on Information Forensics and Security, vol. 12, no. 1, pp. 123-133, 2017.</p>\n<p>[6]P. Yang, R. Ni, and Y. Zhao. Double JPEG compression detection by exploring the correlations in DCT domain. Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC), Honolulu, HI, USA, pp. 728-732, 2018.</p>\n<p>[7]W. Wang, J. Dong, and T. Tan. Exploring DCT coefficient quantization effects for local tampering detection. IEEE Transactions on Information Forensics and Security, vol. 9, no. 10, pp. 1653-1666, 2014.</p>\n<p>[8]I. Amerini, T. Uricchio, L. Ballan, and R. Caldelli. Localization of JPEG double compression through multi-domain convolutional neural networks. IEEE Conference on Computer Vision and Pattern Recognition Workshops (CVPRW), Honolulu, HI, USA, pp. 1865-1871, 2017.</p>\n<p>[9]P. Zhou, X. Han, V. I. Morariu, and L. S. Davis. Learning Rich Features for Image Manipulation Detection. IEEE Conference on Computer Vision and Pattern Recognition (CVPR), Salt Lake City, UT, USA, pp. 1053-1061, 2018.</p>\n<p>[10]M. Tagliasacchi, M. V.-Scarzanella, P. L. Dragotti, and S. Tubaro. Transform coder identification. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Vancouver, BC, Canada pp. 5785-5789, 2013.</p>\n<p>[11]T. Bianchi, A. Piva, and F. Pérez-González. Near optimal detection of quantized signals and application to JPEG forensics. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 168-173, 2013.</p>\n<p>[12]M. C. Stamm, and K. J. Ray Liu. Forensic detection of image manipulation using statistical intrinsic fingerprints. IEEE Transactions on Information Forensics and Security, vol. 5, no. 3, pp. 492-506, 2010.</p>\n<p>[13]G. Cao, Y. Zhao, R. Ni, and X. Li. Contrast enhancement-based forensics in digital images. IEEE Transactions on Information Forensics and Security, vol. 9, no. 3, pp. 515-525, 2014.</p>\n<p>[14]C. Zhang, D. Du, L. Ke, H. Qi, and S. Lyu. Global contrast enhancement detection via deep multi-path network. International Conference on Pattern Recognition (ICPR), Beijing, China, pp. 2815-2820, 2018.</p>\n<p>[15]王金伟, 吴国静. 基于线性模型的图像对比度增强取证[J]. 网络空间安全, 2019, vol. 10, no. 8, pp. 47-54.</p>\n<p>[16]周琳娜, 王东明, 郭云彪, 杨义先. 基于数字图像边缘特性的形态学滤波取证技术[J]. 电子学报, 2008, vol. 36, no. 6, pp. 1047-1051.</p>\n<p>[17]B. Su, S. Lu, and C. L. Tan. Blurred image region detection and classification. ACM International Conference on Multimedia (ACM MM), New York, NY, USA, pp. 1397-1400, 2011.</p>\n<p>[18]W. Xu, J. Mulligan, D. Xu, and X. Chen. Detecting and classifying blurred image regions. IEEE International Conference on Multimedia and Expo (ICME), San Jose, CA, USA, 2013.</p>\n<p>[19]M. Kirchner, and R. Bohme. Hiding traces of resampling in digital images. IEEE Transactions on Information Forensics and Security, vol. 3, no. 4, pp. 582-592, 2008.</p>\n<p>[20]M. C. Stamm, and K. J. Ray Liu. Anti-forensic of digital image compression. IEEE Transactions on Information Forensics and Security, vol. 6, no. 3, pp. 1050-1065, 2011.</p>\n<p>[21]M. Kirchner, and J. Fridrich. On detection of median filtering in digital images. The SPIE-Media Forensics and Security, San Jose, USA, pp. 754110-1-75411012, 2010.</p>\n<p>[22]X. Kang, M. C. Stamm, A. Peng, and K. J. Ray Liu. Robust median filtering forensics using an autoregressive model. IEEE Transactions on Information Forensics and Security, vol. 8, no. 9, pp. 1456-1468, 2013.</p>\n<p>[23]彭安杰, 康显桂. 基于滤波残差多方向差分的中值滤波取证技术[J]. 计算机学报, 2016. vol. 39, no. 3, pp. 503-515.</p>\n<p>[24]G. Cao, Y. Zhao, R. Ni, and A. C. Kot. Unsharp masking sharpening detection via overshoot artifacts analysis. IEEE Signal Processing Letters, vol. 18, no. 10, pp. 603-606, 2011.</p>\n<p>[25]F. Ding, G. Zhu, and Y. Q. Shi. A novel method for detecting image sharpening based on local binary pattern. International Conference on Digital Forensics and Watermarking (IWDW), Berlin, Germany, pp. 180-191, 2013.</p>\n<p>[26]F. Ding, G. Zhu, J. Yang, J. Xie, and Y. Q. Shi. Edge perpendicular binary coding for USM sharpening detection. IEEE Signal Processing Letters, vol. 22, no. 3, pp. 327-331, 2015.</p>\n<p>[27]A. C. Popescu, and H. Farid. Exposing digital forgeries by detecting traces of resampling. IEEE Transactions on Signal Processing, vol. 53, no. 2, pp. 758-767, 2005.</p>\n<p>[28]A. C. Gallagher. Detection of linear and cubic interpolation in JPEG compressed images. Canadian Conference on Computer and Robot Vision (CRV), Victoria, BC, Canada, pp. 65-72, 2005.</p>\n<p>[29]B. Mahdian, and S. Saic. Blind authentication using periodic properties of interpolation. IEEE Transactions on Information Forensics and Security, vol. 3, no. 3, pp. 529-538, 2008.</p>\n<p>[30]M. Kirchner. Fast and reliable resampling detection by spectral analysis of fixed linear predictor residue. ACM Workshop on Multimedia and Security (MM &amp; Sec), Oxford, UK, pp. 11-20, 2008.</p>\n<p>[31]X. Feng, I. J. Cox, and D. Gwenaël. Normalized energy density-based forensic detection of resampled images. IEEE Transactions on Multimedia, vol. 14, no. 3, pp. 536-545, 2012.</p>\n<p>[32]B. Bayar, and M. C. Stamm. On the robustness of constrained convolutional neural networks to JPEG post-compression for image resampling detection. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), New Orleans, LA, USA, pp. 2152-2156, 2017.</p>\n<p>[33]B. Bayar, and M. C. Stamm. Constrained convolutional neural networks: A new approach towards general purpose image manipulation detection. IEEE Transactions on Information Forensics and Security, vol. 13, no. 11, pp. 2691–2706, 2018.</p>\n<p>[34]C. Liu, and M. Kirchner. CNN-based rescaling factor estimation. ACM Workshop, pp. 119–124, 2019.</p>\n<p>[35]S. Luo, J. Luo, W. Lu, Y. Fang, J. Zeng, S. Shi, and Y. Zhang. Resampling factor estimation via dual-stream convolutional neural network. Computers, Materials &amp; Continua, vol. 66, no. 1, pp. 647–657, 2021.</p>\n<p>[36]X. Liu, W. Lu, Q. Zhang, J. Huang, and Y. Shi. Downscaling factor estimation on pre-JPEG compressed images. IEEE Transactions on Circuits and Systems for Video Technology, vol. 30, no. 3, pp. 618-631, 2019.</p>\n<p>[37]Q. Zhang, W. Lu, T. Huang, S. Luo, Z. Xu, and Y. Mao. On the robustness of JPEG post-compression to resampling factor estimation. Signal Processing, vol. 168, pp. 107371, 2020.</p>\n<p>[38]W. Lu, Q. Zhang, S. Luo, Y. Zhou, J. Huang, and Y. Q. Shi. Robust estimation of upscaling factor on double JPEG compressed images. IEEE Transactions on Cybernetics, pp. 1-13, 2021.</p>\n<p>[39]W. Wei, S. Wang, X. Zhang, and Z. Tang. Estimation of image rotation angle using interpolation-related spectral signatures with application to blind detection of image forgery. IEEE Transaction on Information Forensics and Security, vol. 5, no. 3, pp. 507-517, 2010.</p>\n<p>[40]C. Chen, J. Ni, Z. Shen, and Y.Q. Shi. Blind forensics of successive geometric transformations in digital images using spectral method: theory and applications. IEEE Transactions on Image Processing, vol. 26, no. 6, pp. 2811-2824, 2017.</p>\n<p>[41]J. Ou, and J. Ni. Blind estimation of affine transformation using 2D cyclostationarity of resampled images. Mippr: Multispectral Image Acquisition, Processing, &amp; Analysis International Society for Optics and Photonics, 2015.</p>\n<p>[42]P. Comesaña. Detection information theoretic measures for quantifying the distinguishability between multimedia operator chains. IEEE International Workshop on Information Forensics and Security (WIFS), Tenerife, Spain, pp. 211-216, 2012.</p>\n<p>[43]P. Comesaña, and F. P. González. Multimedia operator chain topology and ordering estimation based on detection and information theoretic tools. International Conference on Digital Forensics and Watermarking (IWDW), Berlin, Germany, pp. 213-227, 2013.</p>\n<p>[44]M. C. Stamm, X. Chu, and K. J. Ray Liu. Forensically determining the order of signal processing operations. IEEE International Workshop on Information Forensics and Security (WIFS), Guangzhou, China, pp. 162-167, 2013.</p>\n<p>[45]J. Li, Y. Zhao, and R. Ni. Detection of seam carving and contrast enhancement operation chain. International Conference on Intelligent Information Hiding and Multimedia Signal Processing (IIH-MMSP), Adelaide, SA, Australia, pp. 235-238, 2015.</p>\n<p>[46]X. Chu, Y. Chen, and K. J. Ray Liu. Detectability of the order of operations: An information theoretic approach. IEEE Transactions on Information Forensics and Security, vol. 11, no. 4, pp. 823-836, 2016.</p>\n<p>[47]S. Gao, X. Liao, and X. Liu. Real-time detecting one specific tampering operation in multiple operator chains. Journal of Real-Time Image Processing, vol. 16, pp. 741-750, 2019.</p>\n<p>[48]J. Chen, X. Liao, and Z. Qing. Identifying tampering operations in image operator chains based on decision fusion. Signal Processing: Image Communication, vol. 95, pp. 116287-1-116287-10, 2021.</p>\n<p>[49]X. Liao, and Z. Huang. A framework for parameters estimation of image operator chain. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), Barcelona, Spain, pp. 2787-2791, 2020.</p>\n<p>[50]M. Boroumand, and J. Fridrich. Deep learning for detecting processing history of images. Electronic Imaging, pp. 213-1-213-9, 2018.</p>\n<p>[51]B. Bayar, and M. C. Stamm. Towards order of processing operations detection in JPEG-compressed images with convolutional neural networks. Electronic Imaging, pp. 211-1-211-9, 2018.</p>\n<p>[52]Y. Chen, Z. Wang, Z. J. Wang, and X. Kang. Automated design of neural network architectures with reinforcement learning for detection of global manipulations. IEEE Journal of Selected Topics in Signal Processing, vol. 14, no. 5, pp. 997-1011, 2020.</p>\n<p>[53]X. Liao, K. Li, X. Zhu, and K. J. Ray Liu. Robust detection of image operator chain with two-stream convolutional neural network. IEEE Journal of Selected Topics in Signal Processing, vol. 14, no. 5, pp. 955-968, 2020.</p>\n<h2 id=\"视频编辑篡改检测Video-manipulation-Detetion综述\"><a href=\"#视频编辑篡改检测Video-manipulation-Detetion综述\" class=\"headerlink\" title=\"视频编辑篡改检测Video manipulation Detetion综述\"></a>视频编辑篡改检测Video manipulation Detetion综述</h2><p>从公开发表论文数量来看，目前绝大多数的篡改被动检测算法都是专用篡改检测算法，且效果十分显著，但需要已知篡改方法和类型的先验知识.通用篡改检测算法针对多种或未知篡改检测准确率良好但也具有一定局限性，实用性和泛化能力有待提高，且对篡改类型的辨识能力不足，只能判断是否经历了篡改操作；<strong>针对多类型+多次篡改的溯源篡改操作链识别能力有限，这也是未来可能的研究方向之一。</strong></p>\n<p><strong>通用篡改检测算法</strong>的最大优势就是快速筛选可疑视频和辨识经历一次及以上篡改的数字视频，然后再用专用算法探测或穷举识别其可能的篡改操作类型或者溯源篡改操作链。总而言之，两者技术是互补关系。</p>\n<h3 id=\"数字视频再编辑篡改技术\"><a href=\"#数字视频再编辑篡改技术\" class=\"headerlink\" title=\"数字视频再编辑篡改技术\"></a>数字视频再编辑篡改技术</h3><p>数字视频编辑篡改技术的一般定义：为了视频画面提质、传输、存储，或改变内容内在关系的后编辑操作的技术集合。这一后编辑操作可能是常规的需求，也可能是恶意的目的。目前，本文中将常见的数字视频编辑篡改技术分为<strong>四大类</strong>：</p>\n<ol>\n<li>数字视频<strong>文件再编辑</strong>的篡改方法：本文是指针对数字视频的码流、或者编码参数、容器等的编辑，达到对原始视频文件的再编辑目的，一般不改变视频内容。例<strong>如，码率重采样、视频格式转码、容器转换、各种滤波器操作等后处理操作</strong>；</li>\n<li>数字视频<strong>内容再编辑</strong>的篡改方法：本文是指针对数字视频的部分解码或完全解码后内容进行内容级编辑操作，达到对原始视频内容的再编辑目的。例如，<strong>视频帧间插入/删除攻击、帧内复制粘贴攻击操作</strong>等；</li>\n<li>数字视频<strong>内容生成</strong>的篡改方法：本文是指<strong>针对数字视频内容的部分生成替换</strong>或全部生成虚拟目标全局替换，进行视频内容级编辑操作，达到对原始视频内容的再编辑目的。例如，使用StyleGAN网络生成虚拟人物或目标的视频内容等操作；</li>\n<li>数字视频的<strong>重拍摄篡改</strong>方法：本文是指针对数字视频内容的重新数字采集再编辑操作，达到对原始视频内容的再编辑目的。例如，<strong>利用数字设备对屏幕画面进行重新拍摄和再编辑操作</strong>。</li>\n</ol>\n<h4 id=\"视频文件再编辑篡改\"><a href=\"#视频文件再编辑篡改\" class=\"headerlink\" title=\"视频文件再编辑篡改\"></a>视频文件再编辑篡改</h4><p>视频文件再编辑篡改是指在不改变视频内容的前提下对视频文件的编辑操作，比如转码操作、分辨率提升/降低、平滑操作、锐化操作、去噪操作、信息隐藏操作等。</p>\n<p>例如，数据隐藏技术可以在不影响视觉效果的前提下，向视频内嵌入信息，实现对视频文件的编辑。例如，北京交通大学的李赵红[4]等人研究了P帧种各尺寸PU划分类型在隐写前后的数目变化，构建了25维和3维特征用来检测HEVC视频的块划分模式隐写算法。帧率变化是通过提升或下降视频的帧率方法来达到编辑视频文件的目的。Khoubani[5]等人基于模糊平滑的快速四元数小波运动补偿进行帧率上转换。这篇论文使用图像序列的相位来考虑QWT运动估计，实现了更准确的运动估计、更少的后处理流程和更低的复杂度。码率变换是另外一种视频文件编辑的方法，Kevin[6]等人提出一种通过求解优化问题来选择比特率的方法即Bola算法。Yin等人[7]提出了MPC算法。Kim[8]等人结合残差学习方式提出了IFCNN网络，用以取代视频编码中的环路滤波算法，即把未经环路滤波的重建图像直接输入网络进行增强处理。</p>\n<h4 id=\"数字视频内容编辑篡改方法\"><a href=\"#数字视频内容编辑篡改方法\" class=\"headerlink\" title=\"数字视频内容编辑篡改方法\"></a>数字视频内容编辑篡改方法</h4><p>视频内容篡改是指部分解码或全解码后，针对音频、图象、视频中特定对象的操作过程，其结果是改变内容的原始属性，导致内容的不可信。从视频帧目标被攻击角度来看，数字视频内容编辑篡改分为<strong>帧间编辑篡改和帧内编辑篡改</strong>。</p>\n<p>视频的帧间编辑篡改方式主要有：帧删除篡改，即删除原始视频的至少一帧或连续多帧的操作；帧插入篡改，即非同源视频的帧片段插入到原视频帧序列中的操作；帧复制粘贴篡改，即同源视频的帧片段在相同视频中不同时间轴上复制插入到原视频中的操作。</p>\n<ul>\n<li>针对这类视频内容的帧间编辑篡改问题，2012年孙锬锋等人[9]提出了视频帧间篡改中主要篡改类型的定义，即包括视频帧复制粘贴、帧插入、帧删除等，其中对于帧的复制粘贴，可以划分为同源和异源两类，同源的帧复制表示复制的对象来自于当前视频片段，而异源帧复制粘贴是将其他视频的片段复制到当前视频片段中。</li>\n<li>2014年王婉等人[10]根据场景的差异性将视频内容编辑篡改划分为静止背景下的内容编辑篡改以及包含运动背景的篡改场景，并提出了一种可以同时检测帧删除，帧插入及帧复制的算法。</li>\n<li>同年柏正尧等人[11]针对帧间篡改对帧间相关性进行研究，并将非负张量分解（Nonnegative tensor factorization, NTF）算法应用到了视频帧间篡改检测中。</li>\n<li>冯春晖等人[13]通过分析残差强度在不同宏块间分布是否具有波动性来检测视频是否被帧删除，并定位删除点的位置。该作者在[13]的基础上进一步分析了具有丰富运动信息下的视频帧间篡改场景，考虑到运动视频容易导致帧间数据特征的变化，作者从帧间差异的角度，提出了一种删帧检测算法[14]，对复杂篡改环境下的序列中不同干扰帧进行分析，并利用运动残差特征区分不同干扰帧和删帧位置处的帧，进而提出一种去帧内编码处理算法，使算法能够应对运动信息带来的影响。</li>\n<li>不同于视频内容帧间篡改，视频内容帧内篡改并非以帧为单位进行篡改，而是以目标为单位进行编辑篡改操作，2021年Yang Quanxin等人[12] 指出视频帧内篡改主要有空域复制粘贴，帧内目标移除等，作者发现帧内篡改将引起视频在时空域上的高频信息的波动。</li>\n</ul>\n<h4 id=\"数字视频内容生成篡改方法\"><a href=\"#数字视频内容生成篡改方法\" class=\"headerlink\" title=\"数字视频内容生成篡改方法\"></a>数字视频内容生成篡改方法</h4><p>视频内容生成方法是指在GAN网络及其衍生网络根据对抗原理，即生成器和判别器构成网络，从一幅噪声图像不断逼近真实图象的方法，其生成局部或全部图象和视频并不是真实的物理拍摄获得，从而达到以假乱真的目的。</p>\n<ul>\n<li>例如，Elor[15]等人的方案可以生成含有人物的视频，并且可以通过扭曲来轻微改变人物的头部姿势。因为这种方法是基于单个目标图像的，它从源视频中的嘴唇内部复制到目标视频，因此仅能部分保留目标视频中的人物身份。</li>\n<li>Kim[16]等人的做法相对于以前的方法而言，可以生成更为逼真的视频。</li>\n<li>Zhouhang[17]等人使用音频来生成视频。他们将一个无声的视频分解为两部分，一部分是人物身份信息，另一部分是语音信息，这里的语音信息是指通过人物嘴部动作传递出来的广义语音信息，而非听到的声音。</li>\n<li>Fried[18]等人基于文本来编辑视频。给定任意文本，该方法就能改变一段视频中人物所说的话，同时保持无缝的试听流。要对一段视频中人物讲话内容进行改变，只需要编辑一下想要表达的文本内容，这种方法十分地简单易行。</li>\n<li>Suwajanakorn[19]等人对人脸中的口型进行替换，生成最终的伪造视频。</li>\n</ul>\n<h4 id=\"数字视频重拍摄的篡改方法\"><a href=\"#数字视频重拍摄的篡改方法\" class=\"headerlink\" title=\"数字视频重拍摄的篡改方法\"></a>数字视频重拍摄的篡改方法</h4><p>数字视频重拍摄的篡改方法是指物理上用物理设备对数字视频内容播放进行重拍摄而造成内容时空含义混乱，达到篡改内容的目的，也就是“二次拍摄篡改编辑”。</p>\n<p>现有的重拍摄的编辑篡改方法主要根据拍摄设备、拍摄场景以及拍摄对象的差异进行分类[20]。Lee[20]等人提出目前重拍摄视频大部分产生于视频投放到液晶屏幕（LCD）上时被重拍摄，因此该作者重点研究LCD显示的视频重拍摄编辑篡改，提出一种梳状纹理的特征识别其重拍摄操作。P. Bestagini[21]等人提出了同步性不一致的重拍摄编辑篡改，作者利用这种不一致性产生的块重影现象对重拍摄视频进行检测。另外，Xavier [22]等人根据电影被投影时引起屏幕空间上的亮度重分配效应、垂直投影在屏幕上的图像的稳定性效应、高频闪烁的显示屏与摄像机快门之间的相互作用这三种效应设计不同的重拍摄编辑篡改场景。Mahdian[23]等人分析了不同品牌LCD显示屏的重拍摄视频在频谱波纹上的差别。除了针对LCD屏幕的重拍摄，重拍摄编辑篡改还包括以手持摄像机拍摄的视频。此类视频中的运动分为帧内运动和手持引起的全局运动，其中全局运动为手持重拍摄独有的效应。Marco [24]等人提出了具有的全局运动特征的手持拍摄视频编辑篡改。另外，图像重拍摄编辑篡改方面的几个经典场景同样也可以在视频重拍摄上适用。比如Thongkamwitoon[25]针对图像的类别差异构建重拍摄图像集合，通过挖掘彩色图像和黑白图像在色度上的差异引起的重拍摄图像在像素上的失真特性对图像进行重拍摄检验。Anjum等人[26]通过挖掘图像中高层次边缘细节特征，进而根据在原始图像和重拍摄图像中不同组别的边缘像素数量具有一定差异这一特性，构建具有不同边缘特性的重拍摄场景并进行分类。</p>\n<h3 id=\"数字视频被动取证检测技术\"><a href=\"#数字视频被动取证检测技术\" class=\"headerlink\" title=\"数字视频被动取证检测技术\"></a>数字视频被动取证检测技术</h3><p>上述数字视频编辑技术表明了：</p>\n<ol>\n<li>数字视频无论是编码复杂性，还是数据量的规模庞大，都给篡改编辑带来了更多的可利用空间和隐藏空间；</li>\n<li>篡改攻击的角度多样性，导致了针对篡改类型的通用识别算法实现具有较大难度。</li>\n</ol>\n<p>针对上述篡改编辑类型，对目前已经取得的被动检测成果进行介绍和分析。我们把数字视频篡改被动取证技术<strong>分为三类</strong>：</p>\n<ol>\n<li><strong>时空域</strong>特征检测技术。即无论是音频、图象、视频完全解码后，就会是一种结构化或半结构化的媒体原始文件，在原始文件上，可以构建各种物理、几何、光学等的传统数学特征模型，而这些数学模型通常是某种目标特征属性的固定模式、或者连续变化的某种特征数据表征。篡改编辑的过程中会破坏这种上述固定内在模式，引起连续性质的某些突变、或者出现某些特殊非典型痕迹残留分布等情况，而这些情况就可以通过针对时空特征建模方法来加以检测和识别。<strong>代表性算法有光流特征、运动场特征、亮度变化率特征、块效应强度特征等。</strong></li>\n<li><strong>编码域</strong>特征检测技术。即在数字媒体不完全解码的情况下，码流域、编码域的编码参数、编码域的预测模式、编码域分块模式等环境下，同样具有潜在的首次编码后的系数分布规律和特殊内在统计模式。而这种潜在的分布规律和模式，需要构建高维特征模型，如高阶概率统计模型、多模态融合特征模型等才能洞悉其规律。而且这种高维特征模型对人眼和人耳不可感知的细微编辑痕迹更为敏感。而且编码技术本身也会对数字媒体产生失真效果，因此，对完全解码后媒体数据可能带来意想不到的影响。但是在编码域对篡改痕迹直接展开分析的同时，已经充分考虑了编码失真的影响，在检测过程中可以更加精细化感知各种篡改编辑残留的痕迹。<strong>代表性算法有PU数量统计特征、预测残差分布特征、宏块类型变化特征、DCT系数分布特征</strong>。</li>\n<li><strong>深度</strong>特征检测技术。即无论数字媒体是什么容器格式或者什么编码，首先需要生成大量的篡改样本，把篡改样本进行初步的预处理之后，直接送到深度网络模型中加以学习叠代，直到获得预期稳定的输出，此时深度网络特征模型已经完成了参数训练，此后只需要给定输入就可给出分类结果。当然目前为止，这样简单粗暴的方法效果并不明显。学者们纷纷提出了多样化的<strong>深度网络模型、预处理方法、增加Attention机制、修剪网络无意义的层、增加强化学习的机制</strong>等等。通过深度网络自主学习的能力，学习到人类目前无法感知的特征，增强对篡改数据规律知识的学习，最终能否优于人类设计特征的效果。但是目前为止，大部分的深度网络模型对全局学习的效果不佳。<strong>代表性算法有卷积神经网络、双通道残差网络、遗传卷积网络、混合深度学习网络</strong>。</li>\n</ol>\n<h4 id=\"时空域特征检测技术\"><a href=\"#时空域特征检测技术\" class=\"headerlink\" title=\"时空域特征检测技术\"></a>时空域特征检测技术</h4><p>在数字视频的拍摄过程中，<strong>相邻帧或像素之间往往存在一定的关联</strong>，而对于视频的篡改往往会破坏这种关联性，因此视频篡改操作往往会在时空与留下痕迹。在现有工作中，时空域的检测算法能够直接对篡改痕迹像素或帧之间的异常特性进行建模，但算法复杂度往往较高。</p>\n<ul>\n<li>文献[27]中，巢娟等人提出了一种基于光流一致性的帧间篡改检测方法，针对帧插入和帧删除的细微差别，提出了两种不同的检测方案。实验表明，该方案在识别帧插入和帧删除模型方面取得了较好的效果。</li>\n<li>在文献[28]中，吴俞醒等人提出了一种基于速度场一致性的视频帧间伪造（连续帧删除和连续帧复制）检测算法。在文献[3]中，许强等人结合GOP结构非对齐的HEVC重编码引起的质量下降特性，通过分析HEVC编码标准中帧间编码对重建像素值的影响，提出基于帧间质量下降机制分析的检测算法，该算法对GOP结构非对齐的重编码检测问题能取得0.98以上的AUC值。</li>\n<li>而对于视频转码检测，在[29]中，许强构建了去块滤波模式决策特征以及SAO补偿特征来进行重编码的检测，算法分别在公开数据集上进行了验证，算法能取得97.21%的平均准确率。</li>\n<li>在文献[30]、[31]中，何沛松等人将待测视频解码为一连串连续的视频帧后，根据块效应强度变化规律的不同能够对视频双编码视频进行检测。</li>\n<li>在文献[32]中，杨高波等人提出了一种基于边缘强度的被动取证方法来检测候选视频中可能的视频帧速率上转换（FRUC）操作。平均检测准确率达94.5%。</li>\n<li>在文献[33]中，边山等人在在大量实验的基础上，发现目前大多数视频编辑软件中采用的帧速率上转换算法不可避免地会在生成的视频帧序列的帧间相似性中引入一些周期性的伪影。</li>\n</ul>\n<p>综上所述，时空域特征检测技术可以较全面的解决帧间和帧内篡改编辑的被动检测问题，<strong>但仍存在一下问题</strong>：</p>\n<ol>\n<li>视频包含快速运动的信息，或者包含场景切换，算法的性能将下降。这个问题是目前被动检测算法中普遍存在的鲁棒性问题，有待改善。</li>\n<li>在重编码比特率较低时检测性能会出现明显下降。这是因为视频重编码时比特率（画面质量）较低，会造成严重的信息失真，与篡改编辑痕迹耦合在一起，造成检测困难。这一问题应该系统研究比特率变化与篡改编辑痕迹变化之间的关系。</li>\n<li>时空特征检测技术基本上都是针对专用篡改编辑而设计的，因此通用性和泛化能力都十分有限。有的算法对复合篡改编辑的方式显得无能为力。这也是未来要解决的重要问题之一。</li>\n</ol>\n<h4 id=\"编码域特征检测技术\"><a href=\"#编码域特征检测技术\" class=\"headerlink\" title=\"编码域特征检测技术\"></a>编码域特征检测技术</h4><p>视频重编码操作是在首次编码的基础上再一次执行编码操作，基于编码域特征统计分析的视频重编码痕迹检测算法实际上就是根据重编码操作对视频编码后的参数扰动关系构建检测依据，依赖手工设计的特征来进行检测的算法。</p>\n<ul>\n<li>在文献[34]中，DAVID等人提出了基于The Variation of Prediction Footprint（VPF）的二次编码篡改检测算法。</li>\n<li>文献[35]中，该团队在MPEG-2标准上提出了一种基于广义VPF（G-VPF）的双编码检测算法，在首次编码使用QP（QP1）大于重编码使用QP（QP2）的情况下达到了98%以上的准确率。</li>\n<li>在文献[38]中，赵耀等人通过对预测模式特征（PMF）的分析，提出了一种用于假高清视频场景的重编码检测方案，该方法首先从四个方向的帧内预测模式中提取一个四维特征。其次，从三个预测模式中提取了6维特征。最后，将这两种特征集结合到PMF中，检测出伪造高清视频，并进一步估计其原始QPs和比特率。</li>\n<li>在文献[39]中，蒋兴浩等人提出了一种基于帧内预测模式的新方法。文献分析了帧内编码的质量退化机理，并充分考虑了帧内编码的误差来源，建立了等效误差模型，随后提出了基于帧内预测模式统计特征的双HEVC编码检测特征模型。最后，用720p和1080p的HEVC视频代替低分辨率（CIF或QCIF）视频进行了实验。实验结果表明，与现有方法相比，该方法具有更好的效率。此外，该方法对不同的编码配置具有较强的鲁棒性。</li>\n</ul>\n<p>综上所述，该类检测算法能有效的检测普通场景下的重编码操作，<strong>但存在一些不足</strong>：</p>\n<ol>\n<li>算法过度依赖解码器对参数的提取，并且容易受到反取证手段的攻击。</li>\n<li>当视频包含强运动成分信息或场景切换时，算法性能将下降。</li>\n<li>智能编码技术的兴起，给重编码检测带来了新的危机。</li>\n</ol>\n<h4 id=\"深度特征检测技术\"><a href=\"#深度特征检测技术\" class=\"headerlink\" title=\"深度特征检测技术\"></a>深度特征检测技术</h4><p>近年来，卷积神经网络（CNN）已经在多媒体取证领域取得成功应用。CNN 能够从训练样本中自动有效地学习层次化的特征表达。受此启发，一系列算法利用卷积神经网络来解决视频重编码痕迹检测问题。</p>\n<ul>\n<li>在文献[40]中，何沛松等人首先建立视频帧集合，以 3 帧为单位进行分块，若 3 帧中第二帧为重定位I帧，则该片段定义为正样本，否则为负样本。通过这种预处理操作，构建一个卷积神经网络，利用平均池化，作者能很好地检测出重定位I帧。</li>\n<li>类似的在[41]中许强等人通过构建 Genetic CNN，来进行AVC视频中重定位 I 帧的检测。不同于一般的卷积神经网络，<strong>Genetic CNN 能够结合遗传算法，实现自动设计网络架构的目的</strong>，通过算法对比，该算法的有效性得到验证。</li>\n<li>在[42]中，何沛松等人通过<strong>构建一个混合深度神经网络来揭露伪高清的HEVC重编码视频</strong>。通过提取基于块的残差信号，并构建一个双支路的网络进行检测，不同分支的输出向量将拼接后再联合优化得到逐块的检测结果。最后采用多数投票(local-to-global)策略得到最终的检测结果。</li>\n<li>除此之外，何沛松等人在[2]中<strong>提出了一种混合神经网络</strong>，通过从编码域中的编码信息中学习鲁棒时空表示，来揭示具有双重编码的HEVC视频中异常帧。</li>\n<li>在[43]中，Gan等人提出了一种<strong>基于VGG-11卷积神经网络的视频帧内伪造取证算法</strong>，该算法能自动检测视频伪造帧。该算法首先将视频解编码为一系列帧，计算出每帧的运动剩余映射，提取隐写特征。然后，以四个不同的隐写特征样本集作为训练集，并将测试集作为训练和测试模型。通过对比实验，选择了最佳性能特征。最后，通过伪造视频对伪造的帧进行了成功的标记。</li>\n</ul>\n<p>综上所述，深度神经网络的运用在一定程度上解决了传统算法的缺陷，虽然这些算法都能够取得较高的准确率，<strong>但其仍然存在一系列局限性</strong>：</p>\n<ol>\n<li>大多数基于深度神经网络的算法对样本数量要求较高，并且需要耗费大量的时间训练网络模型。</li>\n<li>这些算法都是以重定位I帧或者块为单位作为输入，如何设计高效的网络<strong>实现视频级别的重编码痕迹检测</strong>是今后研究的重要方向。</li>\n<li>深度神经网络在提升了人工检测效率和准确率，但其深度网络的可解释性和学习到特征的可解释性仍然是不透明的，很多时候“过学习”的现象或者“欠学习”的问题普遍存在。这一问题有待进一步改善。</li>\n</ol>\n<h3 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h3><ol>\n<li>篡改编辑（攻击）残留痕迹与数字媒体编码技术的依赖关系尚存在空白领域有待探索。数字媒体<strong>各类编码标准的不同特性内在机制和信息失真模型理论、特征模型建模的方法论、算法检测框架的性能等问题</strong>，还需要不断完善，逐步建立起完整的被动检测理论体系；</li>\n<li>人工智能理论、深度网络学习方法与对抗篡改攻击技术互为对抗和相互融合是未来的发展趋势。目前新型的<strong>VVC编码已经采用了众多的神经网络模块替代传统编码框架中画面提质模块、滤波模块、运动预测模块</strong>等，未来的人工智能技术与编码深度结合之下，如何检测篡改攻击痕迹是更加复杂和困难的挑战；</li>\n<li>该领域的专用算法尽管已经取得了丰硕的成果，但还存在着诸多边界条件的限制，离实际应用存在较大差距；<strong>新型篡改攻击方法不断涌现；新的深度学习模型削弱了篡改痕迹等问题；新的编码算法使得篡改痕迹被隐藏；概率性取证检测转化为确定性检测</strong>的方法等一系列问题。</li>\n<li>目前尽管已经出现了若干的公开视频篡改数据库，但是覆盖篡改类型还比较有限，数据库建设的标准也不统一，数据库的原始样本也存在容器、编码标准混乱的情况，对支撑整个领域研究还是远远不够的；</li>\n<li>在该领域的客观评价指标大多数<strong>仅限于传统的检测准确率、算法效率、定位准确率等指标，但这些指标无法满足对篡改检测算法性能进行全方位的评价</strong>，对未来算法应用落地是一个不容回避的问题，亟待更多的学者参与其中。</li>\n</ol>\n<h3 id=\"参考文献-2\"><a href=\"#参考文献-2\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>[1] Mi Z, Jiang X, Sun T, GAN-Generated Image Detection with Self-Attention Mechanism against GAN Generator Defect[J]. IEEE Journal of Selected Topics in Signal Processing, 2020, 14(5): 969-981.</p>\n<p>[2] Peisong He;Haoliang Li;Hongxia Wang;Shiqi Wang;Xinghao Jiang;Ruimei Zhang, Frame-wise Detection of Double HEVC Compression by Learning Deep Spatio-temporal Representations in Compression Domain[J]. IEEE Transactions on Multimedia, 2020, DOI: 10.1109/ TMM.2020.3021234.</p>\n<p>[3] Xu Q, Jiang X, Sun T, Detection of HEVC double compression with non-aligned GOP structures via inter-frame quality degradation analysis, Neurocomputing,2021, 452: 99-113.</p>\n<p>[4] Zhong hao Li, Meng, Laijin; Xu, Shutong; Li, Zhaohong; Shi, Yunqing; Liang, Yuanchang, A HEVC Video Steganalysis Algorithm Based on PU Partition Modes[J]. Computers, Materials &amp; Continua, 2019, 59(2):563-574.</p>\n<p>[5] Khoubani Sahar and Moradi Mohammad Hassan. A fast quaternion wavelet-based motion compensated frame rate up-conversion with fuzzy smoothing: application to echocardiography temporal enhancement[J]. Multimedia Tools and Applications, 2020, 80(6):8999-9025.</p>\n<p>[6] Kevin Spiteri and Rahul Urgaonkar and Ramesh K. Sitaraman. BOLA: Near-Optimal Bitrate Adaptation for Online Videos[J]. IEEE/ACM Transactions on Networking, 2020, PP(99):1-14.</p>\n<p>[7] Yin, Xiaoqi, Jindal, Abhishek, Sekar, Vyas,Sinopoli, Bruno, A Control-Theoretic Approach for Dynamic Adaptive Video Streaming over HTTP[J]. Computer communication review, 2015, 45(4):325-338.</p>\n<p>[8] Park W S, Kim M., CNN-based in-loop filtering for coding efficiency improvement[C]// 2016 IEEE 12th Image, Video, and Multidimensional Signal Processing Workshop (IVMSP). IEEE, 2016, DOI: 10.1109 /IVMSPW.2016.7528223.</p>\n<p>[9] Sun T, Jiang X, Chao J, A Novel Video Inter-frame Forgery Model Detection Scheme Based on Optical Flow Consistency[J]. International Workshop on Digital Watermarking, 2012. [10] Wang W, Jiang X, Wang S, et al. Identifying Video Forgery Process Using Optical Flow[M]//Digital-Forensics and Watermarking. Springer Berlin Heidelberg, 2014: 244-257.</p>\n<p>[11] Yin L, Bai Z, Yang R. Video forgery detection based on nonnegative tensor factorization[C]//Information Science and Technology (ICIST), 2014 4th IEEE International Conference on. IEEE, 2014: 148-151.</p>\n<p>[12] Quanxin Yang, Dongjin Yu, Zhuxi Zhang, Ye Yao, Linqiang Chen, Spatiotemporal Trident Networks: Detection and Localization of Object Removal Tampering in Video Passive Forensics[J]. IEEE Transactions on Circuits and Systems for Video Technology. 2020/12, DOI: 10.1109/TCSVT.2020.3046240.</p>\n<p>[13] Feng C, Xu Z, Zhang W, et al. Automatic location of frame deletion point for digital video forensics[C]//Proceedings of the 2nd ACM workshop on Information hiding and multimedia security. ACM, 2014: 171-179.</p>\n<p>[14] Feng C, Xu Z, Jia S, Zhang W, Xu Y, Motion-adaptive frame deletion detection for digital video forensics[J], IEEE Transactions on Circuits and Systems for Video Technology, 2016, 27(12):2543–2554.</p>\n<p>[15] Averbuch-Elor, Hadar, Cohen-Or, Daniel, Kopf, Johannes. Bringing portraits to life[J]. ACM Transactions on Graphics, 2017, 36(6) :1-13.</p>\n<p>[16] Kim Hyeongwoo, Theobalt Christian, Carrido Pablo. Deep video portraits[J]. ACM Transactions on Graphics, 2018, 37(4):1-14.</p>\n<p>[17] Zhou H, Liu Y, Liu Z, et al. Talking Face Generation by Adversarially Disentangled Audio-Visual Representation[J]. Proceedings of the AAAI Conference on Artificial Intelligence, 2019, 33:9299-9306.</p>\n<p>[18] Fried, O., Tewari, A., Zollh, Zollhöfer M et al. Text-Based Editing of Talking-Head Video[J]. ACM Trans. Graph. 38(4), 2019: 1-14.</p>\n<p>[19] Supasorn Suwajanakorn, Steven M. Seitz. Synthesizing Obama: learning lip sync from audio[M]. ACM, 2017.</p>\n<p>[20]Lee J W, Lee M J, Lee H Y, et al. Screenshot identification by analysis of directional inequality of interlaced video[J]. Eurasip Journal on Image &amp; Video Processing, 2012, (1):1-15.</p>\n<p>[21] Bestagini P, Visentini-Scarzanella M, Tagliasacchi M, et al. Video recapture detection based on ghosting artifact analysis[C]//Image Processing (ICIP), 2013 20th IEEE International Conference on. IEEE, 2013: 4457-4461.</p>\n<p>[22] Rolland-Neviere, X., Chupeau, B., Doerr, G., et al. (2012) Forensic Characterization of Camcorded Movies: Digital Cinema vs. Celluloid Film Prints[C]//Proceedings of SPIE—The International Society for Optical Engineering, Burlin-game, 9 February 2012, 83030R-83030R-11.</p>\n<p>[23] Mahdian B, Novozamsky A, Saic S. Identification of aliasing-based patterns in re-captured LCD screens[C]//Image Processing (ICIP), 2015 IEEE International Conference on. IEEE, 2015: 616-620.</p>\n<p>[24] Visentini-Scarzanella M, Dragotti P L. Video jitter analysis for automatic bootleg detection[C]//Multimedia Signal Processing (MMSP), 2012 IEEE 14th International Workshop on. IEEE, 2012: 101-106.</p>\n<p>[25] Thongkamwitoon T, Muammar H, Dragotti P L. An image recapture detection algorithm based on learning dictionaries of edge profiles[J]. Information Forensics and Security, IEEE Transactions on, 2015, 10(5): 953-968.</p>\n<p>[26] Anjum, A., Islam, S. Recapture detection technique based on edge-types by analysing high-frequency components in digital images acquired through LCD screens[J]. Multimed Tools Appl, 2020,79: 6965–6985.</p>\n<p>[27] Chao J, Jiang X, Sun T. A novel video inter-frame forgery model detection scheme based on optical flow consistency[C]//International Workshop on Digital Watermarking. Springer, Berlin, Heidelberg, 2012: 267-281.</p>\n<p>[28] Wu Y, Jiang X, Sun T, et al. Exposing video inter-frame forgery based on velocity field consistency[C]//2014 IEEE international conference on acoustics, speech and signal processing (ICASSP). IEEE, 2014: 2674-2678.</p>\n<p>[29] Qiang XU, Xinghao Jiang, Tanfeng Sun*, Alex C. Kot, Detection of transcoded HEVC videos based on in-loop filtering and PU partitioning analyses[J], Signal Processing: Image Communication, 2021, 92:116109.</p>\n<p>[30] He P, Sun T, Jiang X, et al. Double compression detection in MPEG-4 videos based on block artifact measurement with variation of prediction footprint[C]// International Conference on Intelligent Computing. Springer. 2015: 787–793.</p>\n<p>[31] He P, Jiang X, Sun T, et al. Detection of double compression in MPEG-4 videos based on block artifact measurement[J]. Neurocomputing, 2017, 228: 84–96.</p>\n<p>[32] Yao Y, Yang G, Sun X, et al. Detecting video frame-rate up-conversion based on periodic properties of edge-intensity[J]. Journal of Information Security and Applications, 2016, 26: 39–50.</p>\n<p>[33] Bian S, Luo W, Huang J. Detecting video frame-rate up-conversion based on periodic properties of inter-frame similarity[J]. Multimedia tools and applications, 2014, 72(1): 437–451.</p>\n<p>[34] Vazquezpadin D, Fontani M, Bianchi T, et al. Detection of video double encoding with GOP size estimation[C]// IEEE International Workshop on Information Forensics and Security (WIFS), 2012:151-156.</p>\n<p>[35] Vazquez-Padin D, Fontani M, Shullani D, et al. Video Integrity Verification and GOP Size Estimation Via Generalized Variation of Prediction Footprint[J]. IEEE transactions on information forensics and security, 2020, (15):1815-1830.</p>\n<p>[36] Li, Q., Wang, R. and Xu, D., Detection of double compression in HEVC videos based on TU size and quantized DCT coefficients[J]. IET Inf. Secur., 2019, (13): 1-6.</p>\n<p>[37] Yao H., Ni R., Zhao Y., Double compression detection for H.264 videos with adaptive GOP structure. Multimedia Tools and Applications, 2020, (79):5789-5806.</p>\n<p>[38] Yu Y , Yao H , Ni R , et al. Detection of fake high definition for HEVC videos based on prediction mode feature[J]. Signal processing, 2020, 166(Jan.):107269.1-107269.11.</p>\n<p>[39] X.H, Jiang, Q. Xu, T.F. Sun, Bin Li, Peisong He, Detection of HEVC double compression with the same coding parameters based on analysis of intra coding quality degradation process[J]. IEEE Transactions on Information Forensics and Security, 2019, (15): 250-263.</p>\n<p>[40] He P, Jiang X, Sun T, et al. Frame-wise detection of relocated I-frames in double compressed H.264 videos based on convolutional neural network[J]. Journal of Visual Communication and Image Representation, 2017, (48): 149-158.</p>\n<p>[41 Xu Q, Jiang X, Sun T, et al. Relocated I-Frames Detection in H. 264 Double Compressed Videos Based on Genetic-CNN[C]. in: 2018 Asia-Pacifc Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC). 2018: 710-716.</p>\n<p>[42] He P, Li H, Li B, et al. Exposing Fake Bitrate Videos Using Hybrid Deep-learning Network from Recompression Error[J]. IEEE Transactions on Circuits and Systems for Video Technology, 2019, (99):1-13.</p>\n<p>[43] Gan Y, Yang J, Lai W. Video object forgery detection algorithm based on VGG-11 convolutional neural network[C]//2019 International Conference on Intelligent Computing, Automation and Systems (ICICAS). IEEE, 2019: 575-580.</p>\n<blockquote>\n<p>本文转自公众号【隐者联盟】<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485053&idx=1&sn=b658496c5826472b5cea4183ede69759\">【极简综述17】数字图像处理操作取证</a>、<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485053&idx=2&sn=afbec76ac6f61518c50b6a040eb33fac\">【极简综述18】数字图像篡改操作取证</a>、<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg4MjU4OTU0MA==&mid=2247485207&idx=1&sn=c2be18dc1badc7c8731a91c0f926d55b\">【极简综述19】数字视频再编辑篡改及被动取证检测技术综述</a></p>\n</blockquote>"},{"title":"用BusyBox制作最小根文件系统","article_type":0,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"top":null,"_content":"\n\n\n<!-- more -->","source":"_drafts/模板.md","raw":"---\ntitle: 用BusyBox制作最小根文件系统\ntag:\n  - linux\ncategories:\n  - linux\narticle_type: 0\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\ntop:\n\n---\n\n\n\n<!-- more -->","slug":"模板","published":0,"date":"2022-11-24T13:36:19.847Z","updated":"2021-12-30T11:09:53.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4o000r64rg2fed3azg","content":"<span id=\"more\"></span>","site":{"data":{}},"excerpt":"","more":""},{"title":"三水的笔记 Find Notes 上线","article_type":0,"abbrlink":"2e289bf9","date":"2022-11-28T16:00:00.000Z","top":2,"_content":"\n<img src=\"https://qiniu.findn.cn//blog/photos/article/findnotes.png\" alt=\"findnotes\" style=\"zoom:80%;\" />\n\n为了方便个人知识管理，我又建了新的笔记网站——[Find Notes - 三水的笔记](https://findn.cn/)，网站主要更新一些学习过程中的笔记：\n\n- 算法刷题（Leetcode、代码随想录、剑指Offer）\n- 前端学习笔记（HTML、CSS、JavaScript、Vue）\n- 计算机基础知识（Linux、操作系统、计算机网络、设计模式）\n- 个人项目\n\n目前的博客[三水のBlog](https://sanshui.findn.cn/)后面主要记录一些个人随笔、生活趣事等。\n\n<!-- more -->\n\n# 关于博客\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/findnotes-min.svg\" alt=\"findnotes-logo\" style=\"width: 200px;\" />\n\n`Find Notes`域名为[https://findn.cn/](https://findn.cn/)，Repo在[这里](https://github.com/jackhanyuan/Find-CS-Notes)，网站名称主要是根据域名Findn联想到的，logo左边F是Find的缩写，右边的笔代表着笔记，希望每个人都可以在三水的笔记里找到学习CS的乐趣！\n\n博客使用[VuePress V2](https://github.com/vuepress/vuepress-next)建站，使用的主题是[vuepress-theme-hope](https://github.com/vuepress-theme-hope/vuepress-theme-hope)，支持[PWA](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps)，缓存安装后可离线使用。安装的方法因浏览器不同而不同，如 PC 版本 Chrome 或 Edge 浏览器直接点击地址栏右侧的`安装Find Notes`即可，在 iOS Safari 中，点击下方`共享`按钮，再点击`添加至主屏幕`；Android Chrome/Firefox 中，点击右上角`菜单`按钮，再点击`添加至主屏幕`或`安装`。","source":"_posts/07 三水的笔记 Find Notes 上线.md","raw":"---\ntitle: 三水的笔记 Find Notes 上线\ntag:\n  - 三水\ncategories:\n  - - 博客Blog\n    - 三水的笔记\narticle_type: 0\nabbrlink: 2e289bf9\ndate: 2022-11-29\ntop: 2\n---\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/findnotes.png\" alt=\"findnotes\" style=\"zoom:80%;\" />\n\n为了方便个人知识管理，我又建了新的笔记网站——[Find Notes - 三水的笔记](https://findn.cn/)，网站主要更新一些学习过程中的笔记：\n\n- 算法刷题（Leetcode、代码随想录、剑指Offer）\n- 前端学习笔记（HTML、CSS、JavaScript、Vue）\n- 计算机基础知识（Linux、操作系统、计算机网络、设计模式）\n- 个人项目\n\n目前的博客[三水のBlog](https://sanshui.findn.cn/)后面主要记录一些个人随笔、生活趣事等。\n\n<!-- more -->\n\n# 关于博客\n\n<img src=\"https://qiniu.findn.cn//blog/photos/article/findnotes-min.svg\" alt=\"findnotes-logo\" style=\"width: 200px;\" />\n\n`Find Notes`域名为[https://findn.cn/](https://findn.cn/)，Repo在[这里](https://github.com/jackhanyuan/Find-CS-Notes)，网站名称主要是根据域名Findn联想到的，logo左边F是Find的缩写，右边的笔代表着笔记，希望每个人都可以在三水的笔记里找到学习CS的乐趣！\n\n博客使用[VuePress V2](https://github.com/vuepress/vuepress-next)建站，使用的主题是[vuepress-theme-hope](https://github.com/vuepress-theme-hope/vuepress-theme-hope)，支持[PWA](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps)，缓存安装后可离线使用。安装的方法因浏览器不同而不同，如 PC 版本 Chrome 或 Edge 浏览器直接点击地址栏右侧的`安装Find Notes`即可，在 iOS Safari 中，点击下方`共享`按钮，再点击`添加至主屏幕`；Android Chrome/Firefox 中，点击右上角`菜单`按钮，再点击`添加至主屏幕`或`安装`。","slug":"07 三水的笔记 Find Notes 上线","published":1,"updated":"2022-11-29T09:43:21.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4q000w64rgg5smdvxd","content":"<img src=\"https://qiniu.findn.cn//blog/photos/article/findnotes.png\" alt=\"findnotes\" style=\"zoom:80%;\" />\n\n<p>为了方便个人知识管理，我又建了新的笔记网站——<a href=\"https://findn.cn/\">Find Notes - 三水的笔记</a>，网站主要更新一些学习过程中的笔记：</p>\n<ul>\n<li>算法刷题（Leetcode、代码随想录、剑指Offer）</li>\n<li>前端学习笔记（HTML、CSS、JavaScript、Vue）</li>\n<li>计算机基础知识（Linux、操作系统、计算机网络、设计模式）</li>\n<li>个人项目</li>\n</ul>\n<p>目前的博客<a href=\"https://sanshui.findn.cn/\">三水のBlog</a>后面主要记录一些个人随笔、生活趣事等。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"关于博客\"><a href=\"#关于博客\" class=\"headerlink\" title=\"关于博客\"></a>关于博客</h1><img src=\"https://qiniu.findn.cn//blog/photos/article/findnotes-min.svg\" alt=\"findnotes-logo\" style=\"width: 200px;\" />\n\n<p><code>Find Notes</code>域名为<a href=\"https://findn.cn/\">https://findn.cn/</a>，Repo在<a href=\"https://github.com/jackhanyuan/Find-CS-Notes\">这里</a>，网站名称主要是根据域名Findn联想到的，logo左边F是Find的缩写，右边的笔代表着笔记，希望每个人都可以在三水的笔记里找到学习CS的乐趣！</p>\n<p>博客使用<a href=\"https://github.com/vuepress/vuepress-next\">VuePress V2</a>建站，使用的主题是<a href=\"https://github.com/vuepress-theme-hope/vuepress-theme-hope\">vuepress-theme-hope</a>，支持<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps\">PWA</a>，缓存安装后可离线使用。安装的方法因浏览器不同而不同，如 PC 版本 Chrome 或 Edge 浏览器直接点击地址栏右侧的<code>安装Find Notes</code>即可，在 iOS Safari 中，点击下方<code>共享</code>按钮，再点击<code>添加至主屏幕</code>；Android Chrome/Firefox 中，点击右上角<code>菜单</code>按钮，再点击<code>添加至主屏幕</code>或<code>安装</code>。</p>\n","site":{"data":{}},"excerpt":"<img src=\"https://qiniu.findn.cn//blog/photos/article/findnotes.png\" alt=\"findnotes\" style=\"zoom:80%;\" />\n\n<p>为了方便个人知识管理，我又建了新的笔记网站——<a href=\"https://findn.cn/\">Find Notes - 三水的笔记</a>，网站主要更新一些学习过程中的笔记：</p>\n<ul>\n<li>算法刷题（Leetcode、代码随想录、剑指Offer）</li>\n<li>前端学习笔记（HTML、CSS、JavaScript、Vue）</li>\n<li>计算机基础知识（Linux、操作系统、计算机网络、设计模式）</li>\n<li>个人项目</li>\n</ul>\n<p>目前的博客<a href=\"https://sanshui.findn.cn/\">三水のBlog</a>后面主要记录一些个人随笔、生活趣事等。</p>","more":"<h1 id=\"关于博客\"><a href=\"#关于博客\" class=\"headerlink\" title=\"关于博客\"></a>关于博客</h1><img src=\"https://qiniu.findn.cn//blog/photos/article/findnotes-min.svg\" alt=\"findnotes-logo\" style=\"width: 200px;\" />\n\n<p><code>Find Notes</code>域名为<a href=\"https://findn.cn/\">https://findn.cn/</a>，Repo在<a href=\"https://github.com/jackhanyuan/Find-CS-Notes\">这里</a>，网站名称主要是根据域名Findn联想到的，logo左边F是Find的缩写，右边的笔代表着笔记，希望每个人都可以在三水的笔记里找到学习CS的乐趣！</p>\n<p>博客使用<a href=\"https://github.com/vuepress/vuepress-next\">VuePress V2</a>建站，使用的主题是<a href=\"https://github.com/vuepress-theme-hope/vuepress-theme-hope\">vuepress-theme-hope</a>，支持<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps\">PWA</a>，缓存安装后可离线使用。安装的方法因浏览器不同而不同，如 PC 版本 Chrome 或 Edge 浏览器直接点击地址栏右侧的<code>安装Find Notes</code>即可，在 iOS Safari 中，点击下方<code>共享</code>按钮，再点击<code>添加至主屏幕</code>；Android Chrome/Firefox 中，点击右上角<code>菜单</code>按钮，再点击<code>添加至主屏幕</code>或<code>安装</code>。</p>"},{"title":"LeetCode刷题 Day1 数组 | 704. 二分查找 27. 移除元素","article_type":0,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"mathjax":false,"abbrlink":"d446fd47","date":"2022-11-15T16:00:00.000Z","top":null,"_content":"\n- LeetCode 704. 二分查找\n- LeetCode 27. 移除元素\n\n<!-- more -->\n\n## 704. 二分查找\n\n> [力扣题目链接](https://leetcode.cn/problems/binary-search/)\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例 1：\n```\n输入：nums = [-1,0,3,5,9,12], target = 9\n输出：4\n解释：9 出现在 nums 中并且下标为 4\n```\n\n示例 2：\n```\n输入：nums = [-1,0,3,5,9,12], target = 2\n输出：-1\n解释：2 不存在 nums 中因此返回 -1\n```\n\n### 思路\n\n> 使用二分法前提条件：\n- 数组为有序数组\n- 数组中无重复元素\n\n> 边界问题\n\n首先确定查找的时候是否包括数组左右两边的数字，通常分为以下2种：\n\n- 左闭右闭\n  - 查找范围在`[left, right]`区间，初值 `left, right=0, len(nums) - 1`。\n  - `while (left <= right)` 要使用 `<=` ，因为左闭右闭时，`left == right`是有意义的。\n  - `if (nums[mid] > target)` `right == mid - 1`，因为中间值大于target，那么接下来要查找的范围应该包含中间值左边的那个值，而right赋值为 mid - 1 时，查找范围刚好是[left, mid - 1]。\n\n- 左闭右开\n  - 查找范围在`[left, right)`区间，初值 `left, right=0, len(nums)`。\n  - `while (left < right)` 要使用 `<` ，因为左闭右开时，`left == right`没有意义。\n  - `if (nums[mid] > target)` `right == mid`，因为中间值大于target，那么接下来要查找的范围应该包含中间值左边的那个值，而 right 赋值为 mid 时，查找范围刚好是[left, mid - 1]。\n\n> 值溢出问题\n\n- `mid = left + ((right - left) >> 1)` 与 `mid = (left + right) // 2` 计算结果一致，但当 left 和 right 很大的时候，前者可以防止溢出问题（python中整数对象是变长对象，所以不存在溢出问题），此外位运算速度比除法快。\n\n### python代码\n\n左闭右闭\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left +((right - left) >> 1)\n            print(left, right, mid)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1 \n```\n\n左闭右开\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = left +((right - left) >> 1)\n            print(left, right, mid)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid\n            else:\n                left = mid + 1\n        return -1 \n```\n\n\n## 27. 移除元素\n\n> [力扣题目链接](https://leetcode.cn/problems/remove-element/)\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1：\n```\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n```\n\n示例 2：\n```\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n```\n\n### 思路\n\n- 数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，要删除某个元素，后面的只能向前覆盖。\n- 暴力法\n  - 双层循环\n    - 注意：Python 中 `for i in range(length)`中，i每次从迭代器中取数，循环体中改变i的值并不能改变下一次for循环中取到的i值，可以参考[这里](https://blog.csdn.net/zhimou/article/details/105537102)。\n- 双指针（快慢指针法）\n  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组。\n  - 慢指针：删除了目标值的新数组的下标，慢指针只有在快指针的值不为target的值时才移动。\n\n### python代码\n\n暴力解法 - python调库\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        for num in nums[::-1]:  # nums[::-1]相当于生成一个新的迭代器，循环体内remove不影响这里num取数\n            print(num)\n            if num == val:\n                nums.remove(num) # 删除操作复杂度O(n)\n                print(nums)\n        \n        return len(nums)\n```\n\n暴力解法 - 双循环\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        length = len(nums)  # length记录新数组的长度\n        i = 0\n        while i < length:  # 这里不能用for循环，因为for i in range(length)中，i每次从迭代器中取数，循环体中改变i的值并不能改变下一次for循环中取到的i值\n            if nums[i] == val: # 判断是否等于val，相等进入第二重循环，不相等变量i加1继续执行第一重循环\n                for j in range(i+1, length):\n                    nums[j-1] = nums[j] # 从i之后依次向前移一位\n                length -= 1  # 逻辑上删除了一个值，数组大小减1\n            else:\n                i += 1\n        \n        return length\n```\n\n双指针法（快慢指针）\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        slow, fast = 0, 0\n        length = len(nums)\n        while fast < length:\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n            fast += 1\n        return slow\n```\n","source":"_posts/05 LeetCode刷题 Day1 数组 704. 二分查找 27. 移除元素.md","raw":"---\ntitle: LeetCode刷题 Day1 数组 | 704. 二分查找 27. 移除元素\ntag:\n  - LeetCode\ncategories:\n  - [算法刷题, 代码随想录]\narticle_type: 0\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\nmathjax: false\nabbrlink: d446fd47\ndate: 2022-11-16\ntop:\n---\n\n- LeetCode 704. 二分查找\n- LeetCode 27. 移除元素\n\n<!-- more -->\n\n## 704. 二分查找\n\n> [力扣题目链接](https://leetcode.cn/problems/binary-search/)\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例 1：\n```\n输入：nums = [-1,0,3,5,9,12], target = 9\n输出：4\n解释：9 出现在 nums 中并且下标为 4\n```\n\n示例 2：\n```\n输入：nums = [-1,0,3,5,9,12], target = 2\n输出：-1\n解释：2 不存在 nums 中因此返回 -1\n```\n\n### 思路\n\n> 使用二分法前提条件：\n- 数组为有序数组\n- 数组中无重复元素\n\n> 边界问题\n\n首先确定查找的时候是否包括数组左右两边的数字，通常分为以下2种：\n\n- 左闭右闭\n  - 查找范围在`[left, right]`区间，初值 `left, right=0, len(nums) - 1`。\n  - `while (left <= right)` 要使用 `<=` ，因为左闭右闭时，`left == right`是有意义的。\n  - `if (nums[mid] > target)` `right == mid - 1`，因为中间值大于target，那么接下来要查找的范围应该包含中间值左边的那个值，而right赋值为 mid - 1 时，查找范围刚好是[left, mid - 1]。\n\n- 左闭右开\n  - 查找范围在`[left, right)`区间，初值 `left, right=0, len(nums)`。\n  - `while (left < right)` 要使用 `<` ，因为左闭右开时，`left == right`没有意义。\n  - `if (nums[mid] > target)` `right == mid`，因为中间值大于target，那么接下来要查找的范围应该包含中间值左边的那个值，而 right 赋值为 mid 时，查找范围刚好是[left, mid - 1]。\n\n> 值溢出问题\n\n- `mid = left + ((right - left) >> 1)` 与 `mid = (left + right) // 2` 计算结果一致，但当 left 和 right 很大的时候，前者可以防止溢出问题（python中整数对象是变长对象，所以不存在溢出问题），此外位运算速度比除法快。\n\n### python代码\n\n左闭右闭\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left +((right - left) >> 1)\n            print(left, right, mid)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1 \n```\n\n左闭右开\n```python\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = left +((right - left) >> 1)\n            print(left, right, mid)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid\n            else:\n                left = mid + 1\n        return -1 \n```\n\n\n## 27. 移除元素\n\n> [力扣题目链接](https://leetcode.cn/problems/remove-element/)\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1：\n```\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n```\n\n示例 2：\n```\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n```\n\n### 思路\n\n- 数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，要删除某个元素，后面的只能向前覆盖。\n- 暴力法\n  - 双层循环\n    - 注意：Python 中 `for i in range(length)`中，i每次从迭代器中取数，循环体中改变i的值并不能改变下一次for循环中取到的i值，可以参考[这里](https://blog.csdn.net/zhimou/article/details/105537102)。\n- 双指针（快慢指针法）\n  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组。\n  - 慢指针：删除了目标值的新数组的下标，慢指针只有在快指针的值不为target的值时才移动。\n\n### python代码\n\n暴力解法 - python调库\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        for num in nums[::-1]:  # nums[::-1]相当于生成一个新的迭代器，循环体内remove不影响这里num取数\n            print(num)\n            if num == val:\n                nums.remove(num) # 删除操作复杂度O(n)\n                print(nums)\n        \n        return len(nums)\n```\n\n暴力解法 - 双循环\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        length = len(nums)  # length记录新数组的长度\n        i = 0\n        while i < length:  # 这里不能用for循环，因为for i in range(length)中，i每次从迭代器中取数，循环体中改变i的值并不能改变下一次for循环中取到的i值\n            if nums[i] == val: # 判断是否等于val，相等进入第二重循环，不相等变量i加1继续执行第一重循环\n                for j in range(i+1, length):\n                    nums[j-1] = nums[j] # 从i之后依次向前移一位\n                length -= 1  # 逻辑上删除了一个值，数组大小减1\n            else:\n                i += 1\n        \n        return length\n```\n\n双指针法（快慢指针）\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        slow, fast = 0, 0\n        length = len(nums)\n        while fast < length:\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n            fast += 1\n        return slow\n```\n","slug":"05 LeetCode刷题 Day1 数组 704. 二分查找 27. 移除元素","published":1,"updated":"2022-11-26T20:36:56.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4s000z64rgd8q4dycz","content":"<ul>\n<li>LeetCode 704. 二分查找</li>\n<li>LeetCode 27. 移除元素</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a>704. 二分查找</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/binary-search/\">力扣题目链接</a></p>\n</blockquote>\n<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-1,0,3,5,9,12], target = 9</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-1,0,3,5,9,12], target = 2</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><blockquote>\n<p>使用二分法前提条件：</p>\n</blockquote>\n<ul>\n<li>数组为有序数组</li>\n<li>数组中无重复元素</li>\n</ul>\n<blockquote>\n<p>边界问题</p>\n</blockquote>\n<p>首先确定查找的时候是否包括数组左右两边的数字，通常分为以下2种：</p>\n<ul>\n<li><p>左闭右闭</p>\n<ul>\n<li>查找范围在<code>[left, right]</code>区间，初值 <code>left, right=0, len(nums) - 1</code>。</li>\n<li><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为左闭右闭时，<code>left == right</code>是有意义的。</li>\n<li><code>if (nums[mid] &gt; target)</code> <code>right == mid - 1</code>，因为中间值大于target，那么接下来要查找的范围应该包含中间值左边的那个值，而right赋值为 mid - 1 时，查找范围刚好是[left, mid - 1]。</li>\n</ul>\n</li>\n<li><p>左闭右开</p>\n<ul>\n<li>查找范围在<code>[left, right)</code>区间，初值 <code>left, right=0, len(nums)</code>。</li>\n<li><code>while (left &lt; right)</code> 要使用 <code>&lt;</code> ，因为左闭右开时，<code>left == right</code>没有意义。</li>\n<li><code>if (nums[mid] &gt; target)</code> <code>right == mid</code>，因为中间值大于target，那么接下来要查找的范围应该包含中间值左边的那个值，而 right 赋值为 mid 时，查找范围刚好是[left, mid - 1]。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>值溢出问题</p>\n</blockquote>\n<ul>\n<li><code>mid = left + ((right - left) &gt;&gt; 1)</code> 与 <code>mid = (left + right) // 2</code> 计算结果一致，但当 left 和 right 很大的时候，前者可以防止溢出问题（python中整数对象是变长对象，所以不存在溢出问题），此外位运算速度比除法快。</li>\n</ul>\n<h3 id=\"python代码\"><a href=\"#python代码\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><p>左闭右闭</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">search</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], target: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            mid = left +((right - left) &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(left, right, mid)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[mid] == target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums[mid] &gt; target:</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span> </span><br></pre></td></tr></table></figure>\n\n<p>左闭右开</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">search</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], target: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            mid = left +((right - left) &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(left, right, mid)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[mid] == target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums[mid] &gt; target:</span><br><span class=\"line\">                right = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span> </span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/remove-element/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,2,3], val = 3</span><br><span class=\"line\">输出：2, nums = [2,2]</span><br><span class=\"line\">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class=\"line\">输出：5, nums = [0,1,4,0,3]</span><br><span class=\"line\">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，要删除某个元素，后面的只能向前覆盖。</li>\n<li>暴力法<ul>\n<li>双层循环<ul>\n<li>注意：Python 中 <code>for i in range(length)</code>中，i每次从迭代器中取数，循环体中改变i的值并不能改变下一次for循环中取到的i值，可以参考<a href=\"https://blog.csdn.net/zhimou/article/details/105537102\">这里</a>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双指针（快慢指针法）<ul>\n<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组。</li>\n<li>慢指针：删除了目标值的新数组的下标，慢指针只有在快指针的值不为target的值时才移动。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"python代码-1\"><a href=\"#python代码-1\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><p>暴力解法 - python调库</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums[::-<span class=\"number\">1</span>]:  <span class=\"comment\"># nums[::-1]相当于生成一个新的迭代器，循环体内remove不影响这里num取数</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(num)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == val:</span><br><span class=\"line\">                nums.remove(num) <span class=\"comment\"># 删除操作复杂度O(n)</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(nums)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(nums)</span><br></pre></td></tr></table></figure>\n\n<p>暴力解法 - 双循环</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        length = <span class=\"built_in\">len</span>(nums)  <span class=\"comment\"># length记录新数组的长度</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; length:  <span class=\"comment\"># 这里不能用for循环，因为for i in range(length)中，i每次从迭代器中取数，循环体中改变i的值并不能改变下一次for循环中取到的i值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == val: <span class=\"comment\"># 判断是否等于val，相等进入第二重循环，不相等变量i加1继续执行第一重循环</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i+<span class=\"number\">1</span>, length):</span><br><span class=\"line\">                    nums[j-<span class=\"number\">1</span>] = nums[j] <span class=\"comment\"># 从i之后依次向前移一位</span></span><br><span class=\"line\">                length -= <span class=\"number\">1</span>  <span class=\"comment\"># 逻辑上删除了一个值，数组大小减1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> length</span><br></pre></td></tr></table></figure>\n\n<p>双指针法（快慢指针）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        slow, fast = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        length = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast &lt; length:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[fast] != val:</span><br><span class=\"line\">                nums[slow] = nums[fast]</span><br><span class=\"line\">                slow += <span class=\"number\">1</span></span><br><span class=\"line\">            fast += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<ul>\n<li>LeetCode 704. 二分查找</li>\n<li>LeetCode 27. 移除元素</li>\n</ul>","more":"<h2 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a>704. 二分查找</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/binary-search/\">力扣题目链接</a></p>\n</blockquote>\n<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-1,0,3,5,9,12], target = 9</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-1,0,3,5,9,12], target = 2</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><blockquote>\n<p>使用二分法前提条件：</p>\n</blockquote>\n<ul>\n<li>数组为有序数组</li>\n<li>数组中无重复元素</li>\n</ul>\n<blockquote>\n<p>边界问题</p>\n</blockquote>\n<p>首先确定查找的时候是否包括数组左右两边的数字，通常分为以下2种：</p>\n<ul>\n<li><p>左闭右闭</p>\n<ul>\n<li>查找范围在<code>[left, right]</code>区间，初值 <code>left, right=0, len(nums) - 1</code>。</li>\n<li><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为左闭右闭时，<code>left == right</code>是有意义的。</li>\n<li><code>if (nums[mid] &gt; target)</code> <code>right == mid - 1</code>，因为中间值大于target，那么接下来要查找的范围应该包含中间值左边的那个值，而right赋值为 mid - 1 时，查找范围刚好是[left, mid - 1]。</li>\n</ul>\n</li>\n<li><p>左闭右开</p>\n<ul>\n<li>查找范围在<code>[left, right)</code>区间，初值 <code>left, right=0, len(nums)</code>。</li>\n<li><code>while (left &lt; right)</code> 要使用 <code>&lt;</code> ，因为左闭右开时，<code>left == right</code>没有意义。</li>\n<li><code>if (nums[mid] &gt; target)</code> <code>right == mid</code>，因为中间值大于target，那么接下来要查找的范围应该包含中间值左边的那个值，而 right 赋值为 mid 时，查找范围刚好是[left, mid - 1]。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>值溢出问题</p>\n</blockquote>\n<ul>\n<li><code>mid = left + ((right - left) &gt;&gt; 1)</code> 与 <code>mid = (left + right) // 2</code> 计算结果一致，但当 left 和 right 很大的时候，前者可以防止溢出问题（python中整数对象是变长对象，所以不存在溢出问题），此外位运算速度比除法快。</li>\n</ul>\n<h3 id=\"python代码\"><a href=\"#python代码\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><p>左闭右闭</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">search</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], target: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt;= right:</span><br><span class=\"line\">            mid = left +((right - left) &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(left, right, mid)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[mid] == target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums[mid] &gt; target:</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span> </span><br></pre></td></tr></table></figure>\n\n<p>左闭右开</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">search</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], target: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        left, right = <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            mid = left +((right - left) &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(left, right, mid)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[mid] == target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> nums[mid] &gt; target:</span><br><span class=\"line\">                right = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span> </span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/remove-element/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,2,3], val = 3</span><br><span class=\"line\">输出：2, nums = [2,2]</span><br><span class=\"line\">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class=\"line\">输出：5, nums = [0,1,4,0,3]</span><br><span class=\"line\">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，要删除某个元素，后面的只能向前覆盖。</li>\n<li>暴力法<ul>\n<li>双层循环<ul>\n<li>注意：Python 中 <code>for i in range(length)</code>中，i每次从迭代器中取数，循环体中改变i的值并不能改变下一次for循环中取到的i值，可以参考<a href=\"https://blog.csdn.net/zhimou/article/details/105537102\">这里</a>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双指针（快慢指针法）<ul>\n<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组。</li>\n<li>慢指针：删除了目标值的新数组的下标，慢指针只有在快指针的值不为target的值时才移动。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"python代码-1\"><a href=\"#python代码-1\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><p>暴力解法 - python调库</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums[::-<span class=\"number\">1</span>]:  <span class=\"comment\"># nums[::-1]相当于生成一个新的迭代器，循环体内remove不影响这里num取数</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(num)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num == val:</span><br><span class=\"line\">                nums.remove(num) <span class=\"comment\"># 删除操作复杂度O(n)</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(nums)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(nums)</span><br></pre></td></tr></table></figure>\n\n<p>暴力解法 - 双循环</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        length = <span class=\"built_in\">len</span>(nums)  <span class=\"comment\"># length记录新数组的长度</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; length:  <span class=\"comment\"># 这里不能用for循环，因为for i in range(length)中，i每次从迭代器中取数，循环体中改变i的值并不能改变下一次for循环中取到的i值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == val: <span class=\"comment\"># 判断是否等于val，相等进入第二重循环，不相等变量i加1继续执行第一重循环</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i+<span class=\"number\">1</span>, length):</span><br><span class=\"line\">                    nums[j-<span class=\"number\">1</span>] = nums[j] <span class=\"comment\"># 从i之后依次向前移一位</span></span><br><span class=\"line\">                length -= <span class=\"number\">1</span>  <span class=\"comment\"># 逻辑上删除了一个值，数组大小减1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> length</span><br></pre></td></tr></table></figure>\n\n<p>双指针法（快慢指针）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">removeElement</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], val: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        slow, fast = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        length = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast &lt; length:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[fast] != val:</span><br><span class=\"line\">                nums[slow] = nums[fast]</span><br><span class=\"line\">                slow += <span class=\"number\">1</span></span><br><span class=\"line\">            fast += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode刷题 Day2 数组 | 977.有序数组的平方 209.长度最小的子数组 59.螺旋矩阵II","article_type":0,"no_word_count":false,"no_toc":false,"no_date":false,"no_declare":false,"no_reward":false,"no_comments":false,"no_share":false,"no_footer":false,"mathjax":false,"abbrlink":"931914af","date":"2022-11-18T16:00:00.000Z","top":null,"_content":"\n- LeetCode 977.有序数组的平方\n- LeetCode 209.长度最小的子数组\n- LeetCode 59.螺旋矩阵II\n\n<!-- more -->\n\n## 977.有序数组的平方\n\n> [力扣题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n示例 1：\n```\n输入：nums = [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n```\n\n示例 2：\n```\n输入：nums = [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n```\n\n### 思路\n\n由于数组有序，负数平方之后可能成为最大数，所以平方后的最大值一定在数组的两端。\n\n> 方法一：从中间向两边：找到正负分界点，然后分别向左向右遍历比较大小。\n\n- 平方的特点是会把负数变成正数，所以一个负数和一个正数平方后的大小要根据绝对值来比较。\n\n> 方法二：从两边向中间：\n\n- 从两边向中间搜索数字是从大到小的，所以需要提前申请好数组空间，然后从后向前写入。\n\n### python代码\n\n找到正负分界点，然后左右遍历比较\n\n```python\nclass Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        # 由于nums有序，所以先找到由负转正的位置i\n        for i, num in enumerate(nums):\n            if num >= 0:\n                break\n        \n        res = []  # 存储新结果\n        left, right = i-1, i  # 双指针，left指向绝对值最小的负值，right指向最小的正值\n        while left>=0 and right < len(nums):  # 分别向左向右遍历，并比较大小\n            if nums[left]**2 < nums[right]**2:\n                res.append(nums[left]**2)\n                left -= 1\n            else:\n                res.append(nums[right]**2)\n                right += 1\n        \n        if left < 0:  # 当左边遍历结束后，把右边剩下的加入结果\n            while right < len(nums):\n                res.append(nums[right]**2)\n                right += 1\n        else:  # 当右边遍历结束后，把左边剩下的加入结果\n            while left >= 0:\n                res.append(nums[left]**2)\n                left -= 1\n        \n        return res\n```\n\n从两边到中间，双指针\n\n```python\nclass Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        i, j = 0, len(nums) - 1  # 起始位置\n        res = [-1] * len(nums)  # 存储结果\n        k = len(nums) - 1  # 指向res中的位置\n        while i <= j:\n            if nums[i]**2 > nums[j]**2:\n                res[k] = nums[i]**2\n                i += 1  # i向右移一位\n            else:\n                res[k] = nums[j]**2\n                j -= 1  # j向左移一位\n            k -= 1\n        \n        return res\n```\n\n## 209.长度最小的子数组\n\n> [力扣题目链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n给定一个含有 n 个正整数的数组和一个正整数 target ，找出该数组中满足其和 ≥ target 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n\n示例 1：\n```\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n示例 2：\n```\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n```\n\n### 思路\n\n> 暴力解法\n\n- 连续子数组的长度大小从0至length依次遍历，当和>=target，返回连续子数组大小\n\n> 双指针（可变滑动窗口）\n\n- 窗口的值< target，增大窗口\n- 窗口的值>= target，缩小窗口\n\n### python代码\n\n> 暴力解法 - 超时\n\n```python\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        len_window = 1  # 连续子数组的长度\n        length = len(nums)\n        while len_window <= length: # 假设连续子数组大小从1至length依次遍历\n            i, j = 0, len_window  # 指向连续子数组的开始和结尾\n            sum_window = sum(nums[0:len_window])  # sum_window 记录长度为len_window的连续子数组的和\n            if sum_window >= target:\n                return len_window\n\n            while j < length:  # 连续子数组向右滑动\n                sum_window = sum_window - nums[i] + nums[j]  # 记录更新后的和\n                if sum_window >= target:\n                    return len_window\n                i += 1\n                j += 1 \n\n            len_window += 1\n        return 0\n```\n\n双指针（可变滑动窗口）\n```python\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        i, j = 0, 0  # i和j分别为滑动窗口起始位置和终止位置\n        sum_window = 0  # 记录滑动窗口和\n        min_window = float(\"inf\")  # 记录最小滑动窗口的大小，初始为无穷大\n\n        while j < len(nums):\n            sum_window += nums[j]  # 当窗口和小于target则扩大窗口       \n            j += 1\n\n            while sum_window >= target:  # 当窗口和大于等于target则缩小窗口     \n                sum_window -= nums[i]\n                i += 1\n                min_window = min(j-i+1, min_window)   # 更新最小滑动窗口的大小\n\n        return 0 if min_window == float(\"inf\") else min_window\n```\n\n## 59.螺旋矩阵II \n\n> [力扣题目链接](https://leetcode.cn/problems/spiral-matrix-ii/)\n\n给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n示例 1：\n```\n输入：n = 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n```\n\n示例 2：\n```\n输入：n = 1\n输出：[[1]]\n```\n\n### 思路\n\n> 循环填充\n\n- 过程：填充上行，从左到右；填充右列，从上到下；填充下行，从右到左；填充左列，从下到上。\n- 每条边的填充都要坚持循环一致的原则，左闭右开或者左开右闭。\n\n### python代码\n\n```python\nclass Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        matrix = [[0] * n for _ in range(n)]\n        startx, starty = 0, 0  # 每圈循环的起始位置\n        loop = n // 2  # 循环的圈数（每圈循环边长会减2）\n        count = 1  # 需要填充的数字\n        offset = 1  # 每圈的偏移量，每次循环右边界收缩一位\n        \n        while loop > 0:\n            for j in range(starty, n - offset):  # 填充上面一条边，从左至右，左闭右开\n                matrix[startx][j] = count\n                count += 1\n                print(startx, j)\n            j += 1  # j移到下一个位置（最右）\n            for i in range(startx, n-offset):  # 填充右边一条边，从上至下，上闭下开\n                matrix[i][j] = count\n                count += 1\n                print(i, j)\n            i += 1  # i移到下一个位置（最下）\n            for j in range(j, starty, -1):  # 填充下边一条边，从右至左，右闭左开\n                matrix[i][j] =count\n                count += 1\n                print(i, j)\n            for i in range(i, startx, -1):  # 填充左边一条边，从下至上，下闭上开\n                matrix[i][starty] = count\n                count += 1\n                print(i, starty)\n            \n            startx += 1  # 一圈循环结束，更新起始位置、偏移量、剩余循环圈数\n            starty += 1\n            offset += 1\n            loop -= 1\n        \n        if n % 2 == 1:  # n为奇数时，填充中心点\n            print(startx, starty, count)\n            matrix[startx][starty] = count\n\n        return matrix\n```\n","source":"_posts/06 LeetCode刷题 Day2 数组 977.有序数组的平方 209.长度最小的子数组 59.螺旋矩阵II.md","raw":"---\ntitle: LeetCode刷题 Day2 数组 | 977.有序数组的平方 209.长度最小的子数组 59.螺旋矩阵II\ntag:\n  - LeetCode\ncategories:\n  - [算法刷题, 代码随想录]\narticle_type: 0\nno_word_count: false\nno_toc: false\nno_date: false\nno_declare: false\nno_reward: false\nno_comments: false\nno_share: false\nno_footer: false\nmathjax: false\nabbrlink: 931914af\ndate: 2022-11-19\ntop:\n---\n\n- LeetCode 977.有序数组的平方\n- LeetCode 209.长度最小的子数组\n- LeetCode 59.螺旋矩阵II\n\n<!-- more -->\n\n## 977.有序数组的平方\n\n> [力扣题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n示例 1：\n```\n输入：nums = [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n```\n\n示例 2：\n```\n输入：nums = [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n```\n\n### 思路\n\n由于数组有序，负数平方之后可能成为最大数，所以平方后的最大值一定在数组的两端。\n\n> 方法一：从中间向两边：找到正负分界点，然后分别向左向右遍历比较大小。\n\n- 平方的特点是会把负数变成正数，所以一个负数和一个正数平方后的大小要根据绝对值来比较。\n\n> 方法二：从两边向中间：\n\n- 从两边向中间搜索数字是从大到小的，所以需要提前申请好数组空间，然后从后向前写入。\n\n### python代码\n\n找到正负分界点，然后左右遍历比较\n\n```python\nclass Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        # 由于nums有序，所以先找到由负转正的位置i\n        for i, num in enumerate(nums):\n            if num >= 0:\n                break\n        \n        res = []  # 存储新结果\n        left, right = i-1, i  # 双指针，left指向绝对值最小的负值，right指向最小的正值\n        while left>=0 and right < len(nums):  # 分别向左向右遍历，并比较大小\n            if nums[left]**2 < nums[right]**2:\n                res.append(nums[left]**2)\n                left -= 1\n            else:\n                res.append(nums[right]**2)\n                right += 1\n        \n        if left < 0:  # 当左边遍历结束后，把右边剩下的加入结果\n            while right < len(nums):\n                res.append(nums[right]**2)\n                right += 1\n        else:  # 当右边遍历结束后，把左边剩下的加入结果\n            while left >= 0:\n                res.append(nums[left]**2)\n                left -= 1\n        \n        return res\n```\n\n从两边到中间，双指针\n\n```python\nclass Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        i, j = 0, len(nums) - 1  # 起始位置\n        res = [-1] * len(nums)  # 存储结果\n        k = len(nums) - 1  # 指向res中的位置\n        while i <= j:\n            if nums[i]**2 > nums[j]**2:\n                res[k] = nums[i]**2\n                i += 1  # i向右移一位\n            else:\n                res[k] = nums[j]**2\n                j -= 1  # j向左移一位\n            k -= 1\n        \n        return res\n```\n\n## 209.长度最小的子数组\n\n> [力扣题目链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n给定一个含有 n 个正整数的数组和一个正整数 target ，找出该数组中满足其和 ≥ target 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n\n示例 1：\n```\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n示例 2：\n```\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n```\n\n### 思路\n\n> 暴力解法\n\n- 连续子数组的长度大小从0至length依次遍历，当和>=target，返回连续子数组大小\n\n> 双指针（可变滑动窗口）\n\n- 窗口的值< target，增大窗口\n- 窗口的值>= target，缩小窗口\n\n### python代码\n\n> 暴力解法 - 超时\n\n```python\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        len_window = 1  # 连续子数组的长度\n        length = len(nums)\n        while len_window <= length: # 假设连续子数组大小从1至length依次遍历\n            i, j = 0, len_window  # 指向连续子数组的开始和结尾\n            sum_window = sum(nums[0:len_window])  # sum_window 记录长度为len_window的连续子数组的和\n            if sum_window >= target:\n                return len_window\n\n            while j < length:  # 连续子数组向右滑动\n                sum_window = sum_window - nums[i] + nums[j]  # 记录更新后的和\n                if sum_window >= target:\n                    return len_window\n                i += 1\n                j += 1 \n\n            len_window += 1\n        return 0\n```\n\n双指针（可变滑动窗口）\n```python\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        i, j = 0, 0  # i和j分别为滑动窗口起始位置和终止位置\n        sum_window = 0  # 记录滑动窗口和\n        min_window = float(\"inf\")  # 记录最小滑动窗口的大小，初始为无穷大\n\n        while j < len(nums):\n            sum_window += nums[j]  # 当窗口和小于target则扩大窗口       \n            j += 1\n\n            while sum_window >= target:  # 当窗口和大于等于target则缩小窗口     \n                sum_window -= nums[i]\n                i += 1\n                min_window = min(j-i+1, min_window)   # 更新最小滑动窗口的大小\n\n        return 0 if min_window == float(\"inf\") else min_window\n```\n\n## 59.螺旋矩阵II \n\n> [力扣题目链接](https://leetcode.cn/problems/spiral-matrix-ii/)\n\n给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n示例 1：\n```\n输入：n = 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n```\n\n示例 2：\n```\n输入：n = 1\n输出：[[1]]\n```\n\n### 思路\n\n> 循环填充\n\n- 过程：填充上行，从左到右；填充右列，从上到下；填充下行，从右到左；填充左列，从下到上。\n- 每条边的填充都要坚持循环一致的原则，左闭右开或者左开右闭。\n\n### python代码\n\n```python\nclass Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        matrix = [[0] * n for _ in range(n)]\n        startx, starty = 0, 0  # 每圈循环的起始位置\n        loop = n // 2  # 循环的圈数（每圈循环边长会减2）\n        count = 1  # 需要填充的数字\n        offset = 1  # 每圈的偏移量，每次循环右边界收缩一位\n        \n        while loop > 0:\n            for j in range(starty, n - offset):  # 填充上面一条边，从左至右，左闭右开\n                matrix[startx][j] = count\n                count += 1\n                print(startx, j)\n            j += 1  # j移到下一个位置（最右）\n            for i in range(startx, n-offset):  # 填充右边一条边，从上至下，上闭下开\n                matrix[i][j] = count\n                count += 1\n                print(i, j)\n            i += 1  # i移到下一个位置（最下）\n            for j in range(j, starty, -1):  # 填充下边一条边，从右至左，右闭左开\n                matrix[i][j] =count\n                count += 1\n                print(i, j)\n            for i in range(i, startx, -1):  # 填充左边一条边，从下至上，下闭上开\n                matrix[i][starty] = count\n                count += 1\n                print(i, starty)\n            \n            startx += 1  # 一圈循环结束，更新起始位置、偏移量、剩余循环圈数\n            starty += 1\n            offset += 1\n            loop -= 1\n        \n        if n % 2 == 1:  # n为奇数时，填充中心点\n            print(startx, starty, count)\n            matrix[startx][starty] = count\n\n        return matrix\n```\n","slug":"06 LeetCode刷题 Day2 数组 977.有序数组的平方 209.长度最小的子数组 59.螺旋矩阵II","published":1,"updated":"2022-11-26T20:38:31.513Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clb218l4t001364rg3vyycs0p","content":"<ul>\n<li>LeetCode 977.有序数组的平方</li>\n<li>LeetCode 209.长度最小的子数组</li>\n<li>LeetCode 59.螺旋矩阵II</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977.有序数组的平方\"></a>977.有序数组的平方</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/squares-of-a-sorted-array/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-4,-1,0,3,10]</span><br><span class=\"line\">输出：[0,1,9,16,100]</span><br><span class=\"line\">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class=\"line\">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-7,-3,2,3,11]</span><br><span class=\"line\">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>由于数组有序，负数平方之后可能成为最大数，所以平方后的最大值一定在数组的两端。</p>\n<blockquote>\n<p>方法一：从中间向两边：找到正负分界点，然后分别向左向右遍历比较大小。</p>\n</blockquote>\n<ul>\n<li>平方的特点是会把负数变成正数，所以一个负数和一个正数平方后的大小要根据绝对值来比较。</li>\n</ul>\n<blockquote>\n<p>方法二：从两边向中间：</p>\n</blockquote>\n<ul>\n<li>从两边向中间搜索数字是从大到小的，所以需要提前申请好数组空间，然后从后向前写入。</li>\n</ul>\n<h3 id=\"python代码\"><a href=\"#python代码\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><p>找到正负分界点，然后左右遍历比较</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">sortedSquares</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        <span class=\"comment\"># 由于nums有序，所以先找到由负转正的位置i</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        res = []  <span class=\"comment\"># 存储新结果</span></span><br><span class=\"line\">        left, right = i-<span class=\"number\">1</span>, i  <span class=\"comment\"># 双指针，left指向绝对值最小的负值，right指向最小的正值</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> right &lt; <span class=\"built_in\">len</span>(nums):  <span class=\"comment\"># 分别向左向右遍历，并比较大小</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left]**<span class=\"number\">2</span> &lt; nums[right]**<span class=\"number\">2</span>:</span><br><span class=\"line\">                res.append(nums[left]**<span class=\"number\">2</span>)</span><br><span class=\"line\">                left -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res.append(nums[right]**<span class=\"number\">2</span>)</span><br><span class=\"line\">                right += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; <span class=\"number\">0</span>:  <span class=\"comment\"># 当左边遍历结束后，把右边剩下的加入结果</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> right &lt; <span class=\"built_in\">len</span>(nums):</span><br><span class=\"line\">                res.append(nums[right]**<span class=\"number\">2</span>)</span><br><span class=\"line\">                right += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:  <span class=\"comment\"># 当右边遍历结束后，把左边剩下的加入结果</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                res.append(nums[left]**<span class=\"number\">2</span>)</span><br><span class=\"line\">                left -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<p>从两边到中间，双指针</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">sortedSquares</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span>  <span class=\"comment\"># 起始位置</span></span><br><span class=\"line\">        res = [-<span class=\"number\">1</span>] * <span class=\"built_in\">len</span>(nums)  <span class=\"comment\"># 存储结果</span></span><br><span class=\"line\">        k = <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span>  <span class=\"comment\"># 指向res中的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt;= j:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i]**<span class=\"number\">2</span> &gt; nums[j]**<span class=\"number\">2</span>:</span><br><span class=\"line\">                res[k] = nums[i]**<span class=\"number\">2</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span>  <span class=\"comment\"># i向右移一位</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res[k] = nums[j]**<span class=\"number\">2</span></span><br><span class=\"line\">                j -= <span class=\"number\">1</span>  <span class=\"comment\"># j向左移一位</span></span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209.长度最小的子数组\"></a>209.长度最小的子数组</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/minimum-size-subarray-sum/\">力扣题目链接</a></p>\n</blockquote>\n<p>给定一个含有 n 个正整数的数组和一个正整数 target ，找出该数组中满足其和 ≥ target 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><blockquote>\n<p>暴力解法</p>\n</blockquote>\n<ul>\n<li>连续子数组的长度大小从0至length依次遍历，当和&gt;=target，返回连续子数组大小</li>\n</ul>\n<blockquote>\n<p>双指针（可变滑动窗口）</p>\n</blockquote>\n<ul>\n<li>窗口的值&lt; target，增大窗口</li>\n<li>窗口的值&gt;= target，缩小窗口</li>\n</ul>\n<h3 id=\"python代码-1\"><a href=\"#python代码-1\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><blockquote>\n<p>暴力解法 - 超时</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">minSubArrayLen</span>(<span class=\"params\">self, target: <span class=\"built_in\">int</span>, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        len_window = <span class=\"number\">1</span>  <span class=\"comment\"># 连续子数组的长度</span></span><br><span class=\"line\">        length = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len_window &lt;= length: <span class=\"comment\"># 假设连续子数组大小从1至length依次遍历</span></span><br><span class=\"line\">            i, j = <span class=\"number\">0</span>, len_window  <span class=\"comment\"># 指向连续子数组的开始和结尾</span></span><br><span class=\"line\">            sum_window = <span class=\"built_in\">sum</span>(nums[<span class=\"number\">0</span>:len_window])  <span class=\"comment\"># sum_window 记录长度为len_window的连续子数组的和</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> sum_window &gt;= target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> len_window</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; length:  <span class=\"comment\"># 连续子数组向右滑动</span></span><br><span class=\"line\">                sum_window = sum_window - nums[i] + nums[j]  <span class=\"comment\"># 记录更新后的和</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum_window &gt;= target:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> len_window</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span> </span><br><span class=\"line\"></span><br><span class=\"line\">            len_window += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>双指针（可变滑动窗口）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">minSubArrayLen</span>(<span class=\"params\">self, target: <span class=\"built_in\">int</span>, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span>  <span class=\"comment\"># i和j分别为滑动窗口起始位置和终止位置</span></span><br><span class=\"line\">        sum_window = <span class=\"number\">0</span>  <span class=\"comment\"># 记录滑动窗口和</span></span><br><span class=\"line\">        min_window = <span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>)  <span class=\"comment\"># 记录最小滑动窗口的大小，初始为无穷大</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; <span class=\"built_in\">len</span>(nums):</span><br><span class=\"line\">            sum_window += nums[j]  <span class=\"comment\"># 当窗口和小于target则扩大窗口       </span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> sum_window &gt;= target:  <span class=\"comment\"># 当窗口和大于等于target则缩小窗口     </span></span><br><span class=\"line\">                sum_window -= nums[i]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                min_window = <span class=\"built_in\">min</span>(j-i+<span class=\"number\">1</span>, min_window)   <span class=\"comment\"># 更新最小滑动窗口的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"keyword\">if</span> min_window == <span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>) <span class=\"keyword\">else</span> min_window</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"59-螺旋矩阵II\"><a href=\"#59-螺旋矩阵II\" class=\"headerlink\" title=\"59.螺旋矩阵II\"></a>59.螺旋矩阵II</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/spiral-matrix-ii/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 3</span><br><span class=\"line\">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：[[1]]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><blockquote>\n<p>循环填充</p>\n</blockquote>\n<ul>\n<li>过程：填充上行，从左到右；填充右列，从上到下；填充下行，从右到左；填充左列，从下到上。</li>\n<li>每条边的填充都要坚持循环一致的原则，左闭右开或者左开右闭。</li>\n</ul>\n<h3 id=\"python代码-2\"><a href=\"#python代码-2\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">generateMatrix</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:</span><br><span class=\"line\">        matrix = [[<span class=\"number\">0</span>] * n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">        startx, starty = <span class=\"number\">0</span>, <span class=\"number\">0</span>  <span class=\"comment\"># 每圈循环的起始位置</span></span><br><span class=\"line\">        loop = n // <span class=\"number\">2</span>  <span class=\"comment\"># 循环的圈数（每圈循环边长会减2）</span></span><br><span class=\"line\">        count = <span class=\"number\">1</span>  <span class=\"comment\"># 需要填充的数字</span></span><br><span class=\"line\">        offset = <span class=\"number\">1</span>  <span class=\"comment\"># 每圈的偏移量，每次循环右边界收缩一位</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> loop &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(starty, n - offset):  <span class=\"comment\"># 填充上面一条边，从左至右，左闭右开</span></span><br><span class=\"line\">                matrix[startx][j] = count</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(startx, j)</span><br><span class=\"line\">            j += <span class=\"number\">1</span>  <span class=\"comment\"># j移到下一个位置（最右）</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(startx, n-offset):  <span class=\"comment\"># 填充右边一条边，从上至下，上闭下开</span></span><br><span class=\"line\">                matrix[i][j] = count</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i, j)</span><br><span class=\"line\">            i += <span class=\"number\">1</span>  <span class=\"comment\"># i移到下一个位置（最下）</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(j, starty, -<span class=\"number\">1</span>):  <span class=\"comment\"># 填充下边一条边，从右至左，右闭左开</span></span><br><span class=\"line\">                matrix[i][j] =count</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i, j)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i, startx, -<span class=\"number\">1</span>):  <span class=\"comment\"># 填充左边一条边，从下至上，下闭上开</span></span><br><span class=\"line\">                matrix[i][starty] = count</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i, starty)</span><br><span class=\"line\">            </span><br><span class=\"line\">            startx += <span class=\"number\">1</span>  <span class=\"comment\"># 一圈循环结束，更新起始位置、偏移量、剩余循环圈数</span></span><br><span class=\"line\">            starty += <span class=\"number\">1</span></span><br><span class=\"line\">            offset += <span class=\"number\">1</span></span><br><span class=\"line\">            loop -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span>:  <span class=\"comment\"># n为奇数时，填充中心点</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(startx, starty, count)</span><br><span class=\"line\">            matrix[startx][starty] = count</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> matrix</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<ul>\n<li>LeetCode 977.有序数组的平方</li>\n<li>LeetCode 209.长度最小的子数组</li>\n<li>LeetCode 59.螺旋矩阵II</li>\n</ul>","more":"<h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977.有序数组的平方\"></a>977.有序数组的平方</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/squares-of-a-sorted-array/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-4,-1,0,3,10]</span><br><span class=\"line\">输出：[0,1,9,16,100]</span><br><span class=\"line\">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class=\"line\">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-7,-3,2,3,11]</span><br><span class=\"line\">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>由于数组有序，负数平方之后可能成为最大数，所以平方后的最大值一定在数组的两端。</p>\n<blockquote>\n<p>方法一：从中间向两边：找到正负分界点，然后分别向左向右遍历比较大小。</p>\n</blockquote>\n<ul>\n<li>平方的特点是会把负数变成正数，所以一个负数和一个正数平方后的大小要根据绝对值来比较。</li>\n</ul>\n<blockquote>\n<p>方法二：从两边向中间：</p>\n</blockquote>\n<ul>\n<li>从两边向中间搜索数字是从大到小的，所以需要提前申请好数组空间，然后从后向前写入。</li>\n</ul>\n<h3 id=\"python代码\"><a href=\"#python代码\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><p>找到正负分界点，然后左右遍历比较</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">sortedSquares</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        <span class=\"comment\"># 由于nums有序，所以先找到由负转正的位置i</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        res = []  <span class=\"comment\"># 存储新结果</span></span><br><span class=\"line\">        left, right = i-<span class=\"number\">1</span>, i  <span class=\"comment\"># 双指针，left指向绝对值最小的负值，right指向最小的正值</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> right &lt; <span class=\"built_in\">len</span>(nums):  <span class=\"comment\"># 分别向左向右遍历，并比较大小</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left]**<span class=\"number\">2</span> &lt; nums[right]**<span class=\"number\">2</span>:</span><br><span class=\"line\">                res.append(nums[left]**<span class=\"number\">2</span>)</span><br><span class=\"line\">                left -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res.append(nums[right]**<span class=\"number\">2</span>)</span><br><span class=\"line\">                right += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; <span class=\"number\">0</span>:  <span class=\"comment\"># 当左边遍历结束后，把右边剩下的加入结果</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> right &lt; <span class=\"built_in\">len</span>(nums):</span><br><span class=\"line\">                res.append(nums[right]**<span class=\"number\">2</span>)</span><br><span class=\"line\">                right += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:  <span class=\"comment\"># 当右边遍历结束后，把左边剩下的加入结果</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                res.append(nums[left]**<span class=\"number\">2</span>)</span><br><span class=\"line\">                left -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<p>从两边到中间，双指针</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">sortedSquares</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span>  <span class=\"comment\"># 起始位置</span></span><br><span class=\"line\">        res = [-<span class=\"number\">1</span>] * <span class=\"built_in\">len</span>(nums)  <span class=\"comment\"># 存储结果</span></span><br><span class=\"line\">        k = <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span>  <span class=\"comment\"># 指向res中的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt;= j:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i]**<span class=\"number\">2</span> &gt; nums[j]**<span class=\"number\">2</span>:</span><br><span class=\"line\">                res[k] = nums[i]**<span class=\"number\">2</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span>  <span class=\"comment\"># i向右移一位</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res[k] = nums[j]**<span class=\"number\">2</span></span><br><span class=\"line\">                j -= <span class=\"number\">1</span>  <span class=\"comment\"># j向左移一位</span></span><br><span class=\"line\">            k -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209.长度最小的子数组\"></a>209.长度最小的子数组</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/minimum-size-subarray-sum/\">力扣题目链接</a></p>\n</blockquote>\n<p>给定一个含有 n 个正整数的数组和一个正整数 target ，找出该数组中满足其和 ≥ target 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><blockquote>\n<p>暴力解法</p>\n</blockquote>\n<ul>\n<li>连续子数组的长度大小从0至length依次遍历，当和&gt;=target，返回连续子数组大小</li>\n</ul>\n<blockquote>\n<p>双指针（可变滑动窗口）</p>\n</blockquote>\n<ul>\n<li>窗口的值&lt; target，增大窗口</li>\n<li>窗口的值&gt;= target，缩小窗口</li>\n</ul>\n<h3 id=\"python代码-1\"><a href=\"#python代码-1\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><blockquote>\n<p>暴力解法 - 超时</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">minSubArrayLen</span>(<span class=\"params\">self, target: <span class=\"built_in\">int</span>, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        len_window = <span class=\"number\">1</span>  <span class=\"comment\"># 连续子数组的长度</span></span><br><span class=\"line\">        length = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> len_window &lt;= length: <span class=\"comment\"># 假设连续子数组大小从1至length依次遍历</span></span><br><span class=\"line\">            i, j = <span class=\"number\">0</span>, len_window  <span class=\"comment\"># 指向连续子数组的开始和结尾</span></span><br><span class=\"line\">            sum_window = <span class=\"built_in\">sum</span>(nums[<span class=\"number\">0</span>:len_window])  <span class=\"comment\"># sum_window 记录长度为len_window的连续子数组的和</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> sum_window &gt;= target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> len_window</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; length:  <span class=\"comment\"># 连续子数组向右滑动</span></span><br><span class=\"line\">                sum_window = sum_window - nums[i] + nums[j]  <span class=\"comment\"># 记录更新后的和</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> sum_window &gt;= target:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> len_window</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span> </span><br><span class=\"line\"></span><br><span class=\"line\">            len_window += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>双指针（可变滑动窗口）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">minSubArrayLen</span>(<span class=\"params\">self, target: <span class=\"built_in\">int</span>, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span>  <span class=\"comment\"># i和j分别为滑动窗口起始位置和终止位置</span></span><br><span class=\"line\">        sum_window = <span class=\"number\">0</span>  <span class=\"comment\"># 记录滑动窗口和</span></span><br><span class=\"line\">        min_window = <span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>)  <span class=\"comment\"># 记录最小滑动窗口的大小，初始为无穷大</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; <span class=\"built_in\">len</span>(nums):</span><br><span class=\"line\">            sum_window += nums[j]  <span class=\"comment\"># 当窗口和小于target则扩大窗口       </span></span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> sum_window &gt;= target:  <span class=\"comment\"># 当窗口和大于等于target则缩小窗口     </span></span><br><span class=\"line\">                sum_window -= nums[i]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                min_window = <span class=\"built_in\">min</span>(j-i+<span class=\"number\">1</span>, min_window)   <span class=\"comment\"># 更新最小滑动窗口的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"keyword\">if</span> min_window == <span class=\"built_in\">float</span>(<span class=\"string\">&quot;inf&quot;</span>) <span class=\"keyword\">else</span> min_window</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"59-螺旋矩阵II\"><a href=\"#59-螺旋矩阵II\" class=\"headerlink\" title=\"59.螺旋矩阵II\"></a>59.螺旋矩阵II</h2><blockquote>\n<p><a href=\"https://leetcode.cn/problems/spiral-matrix-ii/\">力扣题目链接</a></p>\n</blockquote>\n<p>给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 3</span><br><span class=\"line\">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：[[1]]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><blockquote>\n<p>循环填充</p>\n</blockquote>\n<ul>\n<li>过程：填充上行，从左到右；填充右列，从上到下；填充下行，从右到左；填充左列，从下到上。</li>\n<li>每条边的填充都要坚持循环一致的原则，左闭右开或者左开右闭。</li>\n</ul>\n<h3 id=\"python代码-2\"><a href=\"#python代码-2\" class=\"headerlink\" title=\"python代码\"></a>python代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">generateMatrix</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:</span><br><span class=\"line\">        matrix = [[<span class=\"number\">0</span>] * n <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">        startx, starty = <span class=\"number\">0</span>, <span class=\"number\">0</span>  <span class=\"comment\"># 每圈循环的起始位置</span></span><br><span class=\"line\">        loop = n // <span class=\"number\">2</span>  <span class=\"comment\"># 循环的圈数（每圈循环边长会减2）</span></span><br><span class=\"line\">        count = <span class=\"number\">1</span>  <span class=\"comment\"># 需要填充的数字</span></span><br><span class=\"line\">        offset = <span class=\"number\">1</span>  <span class=\"comment\"># 每圈的偏移量，每次循环右边界收缩一位</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> loop &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(starty, n - offset):  <span class=\"comment\"># 填充上面一条边，从左至右，左闭右开</span></span><br><span class=\"line\">                matrix[startx][j] = count</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(startx, j)</span><br><span class=\"line\">            j += <span class=\"number\">1</span>  <span class=\"comment\"># j移到下一个位置（最右）</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(startx, n-offset):  <span class=\"comment\"># 填充右边一条边，从上至下，上闭下开</span></span><br><span class=\"line\">                matrix[i][j] = count</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i, j)</span><br><span class=\"line\">            i += <span class=\"number\">1</span>  <span class=\"comment\"># i移到下一个位置（最下）</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(j, starty, -<span class=\"number\">1</span>):  <span class=\"comment\"># 填充下边一条边，从右至左，右闭左开</span></span><br><span class=\"line\">                matrix[i][j] =count</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i, j)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i, startx, -<span class=\"number\">1</span>):  <span class=\"comment\"># 填充左边一条边，从下至上，下闭上开</span></span><br><span class=\"line\">                matrix[i][starty] = count</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i, starty)</span><br><span class=\"line\">            </span><br><span class=\"line\">            startx += <span class=\"number\">1</span>  <span class=\"comment\"># 一圈循环结束，更新起始位置、偏移量、剩余循环圈数</span></span><br><span class=\"line\">            starty += <span class=\"number\">1</span></span><br><span class=\"line\">            offset += <span class=\"number\">1</span></span><br><span class=\"line\">            loop -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span>:  <span class=\"comment\"># n为奇数时，填充中心点</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(startx, starty, count)</span><br><span class=\"line\">            matrix[startx][starty] = count</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> matrix</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"clb218l4l000k64rg6j8p9mkq","category_id":"clb218l4k000i64rghjjbbxto","_id":"clb218l4p000s64rg1i2v7vgg"},{"post_id":"clb218l4e000b64rg7pk0d3qo","category_id":"clb218l4k000i64rghjjbbxto","_id":"clb218l4q000x64rgcp2gc5ou"},{"post_id":"clb218l4m000l64rgcu8e6tib","category_id":"clb218l4k000i64rghjjbbxto","_id":"clb218l4s001064rg6klvde24"},{"post_id":"clb218l4o000r64rg2fed3azg","category_id":"clb218l4k000i64rghjjbbxto","_id":"clb218l4t001464rghzb2hmwh"},{"post_id":"clb218l4t001364rg3vyycs0p","category_id":"clb218l4h000e64rg3yoz4s32","_id":"clb218l4v001c64rgdgez4j3b"},{"post_id":"clb218l4t001364rg3vyycs0p","category_id":"clb218l4t001164rg8dfpgba9","_id":"clb218l4w001f64rgccgv4s8f"},{"post_id":"clb218l4a000a64rghqdf1jov","category_id":"clb218l4h000e64rg3yoz4s32","_id":"clb218l4w001i64rg0msdcnuq"},{"post_id":"clb218l4a000a64rghqdf1jov","category_id":"clb218l4t001164rg8dfpgba9","_id":"clb218l4x001k64rgfj4vfypa"},{"post_id":"clb218l4n000p64rgh3b2a7v2","category_id":"clb218l4n000n64rgfd1d9ms1","_id":"clb218l4y001o64rghxbw6syr"},{"post_id":"clb218l4n000p64rgh3b2a7v2","category_id":"clb218l4v001d64rg0aj821kv","_id":"clb218l4y001q64rg7m1z2x36"},{"post_id":"clb218l4i000f64rghshqdrfi","category_id":"clb218l4n000n64rgfd1d9ms1","_id":"clb218l4z001y64rg0cgz5in3"},{"post_id":"clb218l4i000f64rghshqdrfi","category_id":"clb218l4v001d64rg0aj821kv","_id":"clb218l4z001z64rga0reetes"},{"post_id":"clb218l4s000z64rgd8q4dycz","category_id":"clb218l4h000e64rg3yoz4s32","_id":"clb218l50002164rg57dt5b27"},{"post_id":"clb218l4s000z64rgd8q4dycz","category_id":"clb218l4t001164rg8dfpgba9","_id":"clb218l50002264rggsg92fl3"},{"post_id":"clb218l4g000d64rg9ejs4oru","category_id":"clb218l4n000n64rgfd1d9ms1","_id":"clb218l50002464rg3uxzevz6"},{"post_id":"clb218l4g000d64rg9ejs4oru","category_id":"clb218l4w001j64rggqe24105","_id":"clb218l51002664rg1bxzfn7q"},{"post_id":"clb218l4g000d64rg9ejs4oru","category_id":"clb218l50002064rg4zfabl2h","_id":"clb218l51002764rghs7o1bhi"},{"post_id":"clb218l4q000w64rgg5smdvxd","category_id":"clb218l4v001864rgcb9i14gu","_id":"clb218l51002864rgfvhv5qnd"},{"post_id":"clb218l4q000w64rgg5smdvxd","category_id":"clb218l50002364rg003rfcm5","_id":"clb218l51002964rgcl4k13lw"},{"post_id":"clb218l4j000g64rg09fd2ufp","category_id":"clb218l4v001864rgcb9i14gu","_id":"clb218l51002a64rg7p106ejc"},{"post_id":"clb218l4j000g64rg09fd2ufp","category_id":"clb218l4z001x64rgf2u824gt","_id":"clb218l51002b64rgcsxt38pw"},{"post_id":"clb218l4j000g64rg09fd2ufp","category_id":"clb218l4v001864rgcb9i14gu","_id":"clb218l51002c64rgf7fece4x"},{"post_id":"clb218l4j000g64rg09fd2ufp","category_id":"clb218l50002564rg8onzhsez","_id":"clb218l51002d64rg57sc0ynr"}],"PostTag":[{"post_id":"clb218l4a000a64rghqdf1jov","tag_id":"clb218l4g000c64rghoi814aj","_id":"clb218l4l000j64rga4bib1m0"},{"post_id":"clb218l4l000k64rg6j8p9mkq","tag_id":"clb218l4j000h64rg1wsc1dfj","_id":"clb218l4n000o64rg5oaza9m8"},{"post_id":"clb218l4e000b64rg7pk0d3qo","tag_id":"clb218l4j000h64rg1wsc1dfj","_id":"clb218l4o000q64rg0fq9h2sb"},{"post_id":"clb218l4m000l64rgcu8e6tib","tag_id":"clb218l4j000h64rg1wsc1dfj","_id":"clb218l4p000u64rgbps12d68"},{"post_id":"clb218l4o000r64rg2fed3azg","tag_id":"clb218l4j000h64rg1wsc1dfj","_id":"clb218l4s000y64rgbrkr3v03"},{"post_id":"clb218l4g000d64rg9ejs4oru","tag_id":"clb218l4n000m64rg447i9aom","_id":"clb218l4u001564rga2y597y2"},{"post_id":"clb218l4g000d64rg9ejs4oru","tag_id":"clb218l4p000t64rgfmdedklo","_id":"clb218l4u001664rge8f50dzi"},{"post_id":"clb218l4s000z64rgd8q4dycz","tag_id":"clb218l4g000c64rghoi814aj","_id":"clb218l4v001964rgef060e3q"},{"post_id":"clb218l4t001364rg3vyycs0p","tag_id":"clb218l4g000c64rghoi814aj","_id":"clb218l4v001a64rg7gf89dkx"},{"post_id":"clb218l4i000f64rghshqdrfi","tag_id":"clb218l4n000m64rg447i9aom","_id":"clb218l4w001e64rgf1n50j3w"},{"post_id":"clb218l4i000f64rghshqdrfi","tag_id":"clb218l4p000t64rgfmdedklo","_id":"clb218l4w001g64rg6sz08qrz"},{"post_id":"clb218l4j000g64rg09fd2ufp","tag_id":"clb218l4v001b64rg71735uf2","_id":"clb218l4y001n64rg04f67ox1"},{"post_id":"clb218l4j000g64rg09fd2ufp","tag_id":"clb218l4w001h64rg0koe9e5e","_id":"clb218l4y001p64rgaiapaegd"},{"post_id":"clb218l4n000p64rgh3b2a7v2","tag_id":"clb218l4n000m64rg447i9aom","_id":"clb218l4y001t64rghcjc9pdn"},{"post_id":"clb218l4n000p64rgh3b2a7v2","tag_id":"clb218l4p000t64rgfmdedklo","_id":"clb218l4z001u64rg8z90abxe"},{"post_id":"clb218l4q000w64rgg5smdvxd","tag_id":"clb218l4y001r64rg50j95f94","_id":"clb218l4z001w64rg363t851b"}],"Tag":[{"name":"LeetCode","_id":"clb218l4g000c64rghoi814aj"},{"name":"linux","_id":"clb218l4j000h64rg1wsc1dfj"},{"name":"论文阅读","_id":"clb218l4n000m64rg447i9aom"},{"name":"图像篡改","_id":"clb218l4p000t64rgfmdedklo"},{"name":"hexo","_id":"clb218l4v001b64rg71735uf2"},{"name":"yilia","_id":"clb218l4w001h64rg0koe9e5e"},{"name":"三水","_id":"clb218l4y001r64rg50j95f94"}]}}